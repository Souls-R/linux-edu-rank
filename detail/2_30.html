<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_29.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><span>[30]</span><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_31.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8ef42ddd9a53b73e6fc3934278710c27f80f324f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 23 10:45:54 2014 -0400

    USB: Avoid runtime suspend loops for HCDs that can't handle suspend/resume
    
    Not all host controller drivers have bus-suspend and bus-resume
    methods.  When one doesn't, it will cause problems if runtime PM is
    enabled in the kernel.  The PM core will attempt to suspend the
    controller's root hub, the suspend will fail because there is no
    bus-suspend routine, and a -EBUSY error code will be returned to the
    PM core.  This will cause the suspend attempt to be repeated shortly
    thereafter, in a never-ending loop.
    
    Part of the problem is that the original error code -ENOENT gets
    changed to -EBUSY in usb_runtime_suspend(), on the grounds that the PM
    core will interpret -ENOENT as meaning that the root hub has gotten
    into a runtime-PM error state.  While this change is appropriate for
    real USB devices, it's not such a good idea for a root hub.  In fact,
    considering the root hub to be in a runtime-PM error state would not
    be far from the truth.  Therefore this patch updates
    usb_runtime_suspend() so that it adjusts error codes only for
    non-root-hub devices.
    
    Furthermore, the patch attempts to prevent the problem from occurring
    in the first place by not enabling runtime PM by default for root hubs
    whose host controller driver doesn't have bus_suspend and bus_resume
    methods.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Will Deacon &lt;will.deacon@arm.com&gt;
    Tested-by: Will Deacon &lt;will.deacon@arm.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 888881e5f292..4aeb10034de7 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1822,10 +1822,13 @@ int usb_runtime_suspend(struct device *dev)
 	if (status == -EAGAIN || status == -EBUSY)
 		usb_mark_last_busy(udev);
 
-	/* The PM core reacts badly unless the return code is 0,
-	 * -EAGAIN, or -EBUSY, so always return -EBUSY on an error.
+	/*
+	 * The PM core reacts badly unless the return code is 0,
+	 * -EAGAIN, or -EBUSY, so always return -EBUSY on an error
+	 * (except for root hubs, because they don't suspend through
+	 * an upstream port like other USB devices).
 	 */
-	if (status != 0)
+	if (status != 0 &amp;&amp; udev-&gt;parent)
 		return -EBUSY;
 	return status;
 }
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 090469ebfcff..229a73f64304 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1691,8 +1691,19 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 */
 	pm_runtime_set_autosuspend_delay(&amp;hdev-&gt;dev, 0);
 
-	/* Hubs have proper suspend/resume support. */
-	usb_enable_autosuspend(hdev);
+	/*
+	 * Hubs have proper suspend/resume support, except for root hubs
+	 * where the controller driver doesn't have bus_suspend and
+	 * bus_resume methods.
+	 */
+	if (hdev-&gt;parent) {		/* normal device */
+		usb_enable_autosuspend(hdev);
+	} else {			/* root hub */
+		const struct hc_driver *drv = bus_to_hcd(hdev-&gt;bus)-&gt;driver;
+
+		if (drv-&gt;bus_suspend &amp;&amp; drv-&gt;bus_resume)
+			usb_enable_autosuspend(hdev);
+	}
 
 	if (hdev-&gt;level == MAX_TOPO_LEVEL) {
 		dev_err(&amp;intf-&gt;dev,</pre><hr><pre>commit c1db30a2a79eb59997b13b8cabf2a50bea9f04e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 1 15:21:42 2014 -0400

    USB: OHCI: fix problem with global suspend on ATI controllers
    
    Some OHCI controllers from ATI/AMD seem to have difficulty with
    "global" USB suspend, that is, suspending an entire USB bus without
    setting the suspend feature for each port connected to a device.  When
    we try to resume the child devices, the controller gives timeout
    errors on the unsuspended ports, requiring resets, and can even cause
    ohci-hcd to hang; see
    
            http://marc.info/?l=linux-usb&amp;m=139514332820398&amp;w=2
    
    and the following messages.
    
    This patch fixes the problem by adding a new quirk flag to ohci-hcd.
    The flag causes the ohci_rh_suspend() routine to suspend each
    unsuspended, enabled port before suspending the root hub.  This
    effectively converts the "global" suspend to an ordinary root-hub
    suspend.  There is no need to unsuspend these ports when the root hub
    is resumed, because the child devices will be resumed anyway in the
    course of a normal system resume ("global" suspend is never used for
    runtime PM).
    
    This patch should be applied to all stable kernels which include
    commit 0aa2832dd0d9 (USB: use "global suspend" for system sleep on
    USB-2 buses) or a backported version thereof.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Peter Münster &lt;pmlists@free.fr&gt;
    Tested-by: Peter Münster &lt;pmlists@free.fr&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index c81c8721cc5a..cd871b895013 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -90,6 +90,24 @@ __acquires(ohci-&gt;lock)
 	dl_done_list (ohci);
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
+	/*
+	 * Some controllers don't handle "global" suspend properly if
+	 * there are unsuspended ports.  For these controllers, put all
+	 * the enabled ports into suspend before suspending the root hub.
+	 */
+	if (ohci-&gt;flags &amp; OHCI_QUIRK_GLOBAL_SUSPEND) {
+		__hc32 __iomem	*portstat = ohci-&gt;regs-&gt;roothub.portstatus;
+		int		i;
+		unsigned	temp;
+
+		for (i = 0; i &lt; ohci-&gt;num_ports; (++i, ++portstat)) {
+			temp = ohci_readl(ohci, portstat);
+			if ((temp &amp; (RH_PS_PES | RH_PS_PSS)) ==
+					RH_PS_PES)
+				ohci_writel(ohci, RH_PS_PSS, portstat);
+		}
+	}
+
 	/* maybe resume can wake root hub */
 	if (ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;do_remote_wakeup || autostop) {
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 90879e9ccbec..bb1509675727 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -160,6 +160,7 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
+	ohci-&gt;flags |= OHCI_QUIRK_GLOBAL_SUSPEND;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 9250cada13f0..4550ce05af7f 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -405,6 +405,8 @@ struct ohci_hcd {
 #define	OHCI_QUIRK_HUB_POWER	0x100			/* distrust firmware power/oc setup */
 #define	OHCI_QUIRK_AMD_PLL	0x200			/* AMD PLL quirk*/
 #define	OHCI_QUIRK_AMD_PREFETCH	0x400			/* pre-fetch for ISO transfer */
+#define	OHCI_QUIRK_GLOBAL_SUSPEND	0x800		/* must suspend ports */
+
 	// there are also chip quirks/bugs in init logic
 
 	struct work_struct	nec_work;	/* Worker for NEC quirk */</pre><hr><pre>commit 644373a4219add42123df69c8b7ce6a918475ccd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 28 10:51:15 2014 -0700

    [SCSI] Fix command result state propagation
    
    We're seeing a case where the contents of scmd-&gt;result isn't being reset after
    a SCSI command encounters an error, is resubmitted, times out and then gets
    handled.  The error handler acts on the stale result of the previous error
    instead of the timeout.  Fix this by properly zeroing the scmd-&gt;status before
    the command is resubmitted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index d020149ea8d4..2953bfa92da7 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -924,6 +924,7 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 	memset(scmd-&gt;cmnd, 0, BLK_MAX_CDB);
 	memset(&amp;scmd-&gt;sdb, 0, sizeof(scmd-&gt;sdb));
 	scmd-&gt;request-&gt;next_rq = NULL;
+	scmd-&gt;result = 0;
 
 	if (sense_bytes) {
 		scmd-&gt;sdb.length = min_t(unsigned, SCSI_SENSE_BUFFERSIZE,
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 7fa54fe51f63..9db097a28a74 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -137,6 +137,7 @@ static void __scsi_queue_insert(struct scsi_cmnd *cmd, int reason, int unbusy)
 	 * lock such that the kblockd_schedule_work() call happens
 	 * before blk_cleanup_queue() finishes.
 	 */
+	cmd-&gt;result = 0;
 	spin_lock_irqsave(q-&gt;queue_lock, flags);
 	blk_requeue_request(q, cmd-&gt;request);
 	kblockd_schedule_work(q, &amp;device-&gt;requeue_work);</pre><hr><pre>commit a2ff864b53eac9a0e9b05bfe9d1781ccd6c2af71
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 13:48:47 2014 -0400

    USB: fix crash during hotplug of PCI USB controller card
    
    The code in hcd-pci.c that matches up EHCI controllers with their
    companion UHCI or OHCI controllers assumes that the private drvdata
    fields don't get set too early.  However, it turns out that this field
    gets set by usb_create_hcd(), before hcd-pci expects it, and this can
    result in a crash when two controllers are probed in parallel (as can
    happen when a new controller card is hotplugged).
    
    The companions_rwsem lock was supposed to prevent this sort of thing,
    but usb_create_hcd() is called outside the scope of the rwsem.
    
    A simple solution is to check that the root-hub pointer has been
    initialized as well as the drvdata field.  This doesn't happen until
    usb_add_hcd() is called; that call and the check are both protected by
    the rwsem.
    
    This patch should be applied to stable kernels from 3.10 onward.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Stefani Seibold &lt;stefani@seibold.net&gt;
    Tested-by: Stefani Seibold &lt;stefani@seibold.net&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index d59d99347d54..1f02e65fe305 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -75,7 +75,7 @@ static void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,
 				PCI_SLOT(companion-&gt;devfn) != slot)
 			continue;
 		companion_hcd = pci_get_drvdata(companion);
-		if (!companion_hcd)
+		if (!companion_hcd || !companion_hcd-&gt;self.root_hub)
 			continue;
 		fn(pdev, hcd, companion, companion_hcd);
 	}</pre><hr><pre>commit 1d10255c1c496557a5674e651c4ebbe0f61279f2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 18 10:39:05 2014 -0400

    USB: disable reset-resume when USB_QUIRK_RESET is set
    
    The USB_QUIRK_RESET flag indicates that a USB device changes its
    identity in some way when it is reset.  It may lose its firmware, its
    descriptors may change, or it may switch back to a default mode of
    operation.
    
    If a device does this, the kernel needs to avoid resetting it.  Resets
    are likely to fail, or worse, succeed while changing the device's
    state in a way the system can't detect.
    
    This means we should disable the reset-resume mechanism whenever this
    quirk flag is present.  An attempted reset-resume will fail, the
    device will be logically disconnected, and later on the hub driver
    will rediscover and re-enumerate the device.  This will cause the
    appropriate udev events to be generated, so that userspace will have a
    chance to switch the device into its normal operating mode, if
    necessary.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Reviewed-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2d74dfb9c989..d670aaf13a3d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3105,9 +3105,19 @@ static int finish_port_resume(struct usb_device *udev)
 	 * operation is carried out here, after the port has been
 	 * resumed.
 	 */
-	if (udev-&gt;reset_resume)
+	if (udev-&gt;reset_resume) {
+		/*
+		 * If the device morphs or switches modes when it is reset,
+		 * we don't want to perform a reset-resume.  We'll fail the
+		 * resume, which will cause a logical disconnect, and then
+		 * the device will be rediscovered.
+		 */
  retry_reset_resume:
-		status = usb_reset_and_verify_device(udev);
+		if (udev-&gt;quirks &amp; USB_QUIRK_RESET)
+			status = -ENODEV;
+		else
+			status = usb_reset_and_verify_device(udev);
+	}
 
 	/* 10.5.4.5 says be sure devices in the tree are still there.
 	 * For now let's assume the device didn't go crazy on resume,</pre><hr><pre>commit 6aec044cc2f5670cf3b143c151c8be846499bd15
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 12 11:30:38 2014 -0400

    USB: unbind all interfaces before rebinding any
    
    When a driver doesn't have pre_reset, post_reset, or reset_resume
    methods, the USB core unbinds that driver when its device undergoes a
    reset or a reset-resume, and then rebinds it afterward.
    
    The existing straightforward implementation can lead to problems,
    because each interface gets unbound and rebound before the next
    interface is handled.  If a driver claims additional interfaces, the
    claim may fail because the old binding instance may still own the
    additional interface when the new instance tries to claim it.
    
    This patch fixes the problem by first unbinding all the interfaces
    that are marked (i.e., their needs_binding flag is set) and then
    rebinding all of them.
    
    The patch also makes the helper functions in driver.c a little more
    uniform and adjusts some out-of-date comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: "Poulain, Loic" &lt;loic.poulain@intel.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 08283d40616c..888881e5f292 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1011,8 +1011,7 @@ EXPORT_SYMBOL_GPL(usb_deregister);
  * it doesn't support pre_reset/post_reset/reset_resume or
  * because it doesn't support suspend/resume.
  *
- * The caller must hold @intf's device's lock, but not its pm_mutex
- * and not @intf-&gt;dev.sem.
+ * The caller must hold @intf's device's lock, but not @intf's lock.
  */
 void usb_forced_unbind_intf(struct usb_interface *intf)
 {
@@ -1025,16 +1024,37 @@ void usb_forced_unbind_intf(struct usb_interface *intf)
 	intf-&gt;needs_binding = 1;
 }
 
+/*
+ * Unbind drivers for @udev's marked interfaces.  These interfaces have
+ * the needs_binding flag set, for example by usb_resume_interface().
+ *
+ * The caller must hold @udev's device lock.
+ */
+static void unbind_marked_interfaces(struct usb_device *udev)
+{
+	struct usb_host_config	*config;
+	int			i;
+	struct usb_interface	*intf;
+
+	config = udev-&gt;actconfig;
+	if (config) {
+		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
+			intf = config-&gt;interface[i];
+			if (intf-&gt;dev.driver &amp;&amp; intf-&gt;needs_binding)
+				usb_forced_unbind_intf(intf);
+		}
+	}
+}
+
 /* Delayed forced unbinding of a USB interface driver and scan
  * for rebinding.
  *
- * The caller must hold @intf's device's lock, but not its pm_mutex
- * and not @intf-&gt;dev.sem.
+ * The caller must hold @intf's device's lock, but not @intf's lock.
  *
  * Note: Rebinds will be skipped if a system sleep transition is in
  * progress and the PM "complete" callback hasn't occurred yet.
  */
-void usb_rebind_intf(struct usb_interface *intf)
+static void usb_rebind_intf(struct usb_interface *intf)
 {
 	int rc;
 
@@ -1051,68 +1071,66 @@ void usb_rebind_intf(struct usb_interface *intf)
 	}
 }
 
-#ifdef CONFIG_PM
-
-/* Unbind drivers for @udev's interfaces that don't support suspend/resume
- * There is no check for reset_resume here because it can be determined
- * only during resume whether reset_resume is needed.
+/*
+ * Rebind drivers to @udev's marked interfaces.  These interfaces have
+ * the needs_binding flag set.
  *
  * The caller must hold @udev's device lock.
  */
-static void unbind_no_pm_drivers_interfaces(struct usb_device *udev)
+static void rebind_marked_interfaces(struct usb_device *udev)
 {
 	struct usb_host_config	*config;
 	int			i;
 	struct usb_interface	*intf;
-	struct usb_driver	*drv;
 
 	config = udev-&gt;actconfig;
 	if (config) {
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
 			intf = config-&gt;interface[i];
-
-			if (intf-&gt;dev.driver) {
-				drv = to_usb_driver(intf-&gt;dev.driver);
-				if (!drv-&gt;suspend || !drv-&gt;resume)
-					usb_forced_unbind_intf(intf);
-			}
+			if (intf-&gt;needs_binding)
+				usb_rebind_intf(intf);
 		}
 	}
 }
 
-/* Unbind drivers for @udev's interfaces that failed to support reset-resume.
- * These interfaces have the needs_binding flag set by usb_resume_interface().
+/*
+ * Unbind all of @udev's marked interfaces and then rebind all of them.
+ * This ordering is necessary because some drivers claim several interfaces
+ * when they are first probed.
  *
  * The caller must hold @udev's device lock.
  */
-static void unbind_no_reset_resume_drivers_interfaces(struct usb_device *udev)
+void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev)
 {
-	struct usb_host_config	*config;
-	int			i;
-	struct usb_interface	*intf;
-
-	config = udev-&gt;actconfig;
-	if (config) {
-		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
-			intf = config-&gt;interface[i];
-			if (intf-&gt;dev.driver &amp;&amp; intf-&gt;needs_binding)
-				usb_forced_unbind_intf(intf);
-		}
-	}
+	unbind_marked_interfaces(udev);
+	rebind_marked_interfaces(udev);
 }
 
-static void do_rebind_interfaces(struct usb_device *udev)
+#ifdef CONFIG_PM
+
+/* Unbind drivers for @udev's interfaces that don't support suspend/resume
+ * There is no check for reset_resume here because it can be determined
+ * only during resume whether reset_resume is needed.
+ *
+ * The caller must hold @udev's device lock.
+ */
+static void unbind_no_pm_drivers_interfaces(struct usb_device *udev)
 {
 	struct usb_host_config	*config;
 	int			i;
 	struct usb_interface	*intf;
+	struct usb_driver	*drv;
 
 	config = udev-&gt;actconfig;
 	if (config) {
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
 			intf = config-&gt;interface[i];
-			if (intf-&gt;needs_binding)
-				usb_rebind_intf(intf);
+
+			if (intf-&gt;dev.driver) {
+				drv = to_usb_driver(intf-&gt;dev.driver);
+				if (!drv-&gt;suspend || !drv-&gt;resume)
+					usb_forced_unbind_intf(intf);
+			}
 		}
 	}
 }
@@ -1441,7 +1459,7 @@ int usb_resume_complete(struct device *dev)
 	 * whose needs_binding flag is set
 	 */
 	if (udev-&gt;state != USB_STATE_NOTATTACHED)
-		do_rebind_interfaces(udev);
+		rebind_marked_interfaces(udev);
 	return 0;
 }
 
@@ -1463,7 +1481,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 		pm_runtime_disable(dev);
 		pm_runtime_set_active(dev);
 		pm_runtime_enable(dev);
-		unbind_no_reset_resume_drivers_interfaces(udev);
+		unbind_marked_interfaces(udev);
 	}
 
 	/* Avoid PM error messages for devices disconnected while suspended
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5da5394127e9..2d74dfb9c989 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5380,10 +5380,11 @@ int usb_reset_device(struct usb_device *udev)
 				else if (cintf-&gt;condition ==
 						USB_INTERFACE_BOUND)
 					rebind = 1;
+				if (rebind)
+					cintf-&gt;needs_binding = 1;
 			}
-			if (ret == 0 &amp;&amp; rebind)
-				usb_rebind_intf(cintf);
 		}
+		usb_unbind_and_rebind_marked_interfaces(udev);
 	}
 
 	usb_autosuspend_device(udev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 823857767a16..0923add72b59 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -55,7 +55,7 @@ extern int usb_match_one_id_intf(struct usb_device *dev,
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
-extern void usb_rebind_intf(struct usb_interface *intf);
+extern void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev);
 
 extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
 		struct dev_state *owner);</pre><hr><pre>commit 7aae51347b21eb738dc1981df1365b57a6c5ee4e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 15 15:37:04 2014 -0500

    [SCSI] sd: don't fail if the device doesn't recognize SYNCHRONIZE CACHE
    
    Evidently some wacky USB-ATA bridges don't recognize the SYNCHRONIZE
    CACHE command, as shown in this email thread:
    
            http://marc.info/?t=138978356200002&amp;r=1&amp;w=2
    
    The fact that we can't tell them to drain their caches shouldn't
    prevent the system from going into suspend.  Therefore sd_sync_cache()
    shouldn't return an error if the device replies with an Invalid
    Command ASC.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Sven Neumann &lt;s.neumann@raumfeld.com&gt;
    Tested-by: Daniel Mack &lt;zonque@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 470954aba728..36d1a23f14be 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1463,8 +1463,8 @@ static int sd_sync_cache(struct scsi_disk *sdkp)
 			sd_print_sense_hdr(sdkp, &amp;sshdr);
 		/* we need to evaluate the error return  */
 		if (scsi_sense_valid(&amp;sshdr) &amp;&amp;
-			/* 0x3a is medium not present */
-			sshdr.asc == 0x3a)
+			(sshdr.asc == 0x3a ||	/* medium not present */
+			 sshdr.asc == 0x20))	/* invalid command */
 				/* this is no error here */
 				return 0;
 </pre><hr><pre>commit f080a51bef2caa9b0f647dc430bc608d5723ac29
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 20 10:49:30 2014 -0500

    USB: complain if userspace resets an active endpoint
    
    It is an error for a driver to call usb_clear_halt() or
    usb_reset_endpoint() while there are URBs queued for the endpoint,
    because the end result is not well defined.  At the time the endpoint
    gets reset, it may or may not be actively running.
    
    As far as I know, no kernel drivers do this.  But some userspace
    drivers do, and it seems like a good idea to bring this error to their
    attention.
    
    This patch adds a warning to the kernel log whenever a program invokes
    the USBDEVFS_CLEAR_HALT or USBDEVFS_RESETEP ioctls at an inappropriate
    time, and includes the name of the program.  This will make it clear
    that any subsequent errors are not due to the misbehavior of a kernel
    driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Suggested-by: Bjørn Mork &lt;bjorn@mork.no&gt;
    CC: Stanislaw Gruszka &lt;sgruszka@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 90e18f6fa2bb..f3ba2e076ee3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1043,6 +1043,20 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	return ret;
 }
 
+static void check_reset_of_active_ep(struct usb_device *udev,
+		unsigned int epnum, char *ioctl_name)
+{
+	struct usb_host_endpoint **eps;
+	struct usb_host_endpoint *ep;
+
+	eps = (epnum &amp; USB_DIR_IN) ? udev-&gt;ep_in : udev-&gt;ep_out;
+	ep = eps[epnum &amp; 0x0f];
+	if (ep &amp;&amp; !list_empty(&amp;ep-&gt;urb_list))
+		dev_warn(&amp;udev-&gt;dev, "Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\n",
+				task_pid_nr(current), current-&gt;comm,
+				ioctl_name, epnum);
+}
+
 static int proc_resetep(struct dev_state *ps, void __user *arg)
 {
 	unsigned int ep;
@@ -1056,6 +1070,7 @@ static int proc_resetep(struct dev_state *ps, void __user *arg)
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
+	check_reset_of_active_ep(ps-&gt;dev, ep, "RESETEP");
 	usb_reset_endpoint(ps-&gt;dev, ep);
 	return 0;
 }
@@ -1074,6 +1089,7 @@ static int proc_clearhalt(struct dev_state *ps, void __user *arg)
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
+	check_reset_of_active_ep(ps-&gt;dev, ep, "CLEAR_HALT");
 	if (ep &amp; USB_DIR_IN)
 		pipe = usb_rcvbulkpipe(ps-&gt;dev, ep &amp; 0x7f);
 	else</pre><hr><pre>commit 3e8d6d85adedc59115a564c0a54b36e42087c4d9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 13 15:49:17 2014 -0500

    USB: EHCI: add delay during suspend to prevent erroneous wakeups
    
    High-speed USB connections revert back to full-speed signalling when
    the device goes into suspend.  This takes several milliseconds, and
    during that time it's not possible to tell reliably whether the device
    has been disconnected.
    
    On some platforms, the Wake-On-Disconnect circuitry gets confused
    during this intermediate state.  It generates a false wakeup signal,
    which can prevent the controller from going to sleep.
    
    To avoid this problem, this patch adds a 5-ms delay to the
    ehci_bus_suspend() routine if any ports have to switch over to
    full-speed signalling.  (Actually, the delay was already present for
    devices using a particular kind of PHY power management; the patch
    merely causes the delay to be used more widely.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Peter Chen &lt;Peter.Chen@freescale.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 47b858fc50b2..7ae0c4d51741 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -238,6 +238,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	int			port;
 	int			mask;
 	int			changed;
+	bool			fs_idle_delay;
 
 	ehci_dbg(ehci, "suspend root hub\n");
 
@@ -272,6 +273,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
 	changed = 0;
+	fs_idle_delay = false;
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
@@ -300,16 +302,32 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 
 		if (t1 != t2) {
+			/*
+			 * On some controllers, Wake-On-Disconnect will
+			 * generate false wakeup signals until the bus
+			 * switches over to full-speed idle.  For their
+			 * sake, add a delay if we need one.
+			 */
+			if ((t2 &amp; PORT_WKDISC_E) &amp;&amp;
+					ehci_port_speed(ehci, t2) ==
+						USB_PORT_STAT_HIGH_SPEED)
+				fs_idle_delay = true;
 			ehci_writel(ehci, t2, reg);
 			changed = 1;
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	if ((changed &amp;&amp; ehci-&gt;has_tdi_phy_lpm) || fs_idle_delay) {
+		/*
+		 * Wait for HCD to enter low-power mode or for the bus
+		 * to switch to full-speed idle.
+		 */
+		usleep_range(5000, 5500);
+	}
 
 	if (changed &amp;&amp; ehci-&gt;has_tdi_phy_lpm) {
-		spin_unlock_irq(&amp;ehci-&gt;lock);
-		msleep(5);	/* 5 ms for HCD to enter low-power mode */
 		spin_lock_irq(&amp;ehci-&gt;lock);
-
 		port = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (port--) {
 			u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[port];
@@ -322,8 +340,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 					port, (t3 &amp; HOSTPC_PHCD) ?
 					"succeeded" : "failed");
 		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 	}
-	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* Apparently some devices need a &gt;= 1-uframe delay here */
 	if (ehci-&gt;bus_suspended)</pre><hr><pre>commit adff52952ef52c4dbfb930727f6f8cfe14d9967c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 11 11:26:00 2014 -0500

    USB: ohci-platform: check for platform data misconfiguration
    
    The ohci-platform driver checks for misconfigurations in cases where
    the Device Tree data specifies big-endian registers or descriptors but
    the corresponding driver config settings have not been enabled.  As
    Jonas Gorski suggested, we may as well apply the same check to general
    platform data too.
    
    This requires moving the code that sets the big-endian quirk flags
    from the ohci_platform_reset() routine into ohci_platform_probe(), and
    moving the checks out of the DT-specific "if" statement clause.
    
    The patch also changes the text of the error messages in an attempt to
    make the nature of the error more clear.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Jonas Gorski &lt;jogo@openwrt.org&gt;
    Acked-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-platform.c b/drivers/usb/host/ohci-platform.c
index b6ca0b25259a..b6002c951c5c 100644
--- a/drivers/usb/host/ohci-platform.c
+++ b/drivers/usb/host/ohci-platform.c
@@ -47,10 +47,6 @@ static int ohci_platform_reset(struct usb_hcd *hcd)
 	struct usb_ohci_pdata *pdata = dev_get_platdata(&amp;pdev-&gt;dev);
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
 
-	if (pdata-&gt;big_endian_desc)
-		ohci-&gt;flags |= OHCI_QUIRK_BE_DESC;
-	if (pdata-&gt;big_endian_mmio)
-		ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO;
 	if (pdata-&gt;no_big_frame_no)
 		ohci-&gt;flags |= OHCI_QUIRK_FRAME_NO;
 	if (pdata-&gt;num_ports)
@@ -177,22 +173,6 @@ static int ohci_platform_probe(struct platform_device *dev)
 		if (of_property_read_bool(dev-&gt;dev.of_node, "big-endian"))
 			ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
 
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-		if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_MMIO) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-regs not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
-		if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_DESC) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-desc not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
 		priv-&gt;phy = devm_phy_get(&amp;dev-&gt;dev, "usb");
 		if (IS_ERR(priv-&gt;phy)) {
 			err = PTR_ERR(priv-&gt;phy);
@@ -213,6 +193,28 @@ static int ohci_platform_probe(struct platform_device *dev)
 		}
 	}
 
+	if (pdata-&gt;big_endian_desc)
+		ohci-&gt;flags |= OHCI_QUIRK_BE_DESC;
+	if (pdata-&gt;big_endian_mmio)
+		ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO;
+
+#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
+	if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_MMIO) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_MMIO not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
+	if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_DESC) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_DESC not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+
 	if (pdata-&gt;power_on) {
 		err = pdata-&gt;power_on(dev);
 		if (err &lt; 0)</pre>
    <div class="pagination">
        <a href='2_29.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><span>[30]</span><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_31.html'>Next&gt;&gt;</a>
    <div>
</body>
