<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><span>[2]</span><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit eccd25136386a04ebf46a64f3a34e8e0fab6d9e1
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Mon Dec 13 11:53:07 2021 +0200

    ath11k: Fix a NULL pointer dereference in ath11k_mac_op_hw_scan()
    
    In ath11k_mac_op_hw_scan(), the return value of kzalloc() is directly
    used in memcpy(), which may lead to a NULL pointer dereference on
    failure of kzalloc().
    
    Fix this bug by adding a check of arg.extraie.ptr.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_ATH11K=m show no new warnings, and our static
    analyzer no longer warns about this code.
    
    Fixes: d5c65159f289 ("ath11k: driver for Qualcomm IEEE 802.11ax devices")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Kalle Valo &lt;quic_kvalo@quicinc.com&gt;
    Link: https://lore.kernel.org/r/20211202155348.71315-1-zhou1615@umn.edu

diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index e8b76a311a54..6361378cb407 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -3520,9 +3520,12 @@ static int ath11k_mac_op_hw_scan(struct ieee80211_hw *hw,
 	arg.scan_id = ATH11K_SCAN_ID;
 
 	if (req-&gt;ie_len) {
+		arg.extraie.ptr = kmemdup(req-&gt;ie, req-&gt;ie_len, GFP_KERNEL);
+		if (!arg.extraie.ptr) {
+			ret = -ENOMEM;
+			goto exit;
+		}
 		arg.extraie.len = req-&gt;ie_len;
-		arg.extraie.ptr = kzalloc(req-&gt;ie_len, GFP_KERNEL);
-		memcpy(arg.extraie.ptr, req-&gt;ie, req-&gt;ie_len);
 	}
 
 	if (req-&gt;n_ssids) {</pre><hr><pre>commit 3af86b046933ba513d08399dba0d4d8b50d607d0
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Fri Dec 3 16:40:30 2021 +0100

    media: saa7146: hexium_gemini: Fix a NULL pointer dereference in hexium_attach()
    
    In hexium_attach(dev, info), saa7146_vv_init() is called to allocate
    a new memory for dev-&gt;vv_data. saa7146_vv_release() will be called on
    failure of saa7146_register_device(). There is a dereference of
    dev-&gt;vv_data in saa7146_vv_release(), which could lead to a NULL
    pointer dereference on failure of saa7146_vv_init().
    
    Fix this bug by adding a check of saa7146_vv_init().
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_VIDEO_HEXIUM_GEMINI=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Link: https://lore.kernel.org/linux-media/20211203154030.111210-1-zhou1615@umn.edu
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/common/saa7146/saa7146_fops.c b/drivers/media/common/saa7146/saa7146_fops.c
index baf5772c52a9..be3215977714 100644
--- a/drivers/media/common/saa7146/saa7146_fops.c
+++ b/drivers/media/common/saa7146/saa7146_fops.c
@@ -521,7 +521,7 @@ int saa7146_vv_init(struct saa7146_dev* dev, struct saa7146_ext_vv *ext_vv)
 		ERR("out of memory. aborting.\n");
 		kfree(vv);
 		v4l2_ctrl_handler_free(hdl);
-		return -1;
+		return -ENOMEM;
 	}
 
 	saa7146_video_uops.init(dev,vv);
diff --git a/drivers/media/pci/saa7146/hexium_gemini.c b/drivers/media/pci/saa7146/hexium_gemini.c
index 2214c74bbbf1..3947701cd6c7 100644
--- a/drivers/media/pci/saa7146/hexium_gemini.c
+++ b/drivers/media/pci/saa7146/hexium_gemini.c
@@ -284,7 +284,12 @@ static int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_d
 	hexium_set_input(hexium, 0);
 	hexium-&gt;cur_input = 0;
 
-	saa7146_vv_init(dev, &amp;vv_data);
+	ret = saa7146_vv_init(dev, &amp;vv_data);
+	if (ret) {
+		i2c_del_adapter(&amp;hexium-&gt;i2c_adapter);
+		kfree(hexium);
+		return ret;
+	}
 
 	vv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;
 	vv_data.vid_ops.vidioc_g_input = vidioc_g_input;</pre><hr><pre>commit 0407c49ebe330333478440157c640fffd986f41b
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Tue Nov 30 17:34:44 2021 +0100

    media: saa7146: mxb: Fix a NULL pointer dereference in mxb_attach()
    
    In mxb_attach(dev, info), saa7146_vv_init() is called to allocate a
    new memory for dev-&gt;vv_data. saa7146_vv_release() will be called on
    failure of mxb_probe(dev). There is a dereference of dev-&gt;vv_data
    in saa7146_vv_release(), which could lead to a NULL pointer dereference
    on failure of saa7146_vv_init().
    
    Fix this bug by adding a check of saa7146_vv_init().
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_VIDEO_MXB=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: 03b1930efd3c ("V4L/DVB: saa7146: fix regression of the av7110/budget-av driver")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/pci/saa7146/mxb.c b/drivers/media/pci/saa7146/mxb.c
index 73fc901ecf3d..bf0b9b0914cd 100644
--- a/drivers/media/pci/saa7146/mxb.c
+++ b/drivers/media/pci/saa7146/mxb.c
@@ -683,10 +683,16 @@ static struct saa7146_ext_vv vv_data;
 static int mxb_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)
 {
 	struct mxb *mxb;
+	int ret;
 
 	DEB_EE("dev:%p\n", dev);
 
-	saa7146_vv_init(dev, &amp;vv_data);
+	ret = saa7146_vv_init(dev, &amp;vv_data);
+	if (ret) {
+		ERR("Error in saa7146_vv_init()");
+		return ret;
+	}
+
 	if (mxb_probe(dev)) {
 		saa7146_vv_release(dev);
 		return -1;</pre><hr><pre>commit 348df8035301dd212e3cc2860efe4c86cb0d3303
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Tue Nov 30 17:25:49 2021 +0100

    media: saa7146: hexium_orion: Fix a NULL pointer dereference in hexium_attach()
    
    In hexium_attach(dev, info), saa7146_vv_init() is called to allocate
    a new memory for dev-&gt;vv_data. In hexium_detach(), saa7146_vv_release()
    will be called and there is a dereference of dev-&gt;vv_data in
    saa7146_vv_release(), which could lead to a NULL pointer dereference
    on failure of saa7146_vv_init() according to the following logic.
    
    Both hexium_attach() and hexium_detach() are callback functions of
    the variable 'extension', so there exists a possible call chain directly
    from hexium_attach() to hexium_detach():
    
    hexium_attach(dev, info) -- fail to alloc memory to dev-&gt;vv_data
            |                               in saa7146_vv_init().
            |
            |
    hexium_detach() -- a dereference of dev-&gt;vv_data in saa7146_vv_release()
    
    Fix this bug by adding a check of saa7146_vv_init().
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_VIDEO_HEXIUM_ORION=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/pci/saa7146/hexium_orion.c b/drivers/media/pci/saa7146/hexium_orion.c
index 39d14c179d22..2eb4bee16b71 100644
--- a/drivers/media/pci/saa7146/hexium_orion.c
+++ b/drivers/media/pci/saa7146/hexium_orion.c
@@ -355,10 +355,16 @@ static struct saa7146_ext_vv vv_data;
 static int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)
 {
 	struct hexium *hexium = (struct hexium *) dev-&gt;ext_priv;
+	int ret;
 
 	DEB_EE("\n");
 
-	saa7146_vv_init(dev, &amp;vv_data);
+	ret = saa7146_vv_init(dev, &amp;vv_data);
+	if (ret) {
+		pr_err("Error in saa7146_vv_init()\n");
+		return ret;
+	}
+
 	vv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;
 	vv_data.vid_ops.vidioc_g_input = vidioc_g_input;
 	vv_data.vid_ops.vidioc_s_input = vidioc_s_input;</pre><hr><pre>commit 8dbdcc7269a83305ee9d677b75064d3530a48ee2
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Tue Nov 30 16:38:05 2021 +0100

    media: dib8000: Fix a memleak in dib8000_init()
    
    In dib8000_init(), the variable fe is not freed or passed out on the
    failure of dib8000_identify(&amp;state-&gt;i2c), which could lead to a memleak.
    
    Fix this bug by adding a kfree of fe in the error path.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_DVB_DIB8000=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: 77e2c0f5d471 ("V4L/DVB (12900): DiB8000: added support for DiBcom ISDB-T/ISDB-Tsb demodulator DiB8000")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/dvb-frontends/dib8000.c b/drivers/media/dvb-frontends/dib8000.c
index bb02354a48b8..d67f2dd997d0 100644
--- a/drivers/media/dvb-frontends/dib8000.c
+++ b/drivers/media/dvb-frontends/dib8000.c
@@ -4473,8 +4473,10 @@ static struct dvb_frontend *dib8000_init(struct i2c_adapter *i2c_adap, u8 i2c_ad
 
 	state-&gt;timf_default = cfg-&gt;pll-&gt;timf;
 
-	if (dib8000_identify(&amp;state-&gt;i2c) == 0)
+	if (dib8000_identify(&amp;state-&gt;i2c) == 0) {
+		kfree(fe);
 		goto error;
+	}
 
 	dibx000_init_i2c_master(&amp;state-&gt;i2c_master, DIB8000, state-&gt;i2c.adap, state-&gt;i2c.addr);
 </pre><hr><pre>commit 37307f7020ab38dde0892a578249bf63d00bca64
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Wed Dec 1 01:27:00 2021 +0800

    usb: cdnsp: Fix a NULL pointer dereference in cdnsp_endpoint_init()
    
    In cdnsp_endpoint_init(), cdnsp_ring_alloc() is assigned to pep-&gt;ring
    and there is a dereference of it in cdnsp_endpoint_init(), which could
    lead to a NULL pointer dereference on failure of cdnsp_ring_alloc().
    
    Fix this bug by adding a check of pep-&gt;ring.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_USB_CDNSP_GADGET=y show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: 3d82904559f4 ("usb: cdnsp: cdns3 Add main part of Cadence USBSSP DRD Driver")
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Acked-by: Pawel Laszczak &lt;pawell@cadence.com&gt;
    Acked-by: Peter Chen &lt;peter.chen@kernel.org&gt;
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Link: https://lore.kernel.org/r/20211130172700.206650-1-zhou1615@umn.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/cdns3/cdnsp-mem.c b/drivers/usb/cdns3/cdnsp-mem.c
index ad9aee3f1e39..97866bfb2da9 100644
--- a/drivers/usb/cdns3/cdnsp-mem.c
+++ b/drivers/usb/cdns3/cdnsp-mem.c
@@ -987,6 +987,9 @@ int cdnsp_endpoint_init(struct cdnsp_device *pdev,
 
 	/* Set up the endpoint ring. */
 	pep-&gt;ring = cdnsp_ring_alloc(pdev, 2, ring_type, max_packet, mem_flags);
+	if (!pep-&gt;ring)
+		return -ENOMEM;
+
 	pep-&gt;skip = false;
 
 	/* Fill the endpoint context */</pre><hr><pre>commit ab50cb9df8896b39aae65c537a30de2c79c19735
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Wed Dec 1 23:13:10 2021 +0800

    drm/radeon/radeon_kms: Fix a NULL pointer dereference in radeon_driver_open_kms()
    
    In radeon_driver_open_kms(), radeon_vm_bo_add() is assigned to
    vm-&gt;ib_bo_va and passes and used in radeon_vm_bo_set_addr(). In
    radeon_vm_bo_set_addr(), there is a dereference of vm-&gt;ib_bo_va,
    which could lead to a NULL pointer dereference on failure of
    radeon_vm_bo_add().
    
    Fix this bug by adding a check of vm-&gt;ib_bo_va.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_DRM_RADEON=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: cc9e67e3d700 ("drm/radeon: fix VM IB handling")
    Reviewed-by: Christian König &lt;christian.koenig@amd.com&gt;
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/radeon/radeon_kms.c b/drivers/gpu/drm/radeon/radeon_kms.c
index 7afe28408085..e2488559cc9f 100644
--- a/drivers/gpu/drm/radeon/radeon_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_kms.c
@@ -648,6 +648,8 @@ void radeon_driver_lastclose_kms(struct drm_device *dev)
 int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)
 {
 	struct radeon_device *rdev = dev-&gt;dev_private;
+	struct radeon_fpriv *fpriv;
+	struct radeon_vm *vm;
 	int r;
 
 	file_priv-&gt;driver_priv = NULL;
@@ -660,8 +662,6 @@ int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)
 
 	/* new gpu have virtual address space support */
 	if (rdev-&gt;family &gt;= CHIP_CAYMAN) {
-		struct radeon_fpriv *fpriv;
-		struct radeon_vm *vm;
 
 		fpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);
 		if (unlikely(!fpriv)) {
@@ -672,35 +672,39 @@ int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)
 		if (rdev-&gt;accel_working) {
 			vm = &amp;fpriv-&gt;vm;
 			r = radeon_vm_init(rdev, vm);
-			if (r) {
-				kfree(fpriv);
-				goto out_suspend;
-			}
+			if (r)
+				goto out_fpriv;
 
 			r = radeon_bo_reserve(rdev-&gt;ring_tmp_bo.bo, false);
-			if (r) {
-				radeon_vm_fini(rdev, vm);
-				kfree(fpriv);
-				goto out_suspend;
-			}
+			if (r)
+				goto out_vm_fini;
 
 			/* map the ib pool buffer read only into
 			 * virtual address space */
 			vm-&gt;ib_bo_va = radeon_vm_bo_add(rdev, vm,
 							rdev-&gt;ring_tmp_bo.bo);
+			if (!vm-&gt;ib_bo_va) {
+				r = -ENOMEM;
+				goto out_vm_fini;
+			}
+
 			r = radeon_vm_bo_set_addr(rdev, vm-&gt;ib_bo_va,
 						  RADEON_VA_IB_OFFSET,
 						  RADEON_VM_PAGE_READABLE |
 						  RADEON_VM_PAGE_SNOOPED);
-			if (r) {
-				radeon_vm_fini(rdev, vm);
-				kfree(fpriv);
-				goto out_suspend;
-			}
+			if (r)
+				goto out_vm_fini;
 		}
 		file_priv-&gt;driver_priv = fpriv;
 	}
 
+	if (!r)
+		goto out_suspend;
+
+out_vm_fini:
+	radeon_vm_fini(rdev, vm);
+out_fpriv:
+	kfree(fpriv);
 out_suspend:
 	pm_runtime_mark_last_busy(dev-&gt;dev);
 	pm_runtime_put_autosuspend(dev-&gt;dev);</pre><hr><pre>commit b220110e4cd442156f36e1d9b4914bb9e87b0d00
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Fri Dec 3 00:17:36 2021 +0800

    drm/amdgpu: Fix a NULL pointer dereference in amdgpu_connector_lcd_native_mode()
    
    In amdgpu_connector_lcd_native_mode(), the return value of
    drm_mode_duplicate() is assigned to mode, and there is a dereference
    of it in amdgpu_connector_lcd_native_mode(), which will lead to a NULL
    pointer dereference on failure of drm_mode_duplicate().
    
    Fix this bug add a check of mode.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_DRM_AMDGPU=m show no new warnings, and
    our static analyzer no longer warns about this code.
    
    Fixes: d38ceaf99ed0 ("drm/amdgpu: add core driver (v4)")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index 0de66f59adb8..df1f9b88a53f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
@@ -387,6 +387,9 @@ amdgpu_connector_lcd_native_mode(struct drm_encoder *encoder)
 	    native_mode-&gt;vdisplay != 0 &amp;&amp;
 	    native_mode-&gt;clock != 0) {
 		mode = drm_mode_duplicate(dev, native_mode);
+		if (!mode)
+			return NULL;
+
 		mode-&gt;type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;
 		drm_mode_set_name(mode);
 
@@ -401,6 +404,9 @@ amdgpu_connector_lcd_native_mode(struct drm_encoder *encoder)
 		 * simpler.
 		 */
 		mode = drm_cvt_mode(dev, native_mode-&gt;hdisplay, native_mode-&gt;vdisplay, 60, true, false, false);
+		if (!mode)
+			return NULL;
+
 		mode-&gt;type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;
 		DRM_DEBUG_KMS("Adding cvt approximation of native panel mode %s\n", mode-&gt;name);
 	}</pre><hr><pre>commit e07a097b4986afb8f925d0bb32612e1d3e88ce15
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Wed Dec 1 00:50:39 2021 +0800

    octeontx2-af: Fix a memleak bug in rvu_mbox_init()
    
    In rvu_mbox_init(), mbox_regions is not freed or passed out
    under the switch-default region, which could lead to a memory leak.
    
    Fix this bug by changing 'return err' to 'goto free_regions'.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_OCTEONTX2_AF=y show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: 98c561116360 (“octeontx2-af: cn10k: Add mbox support for CN10K platform”)
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Link: https://lore.kernel.org/r/20211130165039.192426-1-zhou1615@umn.edu
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index cb56e171ddd4..3ca6b942ebe2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -2341,7 +2341,7 @@ static int rvu_mbox_init(struct rvu *rvu, struct mbox_wq_info *mw,
 			goto free_regions;
 		break;
 	default:
-		return err;
+		goto free_regions;
 	}
 
 	mw-&gt;mbox_wq = alloc_workqueue(name,</pre><hr><pre>commit addad7643142f500080417dd7272f49b7a185570
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Wed Dec 1 00:44:38 2021 +0800

    net/mlx4_en: Fix an use-after-free bug in mlx4_en_try_alloc_resources()
    
    In mlx4_en_try_alloc_resources(), mlx4_en_copy_priv() is called and
    tmp-&gt;tx_cq will be freed on the error path of mlx4_en_copy_priv().
    After that mlx4_en_alloc_resources() is called and there is a dereference
    of &amp;tmp-&gt;tx_cq[t][i] in mlx4_en_alloc_resources(), which could lead to
    a use after free problem on failure of mlx4_en_copy_priv().
    
    Fix this bug by adding a check of mlx4_en_copy_priv()
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_MLX4_EN=m show no new warnings,
    and our static analyzer no longer warns about this code.
    
    Fixes: ec25bc04ed8e ("net/mlx4_en: Add resilience in low memory systems")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Link: https://lore.kernel.org/r/20211130164438.190591-1-zhou1615@umn.edu
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 3f6d5c384637..f1c10f2bda78 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2286,9 +2286,14 @@ int mlx4_en_try_alloc_resources(struct mlx4_en_priv *priv,
 				bool carry_xdp_prog)
 {
 	struct bpf_prog *xdp_prog;
-	int i, t;
+	int i, t, ret;
 
-	mlx4_en_copy_priv(tmp, priv, prof);
+	ret = mlx4_en_copy_priv(tmp, priv, prof);
+	if (ret) {
+		en_warn(priv, "%s: mlx4_en_copy_priv() failed, return\n",
+			__func__);
+		return ret;
+	}
 
 	if (mlx4_en_alloc_resources(tmp)) {
 		en_warn(priv,</pre>
    <div class="pagination">
        <a href='7.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><span>[2]</span><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_3.html'>Next&gt;&gt;</a>
    <div>
</body>
