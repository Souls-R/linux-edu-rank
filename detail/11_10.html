<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Peking University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Peking University</h1>
    <div class="pagination">
        <a href='11_9.html'>&lt;&lt;Prev</a><a href='11.html'>1</a><a href='11_2.html'>2</a><a href='11_3.html'>3</a><a href='11_4.html'>4</a><a href='11_5.html'>5</a><a href='11_6.html'>6</a><a href='11_7.html'>7</a><a href='11_8.html'>8</a><a href='11_9.html'>9</a><span>[10]</span>
    </div>
    <hr>
    <pre>commit d232b128e28f54cd8811dd4f6d8b72ffb12cc0a1
Author: GuanXuetao &lt;gxt@mprc.pku.edu.cn&gt;
Date:   Sat Jan 15 18:06:44 2011 +0800

    asm-generic headers: add sizes.h
    
    This patch adds sizes.h into asm-generic headers.
    Only 32-bit version supported.
    
    Signed-off-by: Guan Xuetao &lt;gxt@mprc.pku.edu.cn&gt;
    Acked-by: Arnd Bergmann &lt;arnd@arndb.de&gt;

diff --git a/include/asm-generic/sizes.h b/include/asm-generic/sizes.h
new file mode 100644
index 000000000000..ea5d4ef81061
--- /dev/null
+++ b/include/asm-generic/sizes.h
@@ -0,0 +1,47 @@
+/*
+ * linux/include/asm-generic/sizes.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_GENERIC_SIZES_H__
+#define __ASM_GENERIC_SIZES_H__
+
+#define SZ_1				0x00000001
+#define SZ_2				0x00000002
+#define SZ_4				0x00000004
+#define SZ_8				0x00000008
+#define SZ_16				0x00000010
+#define SZ_32				0x00000020
+#define SZ_64				0x00000040
+#define SZ_128				0x00000080
+#define SZ_256				0x00000100
+#define SZ_512				0x00000200
+
+#define SZ_1K				0x00000400
+#define SZ_2K				0x00000800
+#define SZ_4K				0x00001000
+#define SZ_8K				0x00002000
+#define SZ_16K				0x00004000
+#define SZ_32K				0x00008000
+#define SZ_64K				0x00010000
+#define SZ_128K				0x00020000
+#define SZ_256K				0x00040000
+#define SZ_512K				0x00080000
+
+#define SZ_1M				0x00100000
+#define SZ_2M				0x00200000
+#define SZ_4M				0x00400000
+#define SZ_8M				0x00800000
+#define SZ_16M				0x01000000
+#define SZ_32M				0x02000000
+#define SZ_64M				0x04000000
+#define SZ_128M				0x08000000
+#define SZ_256M				0x10000000
+#define SZ_512M				0x20000000
+
+#define SZ_1G				0x40000000
+#define SZ_2G				0x80000000
+
+#endif /* __ASM_GENERIC_SIZES_H__ */</pre><hr><pre>commit 7dc59bdde7063323b6a70c2f0fadb399ede8038d
Author: GuanXuetao &lt;gxt@mprc.pku.edu.cn&gt;
Date:   Tue Feb 22 19:06:43 2011 +0800

    asm-generic: fix inX/outX functions for architectures that have PCI
    
    The definitions for the PC-style PIO functions in asm-generic/io.h were
    meant as dummies so you could compile code on architectures without
    ISA and PCI buses. However, unicore32 actually wants to use them
    with a real PCI bus, so they need to be defined to actually address
    the register window holding the I/O ports.
    
    Signed-off-by: Arnd Bergmann &lt;arnd@arndb.de&gt;

diff --git a/include/asm-generic/io.h b/include/asm-generic/io.h
index 4644c9a7f724..e0ffa3ddb02a 100644
--- a/include/asm-generic/io.h
+++ b/include/asm-generic/io.h
@@ -94,6 +94,10 @@ static inline void __raw_writeq(u64 b, volatile void __iomem *addr)
 #define writeq(b,addr) __raw_writeq(__cpu_to_le64(b),addr)
 #endif
 
+#ifndef PCI_IOBASE
+#define PCI_IOBASE ((void __iomem *) 0)
+#endif
+
 /*****************************************************************************/
 /*
  * traditional input/output functions
@@ -101,32 +105,32 @@ static inline void __raw_writeq(u64 b, volatile void __iomem *addr)
 
 static inline u8 inb(unsigned long addr)
 {
-	return readb((volatile void __iomem *) addr);
+	return readb(addr + PCI_IOBASE);
 }
 
 static inline u16 inw(unsigned long addr)
 {
-	return readw((volatile void __iomem *) addr);
+	return readw(addr + PCI_IOBASE);
 }
 
 static inline u32 inl(unsigned long addr)
 {
-	return readl((volatile void __iomem *) addr);
+	return readl(addr + PCI_IOBASE);
 }
 
 static inline void outb(u8 b, unsigned long addr)
 {
-	writeb(b, (volatile void __iomem *) addr);
+	writeb(b, addr + PCI_IOBASE);
 }
 
 static inline void outw(u16 b, unsigned long addr)
 {
-	writew(b, (volatile void __iomem *) addr);
+	writew(b, addr + PCI_IOBASE);
 }
 
 static inline void outl(u32 b, unsigned long addr)
 {
-	writel(b, (volatile void __iomem *) addr);
+	writel(b, addr + PCI_IOBASE);
 }
 
 #define inb_p(addr)	inb(addr)
@@ -213,32 +217,32 @@ static inline void outsl(unsigned long addr, const void *buffer, int count)
 
 static inline void readsl(const void __iomem *addr, void *buf, int len)
 {
-	insl((unsigned long)addr, buf, len);
+	insl(addr - PCI_IOBASE, buf, len);
 }
 
 static inline void readsw(const void __iomem *addr, void *buf, int len)
 {
-	insw((unsigned long)addr, buf, len);
+	insw(addr - PCI_IOBASE, buf, len);
 }
 
 static inline void readsb(const void __iomem *addr, void *buf, int len)
 {
-	insb((unsigned long)addr, buf, len);
+	insb(addr - PCI_IOBASE, buf, len);
 }
 
 static inline void writesl(const void __iomem *addr, const void *buf, int len)
 {
-	outsl((unsigned long)addr, buf, len);
+	outsl(addr - PCI_IOBASE, buf, len);
 }
 
 static inline void writesw(const void __iomem *addr, const void *buf, int len)
 {
-	outsw((unsigned long)addr, buf, len);
+	outsw(addr - PCI_IOBASE, buf, len);
 }
 
 static inline void writesb(const void __iomem *addr, const void *buf, int len)
 {
-	outsb((unsigned long)addr, buf, len);
+	outsb(addr - PCI_IOBASE, buf, len);
 }
 
 #ifndef CONFIG_GENERIC_IOMAP
@@ -269,8 +273,9 @@ static inline void writesb(const void __iomem *addr, const void *buf, int len)
 	outsl((unsigned long) (p), (src), (count))
 #endif /* CONFIG_GENERIC_IOMAP */
 
-
-#define IO_SPACE_LIMIT 0xffffffff
+#ifndef IO_SPACE_LIMIT
+#define IO_SPACE_LIMIT 0xffff
+#endif
 
 #ifdef __KERNEL__
 </pre><hr><pre>commit 188c517a050ec5b123e72cab76ea213721e5bd9d
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Tue Sep 25 15:17:07 2012 +0000

    ipv6: return errno pointers consistently for fib6_add_1()
    
    fib6_add_1() should consistently return errno pointers,
    rather than a mixture of NULL and errno pointers.
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 286acfc21250..24995a93ef8c 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -514,7 +514,7 @@ static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,
 	ln = node_alloc();
 
 	if (!ln)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 	ln-&gt;fn_bit = plen;
 
 	ln-&gt;parent = pn;
@@ -561,7 +561,7 @@ static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,
 				node_free(in);
 			if (ln)
 				node_free(ln);
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 		}
 
 		/*
@@ -611,7 +611,7 @@ static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,
 		ln = node_alloc();
 
 		if (!ln)
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 
 		ln-&gt;fn_bit = plen;
 
@@ -777,11 +777,8 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
-		fn = NULL;
-	}
-
-	if (!fn)
 		goto out;
+	}
 
 	pn = fn;
 
@@ -820,15 +817,12 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 					allow_create, replace_required);
 
 			if (IS_ERR(sn)) {
-				err = PTR_ERR(sn);
-				sn = NULL;
-			}
-			if (!sn) {
 				/* If it is failed, discard just allocated
 				   root, and then (in st_failure) stale node
 				   in main tree.
 				 */
 				node_free(sfn);
+				err = PTR_ERR(sn);
 				goto st_failure;
 			}
 
@@ -843,10 +837,8 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 
 			if (IS_ERR(sn)) {
 				err = PTR_ERR(sn);
-				sn = NULL;
-			}
-			if (!sn)
 				goto st_failure;
+			}
 		}
 
 		if (!fn-&gt;leaf) {</pre><hr><pre>commit 61648d91fc278fd1d500da8061d17e6920cd3500
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Sun Jul 29 02:00:03 2012 +0000

    ipv4: clean up put_child
    
    The first parameter struct trie *t is not used anymore.
    Remove it.
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 2a6fdc2708c6..f0cdb30921c0 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -159,7 +159,6 @@ struct trie {
 #endif
 };
 
-static void put_child(struct trie *t, struct tnode *tn, int i, struct rt_trie_node *n);
 static void tnode_put_child_reorg(struct tnode *tn, int i, struct rt_trie_node *n,
 				  int wasfull);
 static struct rt_trie_node *resize(struct trie *t, struct tnode *tn);
@@ -490,7 +489,7 @@ static inline int tnode_full(const struct tnode *tn, const struct rt_trie_node *
 	return ((struct tnode *) n)-&gt;pos == tn-&gt;pos + tn-&gt;bits;
 }
 
-static inline void put_child(struct trie *t, struct tnode *tn, int i,
+static inline void put_child(struct tnode *tn, int i,
 			     struct rt_trie_node *n)
 {
 	tnode_put_child_reorg(tn, i, n, -1);
@@ -754,8 +753,8 @@ static struct tnode *inflate(struct trie *t, struct tnode *tn)
 				goto nomem;
 			}
 
-			put_child(t, tn, 2*i, (struct rt_trie_node *) left);
-			put_child(t, tn, 2*i+1, (struct rt_trie_node *) right);
+			put_child(tn, 2*i, (struct rt_trie_node *) left);
+			put_child(tn, 2*i+1, (struct rt_trie_node *) right);
 		}
 	}
 
@@ -776,9 +775,9 @@ static struct tnode *inflate(struct trie *t, struct tnode *tn)
 			if (tkey_extract_bits(node-&gt;key,
 					      oldtnode-&gt;pos + oldtnode-&gt;bits,
 					      1) == 0)
-				put_child(t, tn, 2*i, node);
+				put_child(tn, 2*i, node);
 			else
-				put_child(t, tn, 2*i+1, node);
+				put_child(tn, 2*i+1, node);
 			continue;
 		}
 
@@ -786,8 +785,8 @@ static struct tnode *inflate(struct trie *t, struct tnode *tn)
 		inode = (struct tnode *) node;
 
 		if (inode-&gt;bits == 1) {
-			put_child(t, tn, 2*i, rtnl_dereference(inode-&gt;child[0]));
-			put_child(t, tn, 2*i+1, rtnl_dereference(inode-&gt;child[1]));
+			put_child(tn, 2*i, rtnl_dereference(inode-&gt;child[0]));
+			put_child(tn, 2*i+1, rtnl_dereference(inode-&gt;child[1]));
 
 			tnode_free_safe(inode);
 			continue;
@@ -817,22 +816,22 @@ static struct tnode *inflate(struct trie *t, struct tnode *tn)
 		 */
 
 		left = (struct tnode *) tnode_get_child(tn, 2*i);
-		put_child(t, tn, 2*i, NULL);
+		put_child(tn, 2*i, NULL);
 
 		BUG_ON(!left);
 
 		right = (struct tnode *) tnode_get_child(tn, 2*i+1);
-		put_child(t, tn, 2*i+1, NULL);
+		put_child(tn, 2*i+1, NULL);
 
 		BUG_ON(!right);
 
 		size = tnode_child_length(left);
 		for (j = 0; j &lt; size; j++) {
-			put_child(t, left, j, rtnl_dereference(inode-&gt;child[j]));
-			put_child(t, right, j, rtnl_dereference(inode-&gt;child[j + size]));
+			put_child(left, j, rtnl_dereference(inode-&gt;child[j]));
+			put_child(right, j, rtnl_dereference(inode-&gt;child[j + size]));
 		}
-		put_child(t, tn, 2*i, resize(t, left));
-		put_child(t, tn, 2*i+1, resize(t, right));
+		put_child(tn, 2*i, resize(t, left));
+		put_child(tn, 2*i+1, resize(t, right));
 
 		tnode_free_safe(inode);
 	}
@@ -877,7 +876,7 @@ static struct tnode *halve(struct trie *t, struct tnode *tn)
 			if (!newn)
 				goto nomem;
 
-			put_child(t, tn, i/2, (struct rt_trie_node *)newn);
+			put_child(tn, i/2, (struct rt_trie_node *)newn);
 		}
 
 	}
@@ -892,21 +891,21 @@ static struct tnode *halve(struct trie *t, struct tnode *tn)
 		if (left == NULL) {
 			if (right == NULL)    /* Both are empty */
 				continue;
-			put_child(t, tn, i/2, right);
+			put_child(tn, i/2, right);
 			continue;
 		}
 
 		if (right == NULL) {
-			put_child(t, tn, i/2, left);
+			put_child(tn, i/2, left);
 			continue;
 		}
 
 		/* Two nonempty children */
 		newBinNode = (struct tnode *) tnode_get_child(tn, i/2);
-		put_child(t, tn, i/2, NULL);
-		put_child(t, newBinNode, 0, left);
-		put_child(t, newBinNode, 1, right);
-		put_child(t, tn, i/2, resize(t, newBinNode));
+		put_child(tn, i/2, NULL);
+		put_child(newBinNode, 0, left);
+		put_child(newBinNode, 1, right);
+		put_child(tn, i/2, resize(t, newBinNode));
 	}
 	tnode_free_safe(oldtnode);
 	return tn;
@@ -1125,7 +1124,7 @@ static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
 		node_set_parent((struct rt_trie_node *)l, tp);
 
 		cindex = tkey_extract_bits(key, tp-&gt;pos, tp-&gt;bits);
-		put_child(t, tp, cindex, (struct rt_trie_node *)l);
+		put_child(tp, cindex, (struct rt_trie_node *)l);
 	} else {
 		/* Case 3: n is a LEAF or a TNODE and the key doesn't match. */
 		/*
@@ -1155,12 +1154,12 @@ static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
 		node_set_parent((struct rt_trie_node *)tn, tp);
 
 		missbit = tkey_extract_bits(key, newpos, 1);
-		put_child(t, tn, missbit, (struct rt_trie_node *)l);
-		put_child(t, tn, 1-missbit, n);
+		put_child(tn, missbit, (struct rt_trie_node *)l);
+		put_child(tn, 1-missbit, n);
 
 		if (tp) {
 			cindex = tkey_extract_bits(key, tp-&gt;pos, tp-&gt;bits);
-			put_child(t, tp, cindex, (struct rt_trie_node *)tn);
+			put_child(tp, cindex, (struct rt_trie_node *)tn);
 		} else {
 			rcu_assign_pointer(t-&gt;trie, (struct rt_trie_node *)tn);
 			tp = tn;
@@ -1619,7 +1618,7 @@ static void trie_leaf_remove(struct trie *t, struct leaf *l)
 
 	if (tp) {
 		t_key cindex = tkey_extract_bits(l-&gt;key, tp-&gt;pos, tp-&gt;bits);
-		put_child(t, tp, cindex, NULL);
+		put_child(tp, cindex, NULL);
 		trie_rebalance(t, tp);
 	} else
 		RCU_INIT_POINTER(t-&gt;trie, NULL);</pre><hr><pre>commit 4ea4bf7ebcbacee2f4736d261efb0693e87a34c9
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Sun Jul 29 01:19:55 2012 +0000

    ipv4: fix debug info in tnode_new
    
    It should print size of struct rt_trie_node * allocated instead of size
    of struct rt_trie_node.
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 18cbc15b20d5..2a6fdc2708c6 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -473,7 +473,7 @@ static struct tnode *tnode_new(t_key key, int pos, int bits)
 	}
 
 	pr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),
-		 sizeof(struct rt_trie_node) &lt;&lt; bits);
+		 sizeof(struct rt_trie_node *) &lt;&lt; bits);
 	return tn;
 }
 </pre><hr><pre>commit 8fe5cb873b7ef7f4fa49477455e8f2e3d555230e
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Mon Jul 23 04:11:21 2012 +0000

    ipv4: Remove redundant assignment
    
    It is redundant to set no_addr and accept_local to 0 and then set them
    with other values just after that.
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index f277cf0e6321..8732cc7920ed 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -258,7 +258,6 @@ static int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,
 	fl4.flowi4_tos = tos;
 	fl4.flowi4_scope = RT_SCOPE_UNIVERSE;
 
-	no_addr = accept_local = 0;
 	no_addr = idev-&gt;ifa_list == NULL;
 
 	accept_local = IN_DEV_ACCEPT_LOCAL(idev);</pre><hr><pre>commit 9e33ce453f8ac8452649802bee1f410319408f4b
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Sat Jul 7 18:26:10 2012 +0800

    ipvs: fix oops on NAT reply in br_nf context
    
    IPVS should not reset skb-&gt;nf_bridge in FORWARD hook
    by calling nf_reset for NAT replies. It triggers oops in
    br_nf_forward_finish.
    
    [  579.781508] BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    [  579.781669] IP: [&lt;ffffffff817b1ca5&gt;] br_nf_forward_finish+0x58/0x112
    [  579.781792] PGD 218f9067 PUD 0
    [  579.781865] Oops: 0000 [#1] SMP
    [  579.781945] CPU 0
    [  579.781983] Modules linked in:
    [  579.782047]
    [  579.782080]
    [  579.782114] Pid: 4644, comm: qemu Tainted: G        W    3.5.0-rc5-00006-g95e69f9 #282 Hewlett-Packard  /30E8
    [  579.782300] RIP: 0010:[&lt;ffffffff817b1ca5&gt;]  [&lt;ffffffff817b1ca5&gt;] br_nf_forward_finish+0x58/0x112
    [  579.782455] RSP: 0018:ffff88007b003a98  EFLAGS: 00010287
    [  579.782541] RAX: 0000000000000008 RBX: ffff8800762ead00 RCX: 000000000001670a
    [  579.782653] RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff8800762ead00
    [  579.782845] RBP: ffff88007b003ac8 R08: 0000000000016630 R09: ffff88007b003a90
    [  579.782957] R10: ffff88007b0038e8 R11: ffff88002da37540 R12: ffff88002da01a02
    [  579.783066] R13: ffff88002da01a80 R14: ffff88002d83c000 R15: ffff88002d82a000
    [  579.783177] FS:  0000000000000000(0000) GS:ffff88007b000000(0063) knlGS:00000000f62d1b70
    [  579.783306] CS:  0010 DS: 002b ES: 002b CR0: 000000008005003b
    [  579.783395] CR2: 0000000000000004 CR3: 00000000218fe000 CR4: 00000000000027f0
    [  579.783505] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  579.783684] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  579.783795] Process qemu (pid: 4644, threadinfo ffff880021b20000, task ffff880021aba760)
    [  579.783919] Stack:
    [  579.783959]  ffff88007693cedc ffff8800762ead00 ffff88002da01a02 ffff8800762ead00
    [  579.784110]  ffff88002da01a02 ffff88002da01a80 ffff88007b003b18 ffffffff817b26c7
    [  579.784260]  ffff880080000000 ffffffff81ef59f0 ffff8800762ead00 ffffffff81ef58b0
    [  579.784477] Call Trace:
    [  579.784523]  &lt;IRQ&gt;
    [  579.784562]
    [  579.784603]  [&lt;ffffffff817b26c7&gt;] br_nf_forward_ip+0x275/0x2c8
    [  579.784707]  [&lt;ffffffff81704b58&gt;] nf_iterate+0x47/0x7d
    [  579.784797]  [&lt;ffffffff817ac32e&gt;] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.784906]  [&lt;ffffffff81704bfb&gt;] nf_hook_slow+0x6d/0x102
    [  579.784995]  [&lt;ffffffff817ac32e&gt;] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.785175]  [&lt;ffffffff8187fa95&gt;] ? _raw_write_unlock_bh+0x19/0x1b
    [  579.785179]  [&lt;ffffffff817ac417&gt;] __br_forward+0x97/0xa2
    [  579.785179]  [&lt;ffffffff817ad366&gt;] br_handle_frame_finish+0x1a6/0x257
    [  579.785179]  [&lt;ffffffff817b2386&gt;] br_nf_pre_routing_finish+0x26d/0x2cb
    [  579.785179]  [&lt;ffffffff817b2cf0&gt;] br_nf_pre_routing+0x55d/0x5c1
    [  579.785179]  [&lt;ffffffff81704b58&gt;] nf_iterate+0x47/0x7d
    [  579.785179]  [&lt;ffffffff817ad1c0&gt;] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [&lt;ffffffff81704bfb&gt;] nf_hook_slow+0x6d/0x102
    [  579.785179]  [&lt;ffffffff817ad1c0&gt;] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [&lt;ffffffff81551525&gt;] ? sky2_poll+0xb35/0xb54
    [  579.785179]  [&lt;ffffffff817ad62a&gt;] br_handle_frame+0x213/0x229
    [  579.785179]  [&lt;ffffffff817ad417&gt;] ? br_handle_frame_finish+0x257/0x257
    [  579.785179]  [&lt;ffffffff816e3b47&gt;] __netif_receive_skb+0x2b4/0x3f1
    [  579.785179]  [&lt;ffffffff816e69fc&gt;] process_backlog+0x99/0x1e2
    [  579.785179]  [&lt;ffffffff816e6800&gt;] net_rx_action+0xdf/0x242
    [  579.785179]  [&lt;ffffffff8107e8a8&gt;] __do_softirq+0xc1/0x1e0
    [  579.785179]  [&lt;ffffffff8135a5ba&gt;] ? trace_hardirqs_off_thunk+0x3a/0x6c
    [  579.785179]  [&lt;ffffffff8188812c&gt;] call_softirq+0x1c/0x30
    
    The steps to reproduce as follow,
    
    1. On Host1, setup brige br0(192.168.1.106)
    2. Boot a kvm guest(192.168.1.105) on Host1 and start httpd
    3. Start IPVS service on Host1
       ipvsadm -A -t 192.168.1.106:80 -s rr
       ipvsadm -a -t 192.168.1.106:80 -r 192.168.1.105:80 -m
    4. Run apache benchmark on Host2(192.168.1.101)
       ab -n 1000 http://192.168.1.106/
    
    ip_vs_reply4
      ip_vs_out
        handle_response
          ip_vs_notrack
            nf_reset()
            {
              skb-&gt;nf_bridge = NULL;
            }
    
    Actually, IPVS wants in this case just to replace nfct
    with untracked version. So replace the nf_reset(skb) call
    in ip_vs_notrack() with a nf_conntrack_put(skb-&gt;nfct) call.
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: Julian Anastasov &lt;ja@ssi.bg&gt;
    Signed-off-by: Simon Horman &lt;horms@verge.net.au&gt;
    Signed-off-by: Pablo Neira Ayuso &lt;pablo@netfilter.org&gt;

diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index d6146b4811c2..95374d1696a1 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -1425,7 +1425,7 @@ static inline void ip_vs_notrack(struct sk_buff *skb)
 	struct nf_conn *ct = nf_ct_get(skb, &amp;ctinfo);
 
 	if (!ct || !nf_ct_is_untracked(ct)) {
-		nf_reset(skb);
+		nf_conntrack_put(skb-&gt;nfct);
 		skb-&gt;nfct = &amp;nf_ct_untracked_get()-&gt;ct_general;
 		skb-&gt;nfctinfo = IP_CT_NEW;
 		nf_conntrack_get(skb-&gt;nfct);</pre><hr><pre>commit 1ff2b0c303698e486f1e0886b4d9876200ef8ca5
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Sat Apr 21 00:11:05 2012 +0800

    xen: implement IRQ_WORK_VECTOR handler
    
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;

diff --git a/arch/x86/include/asm/xen/events.h b/arch/x86/include/asm/xen/events.h
index 1df35417c412..cc146d51449e 100644
--- a/arch/x86/include/asm/xen/events.h
+++ b/arch/x86/include/asm/xen/events.h
@@ -6,6 +6,7 @@ enum ipi_vector {
 	XEN_CALL_FUNCTION_VECTOR,
 	XEN_CALL_FUNCTION_SINGLE_VECTOR,
 	XEN_SPIN_UNLOCK_VECTOR,
+	XEN_IRQ_WORK_VECTOR,
 
 	XEN_NR_IPIS,
 };
diff --git a/arch/x86/xen/smp.c b/arch/x86/xen/smp.c
index 2dc6628c1520..3ec3f8eb19fc 100644
--- a/arch/x86/xen/smp.c
+++ b/arch/x86/xen/smp.c
@@ -16,6 +16,7 @@
 #include &lt;linux/err.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/smp.h&gt;
+#include &lt;linux/irq_work.h&gt;
 
 #include &lt;asm/paravirt.h&gt;
 #include &lt;asm/desc.h&gt;
@@ -41,10 +42,12 @@ cpumask_var_t xen_cpu_initialized_map;
 static DEFINE_PER_CPU(int, xen_resched_irq);
 static DEFINE_PER_CPU(int, xen_callfunc_irq);
 static DEFINE_PER_CPU(int, xen_callfuncsingle_irq);
+static DEFINE_PER_CPU(int, xen_irq_work);
 static DEFINE_PER_CPU(int, xen_debug_irq) = -1;
 
 static irqreturn_t xen_call_function_interrupt(int irq, void *dev_id);
 static irqreturn_t xen_call_function_single_interrupt(int irq, void *dev_id);
+static irqreturn_t xen_irq_work_interrupt(int irq, void *dev_id);
 
 /*
  * Reschedule call back.
@@ -143,6 +146,17 @@ static int xen_smp_intr_init(unsigned int cpu)
 		goto fail;
 	per_cpu(xen_callfuncsingle_irq, cpu) = rc;
 
+	callfunc_name = kasprintf(GFP_KERNEL, "irqwork%d", cpu);
+	rc = bind_ipi_to_irqhandler(XEN_IRQ_WORK_VECTOR,
+				    cpu,
+				    xen_irq_work_interrupt,
+				    IRQF_DISABLED|IRQF_PERCPU|IRQF_NOBALANCING,
+				    callfunc_name,
+				    NULL);
+	if (rc &lt; 0)
+		goto fail;
+	per_cpu(xen_irq_work, cpu) = rc;
+
 	return 0;
 
  fail:
@@ -155,6 +169,8 @@ static int xen_smp_intr_init(unsigned int cpu)
 	if (per_cpu(xen_callfuncsingle_irq, cpu) &gt;= 0)
 		unbind_from_irqhandler(per_cpu(xen_callfuncsingle_irq, cpu),
 				       NULL);
+	if (per_cpu(xen_irq_work, cpu) &gt;= 0)
+		unbind_from_irqhandler(per_cpu(xen_irq_work, cpu), NULL);
 
 	return rc;
 }
@@ -509,6 +525,9 @@ static inline int xen_map_vector(int vector)
 	case CALL_FUNCTION_SINGLE_VECTOR:
 		xen_vector = XEN_CALL_FUNCTION_SINGLE_VECTOR;
 		break;
+	case IRQ_WORK_VECTOR:
+		xen_vector = XEN_IRQ_WORK_VECTOR;
+		break;
 	default:
 		xen_vector = -1;
 		printk(KERN_ERR "xen: vector 0x%x is not implemented\n",
@@ -588,6 +607,16 @@ static irqreturn_t xen_call_function_single_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t xen_irq_work_interrupt(int irq, void *dev_id)
+{
+	irq_enter();
+	irq_work_run();
+	inc_irq_stat(apic_irq_work_irqs);
+	irq_exit();
+
+	return IRQ_HANDLED;
+}
+
 static const struct smp_ops xen_smp_ops __initconst = {
 	.smp_prepare_boot_cpu = xen_smp_prepare_boot_cpu,
 	.smp_prepare_cpus = xen_smp_prepare_cpus,
@@ -634,6 +663,7 @@ static void xen_hvm_cpu_die(unsigned int cpu)
 	unbind_from_irqhandler(per_cpu(xen_callfunc_irq, cpu), NULL);
 	unbind_from_irqhandler(per_cpu(xen_debug_irq, cpu), NULL);
 	unbind_from_irqhandler(per_cpu(xen_callfuncsingle_irq, cpu), NULL);
+	unbind_from_irqhandler(per_cpu(xen_irq_work, cpu), NULL);
 	native_cpu_die(cpu);
 }
 </pre><hr><pre>commit ab6ec39a191243b9968bb9ac7f26cc7ec30c618b
Author: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
Date:   Tue May 1 00:16:27 2012 +0800

    xen/apic: implement io apic read with hypercall
    
    Implements xen_io_apic_read with hypercall, so it returns proper
    IO-APIC information instead of fabricated one.
    
    Fallback to return an emulated IO_APIC values if hypercall fails.
    
    [v2: fallback to return an emulated IO_APIC values if hypercall fails]
    Signed-off-by: Lin Ming &lt;mlin@ss.pku.edu.cn&gt;
    Signed-off-by: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;

diff --git a/arch/x86/xen/apic.c b/arch/x86/xen/apic.c
index 73ade38caa32..1913bf2d2a9c 100644
--- a/arch/x86/xen/apic.c
+++ b/arch/x86/xen/apic.c
@@ -1,8 +1,21 @@
 #include &lt;linux/init.h&gt;
 #include &lt;asm/x86_init.h&gt;
+#include &lt;asm/apic.h&gt;
+#include &lt;xen/interface/physdev.h&gt;
+#include &lt;asm/xen/hypercall.h&gt;
 
 unsigned int xen_io_apic_read(unsigned apic, unsigned reg)
 {
+	struct physdev_apic apic_op;
+	int ret;
+
+	apic_op.apic_physbase = mpc_ioapic_addr(apic);
+	apic_op.reg = reg;
+	ret = HYPERVISOR_physdev_op(PHYSDEVOP_apic_read, &amp;apic_op);
+	if (!ret)
+		return apic_op.value;
+
+	/* fallback to return an emulated IO_APIC values */
 	if (reg == 0x1)
 		return 0x00170020;
 	else if (reg == 0x0)</pre>
    <div class="pagination">
        <a href='11_9.html'>&lt;&lt;Prev</a><a href='11.html'>1</a><a href='11_2.html'>2</a><a href='11_3.html'>3</a><a href='11_4.html'>4</a><a href='11_5.html'>5</a><a href='11_6.html'>6</a><a href='11_7.html'>7</a><a href='11_8.html'>8</a><a href='11_9.html'>9</a><span>[10]</span>
    <div>
</body>
