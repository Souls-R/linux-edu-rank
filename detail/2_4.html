<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_3.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><span>[4]</span><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 811d581194f7412eda97acc03d17fc77824b561f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 3 14:32:09 2023 -0500

    net: USB: Fix wrong-direction WARNING in plusb.c
    
    The syzbot fuzzer detected a bug in the plusb network driver: A
    zero-length control-OUT transfer was treated as a read instead of a
    write.  In modern kernels this error provokes a WARNING:
    
    usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType c0
    WARNING: CPU: 0 PID: 4645 at drivers/usb/core/urb.c:411
    usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    Modules linked in:
    CPU: 1 PID: 4645 Comm: dhcpcd Not tainted
    6.2.0-rc6-syzkaller-00050-g9f266ccaa2f5 #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    01/12/2023
    RIP: 0010:usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    ...
    Call Trace:
     &lt;TASK&gt;
     usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58
     usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
     usb_control_msg+0x320/0x4a0 drivers/usb/core/message.c:153
     __usbnet_read_cmd+0xb9/0x390 drivers/net/usb/usbnet.c:2010
     usbnet_read_cmd+0x96/0xf0 drivers/net/usb/usbnet.c:2068
     pl_vendor_req drivers/net/usb/plusb.c:60 [inline]
     pl_set_QuickLink_features drivers/net/usb/plusb.c:75 [inline]
     pl_reset+0x2f/0xf0 drivers/net/usb/plusb.c:85
     usbnet_open+0xcc/0x5d0 drivers/net/usb/usbnet.c:889
     __dev_open+0x297/0x4d0 net/core/dev.c:1417
     __dev_change_flags+0x587/0x750 net/core/dev.c:8530
     dev_change_flags+0x97/0x170 net/core/dev.c:8602
     devinet_ioctl+0x15a2/0x1d70 net/ipv4/devinet.c:1147
     inet_ioctl+0x33f/0x380 net/ipv4/af_inet.c:979
     sock_do_ioctl+0xcc/0x230 net/socket.c:1169
     sock_ioctl+0x1f8/0x680 net/socket.c:1286
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:870 [inline]
     __se_sys_ioctl fs/ioctl.c:856 [inline]
     __x64_sys_ioctl+0x197/0x210 fs/ioctl.c:856
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    The fix is to call usbnet_write_cmd() instead of usbnet_read_cmd() and
    remove the USB_DIR_IN flag.
    
    Reported-and-tested-by: syzbot+2a0e7abd24f1eb90ce25@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 090ffa9d0e90 ("[PATCH] USB: usbnet (9/9) module for pl2301/2302 cables")
    CC: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/00000000000052099f05f3b3e298@google.com/
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c
index 2c82fbcaab22..7a2b0094de51 100644
--- a/drivers/net/usb/plusb.c
+++ b/drivers/net/usb/plusb.c
@@ -57,9 +57,7 @@
 static inline int
 pl_vendor_req(struct usbnet *dev, u8 req, u8 val, u8 index)
 {
-	return usbnet_read_cmd(dev, req,
-				USB_DIR_IN | USB_TYPE_VENDOR |
-				USB_RECIP_DEVICE,
+	return usbnet_write_cmd(dev, req, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 				val, index, NULL, 0);
 }
 </pre><hr><pre>commit 45bf39f8df7f05efb83b302c65ae3b9bc92b7065
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 31 15:49:04 2023 -0500

    USB: core: Don't hold device lock while reading the "descriptors" sysfs file
    
    Ever since commit 83e83ecb79a8 ("usb: core: get config and string
    descriptors for unauthorized devices") was merged in 2013, there has
    been no mechanism for reallocating the rawdescriptors buffers in
    struct usb_device after the initial enumeration.  Before that commit,
    the buffers would be deallocated when a device was deauthorized and
    reallocated when it was authorized and enumerated.
    
    This means that the locking in the read_descriptors() routine is not
    needed, since the buffers it reads will never be reallocated while the
    routine is running.  This locking can interfere with user programs
    trying to read a hub's descriptors via sysfs while new child devices
    of the hub are being initialized, since the hub is locked during this
    procedure.
    
    Since the locking in read_descriptors() hasn't been needed for over
    nine years, we can remove it.
    
    Reported-and-tested-by: Troels Liebe Bentsen &lt;troels@connectedcars.dk&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/Y9l+wDTRbuZABzsE@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 9eca403af2a8..97a0f8faea6e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2389,9 +2389,8 @@ static int usb_enumerate_device_otg(struct usb_device *udev)
  * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * This is only called by usb_new_device() and usb_authorize_device()
- * and FIXME -- all comments that apply to them apply here wrt to
- * environment.
+ * This is only called by usb_new_device() -- all comments that apply there
+ * apply here wrt to environment.
  *
  * If the device is WUSB and not authorized, we don't attempt to read
  * the string descriptors, as they will be errored out by the device
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 8217032dfb85..b63f78e48c74 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -869,11 +869,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 	size_t srclen, n;
 	int cfgno;
 	void *src;
-	int retval;
 
-	retval = usb_lock_device_interruptible(udev);
-	if (retval &lt; 0)
-		return -EINTR;
 	/* The binary attribute begins with the device descriptor.
 	 * Following that are the raw descriptor entries for all the
 	 * configurations (config plus subsidiary descriptors).
@@ -898,7 +894,6 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 			off -= srclen;
 		}
 	}
-	usb_unlock_device(udev);
 	return count - nleft;
 }
 </pre><hr><pre>commit d18dcfe9860e842f394e37ba01ca9440ab2178f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 23 09:59:09 2022 -0500

    USB: gadgetfs: Fix race between mounting and unmounting
    
    The syzbot fuzzer and Gerald Lee have identified a use-after-free bug
    in the gadgetfs driver, involving processes concurrently mounting and
    unmounting the gadgetfs filesystem.  In particular, gadgetfs_fill_super()
    can race with gadgetfs_kill_sb(), causing the latter to deallocate
    the_device while the former is using it.  The output from KASAN says,
    in part:
    
    BUG: KASAN: use-after-free in instrument_atomic_read_write include/linux/instrumented.h:102 [inline]
    BUG: KASAN: use-after-free in atomic_fetch_sub_release include/linux/atomic/atomic-instrumented.h:176 [inline]
    BUG: KASAN: use-after-free in __refcount_sub_and_test include/linux/refcount.h:272 [inline]
    BUG: KASAN: use-after-free in __refcount_dec_and_test include/linux/refcount.h:315 [inline]
    BUG: KASAN: use-after-free in refcount_dec_and_test include/linux/refcount.h:333 [inline]
    BUG: KASAN: use-after-free in put_dev drivers/usb/gadget/legacy/inode.c:159 [inline]
    BUG: KASAN: use-after-free in gadgetfs_kill_sb+0x33/0x100 drivers/usb/gadget/legacy/inode.c:2086
    Write of size 4 at addr ffff8880276d7840 by task syz-executor126/18689
    
    CPU: 0 PID: 18689 Comm: syz-executor126 Not tainted 6.1.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
    Call Trace:
     &lt;TASK&gt;
    ...
     atomic_fetch_sub_release include/linux/atomic/atomic-instrumented.h:176 [inline]
     __refcount_sub_and_test include/linux/refcount.h:272 [inline]
     __refcount_dec_and_test include/linux/refcount.h:315 [inline]
     refcount_dec_and_test include/linux/refcount.h:333 [inline]
     put_dev drivers/usb/gadget/legacy/inode.c:159 [inline]
     gadgetfs_kill_sb+0x33/0x100 drivers/usb/gadget/legacy/inode.c:2086
     deactivate_locked_super+0xa7/0xf0 fs/super.c:332
     vfs_get_super fs/super.c:1190 [inline]
     get_tree_single+0xd0/0x160 fs/super.c:1207
     vfs_get_tree+0x88/0x270 fs/super.c:1531
     vfs_fsconfig_locked fs/fsopen.c:232 [inline]
    
    The simplest solution is to ensure that gadgetfs_fill_super() and
    gadgetfs_kill_sb() are serialized by making them both acquire a new
    mutex.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+33d7ad66d65044b93f16@syzkaller.appspotmail.com
    Reported-and-tested-by: Gerald Lee &lt;sundaywind2004@gmail.com&gt;
    Link: https://lore.kernel.org/linux-usb/CAO3qeMVzXDP-JU6v1u5Ags6Q-bb35kg3=C6d04DjzA9ffa5x1g@mail.gmail.com/
    Fixes: e5d82a7360d1 ("vfs: Convert gadgetfs to use the new mount API")
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Y6XCPXBpn3tmjdCC@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 01c3ead7d1b4..d605bc2e7e8f 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -229,6 +229,7 @@ static void put_ep (struct ep_data *data)
  */
 
 static const char *CHIP;
+static DEFINE_MUTEX(sb_mutex);		/* Serialize superblock operations */
 
 /*----------------------------------------------------------------------*/
 
@@ -2010,13 +2011,20 @@ gadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)
 {
 	struct inode	*inode;
 	struct dev_data	*dev;
+	int		rc;
 
-	if (the_device)
-		return -ESRCH;
+	mutex_lock(&amp;sb_mutex);
+
+	if (the_device) {
+		rc = -ESRCH;
+		goto Done;
+	}
 
 	CHIP = usb_get_gadget_udc_name();
-	if (!CHIP)
-		return -ENODEV;
+	if (!CHIP) {
+		rc = -ENODEV;
+		goto Done;
+	}
 
 	/* superblock */
 	sb-&gt;s_blocksize = PAGE_SIZE;
@@ -2053,13 +2061,17 @@ gadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)
 	 * from binding to a controller.
 	 */
 	the_device = dev;
-	return 0;
+	rc = 0;
+	goto Done;
 
-Enomem:
+ Enomem:
 	kfree(CHIP);
 	CHIP = NULL;
+	rc = -ENOMEM;
 
-	return -ENOMEM;
+ Done:
+	mutex_unlock(&amp;sb_mutex);
+	return rc;
 }
 
 /* "mount -t gadgetfs path /dev/gadget" ends up here */
@@ -2081,6 +2093,7 @@ static int gadgetfs_init_fs_context(struct fs_context *fc)
 static void
 gadgetfs_kill_sb (struct super_block *sb)
 {
+	mutex_lock(&amp;sb_mutex);
 	kill_litter_super (sb);
 	if (the_device) {
 		put_dev (the_device);
@@ -2088,6 +2101,7 @@ gadgetfs_kill_sb (struct super_block *sb)
 	}
 	kfree(CHIP);
 	CHIP = NULL;
+	mutex_unlock(&amp;sb_mutex);
 }
 
 /*----------------------------------------------------------------------*/</pre><hr><pre>commit ebd50e2947de9d2675b800a6a29748d0ed7d7fd4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 16 15:48:01 2022 -0500

    tools: memory-model: Add rmw-sequences to the LKMM
    
    Viktor (as relayed by Jonas) has pointed out a weakness in the Linux
    Kernel Memory Model.  Namely, the memory ordering properties of atomic
    operations are not monotonic: An atomic op with full-barrier semantics
    does not always provide ordering as strong as one with release-barrier
    semantics.
    
    The following litmus test illustrates the problem:
    
    --------------------------------------------------
    C atomics-not-monotonic
    
    {}
    
    P0(int *x, atomic_t *y)
    {
            WRITE_ONCE(*x, 1);
            smp_wmb();
            atomic_set(y, 1);
    }
    
    P1(atomic_t *y)
    {
            int r1;
    
            r1 = atomic_inc_return(y);
    }
    
    P2(int *x, atomic_t *y)
    {
            int r2;
            int r3;
    
            r2 = atomic_read(y);
            smp_rmb();
            r3 = READ_ONCE(*x);
    }
    
    exists (2:r2=2 /\ 2:r3=0)
    --------------------------------------------------
    
    The litmus test is allowed as shown with atomic_inc_return(), which
    has full-barrier semantics.  But if the operation is changed to
    atomic_inc_return_release(), which only has release-barrier semantics,
    the litmus test is forbidden.  Clearly this violates monotonicity.
    
    The reason is because the LKMM treats full-barrier atomic ops as if
    they were written:
    
            mb();
            load();
            store();
            mb();
    
    (where the load() and store() are the two parts of an atomic RMW op),
    whereas it treats release-barrier atomic ops as if they were written:
    
            load();
            release_barrier();
            store();
    
    The difference is that here the release barrier orders the load part
    of the atomic op before the store part with A-cumulativity, whereas
    the mb()'s above do not.  This means that release-barrier atomics can
    effectively extend the cumul-fence relation but full-barrier atomics
    cannot.
    
    To resolve this problem we introduce the rmw-sequence relation,
    representing an arbitrarily long sequence of atomic RMW operations in
    which each operation reads from the previous one, and explicitly allow
    it to extend cumul-fence.  This modification of the memory model is
    sound; it holds for PPC because of B-cumulativity, it holds for TSO
    and ARM64 because of other-multicopy atomicity, and we can assume that
    atomic ops on all other architectures will be implemented so as to
    make it hold for them.
    
    For similar reasons we also allow rmw-sequence to extend the
    w-post-bounded relation, which is analogous to cumul-fence in some
    ways.
    
    Reported-by: Viktor Vafeiadis &lt;viktor@mpi-sws.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Jonas Oberhauser &lt;jonas.oberhauser@huawei.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 11a1d2d4f681..e901b47236c3 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -1007,6 +1007,36 @@ order.  Equivalently,
 where the rmw relation links the read and write events making up each
 atomic update.  This is what the LKMM's "atomic" axiom says.
 
+Atomic rmw updates play one more role in the LKMM: They can form "rmw
+sequences".  An rmw sequence is simply a bunch of atomic updates where
+each update reads from the previous one.  Written using events, it
+looks like this:
+
+	Z0 -&gt;rf Y1 -&gt;rmw Z1 -&gt;rf ... -&gt;rf Yn -&gt;rmw Zn,
+
+where Z0 is some store event and n can be any number (even 0, in the
+degenerate case).  We write this relation as: Z0 -&gt;rmw-sequence Zn.
+Note that this implies Z0 and Zn are stores to the same variable.
+
+Rmw sequences have a special property in the LKMM: They can extend the
+cumul-fence relation.  That is, if we have:
+
+	U -&gt;cumul-fence X -&gt; rmw-sequence Y
+
+then also U -&gt;cumul-fence Y.  Thinking about this in terms of the
+operational model, U -&gt;cumul-fence X says that the store U propagates
+to each CPU before the store X does.  Then the fact that X and Y are
+linked by an rmw sequence means that U also propagates to each CPU
+before Y does.  In an analogous way, rmw sequences can also extend
+the w-post-bounded relation defined below in the PLAIN ACCESSES AND
+DATA RACES section.
+
+(The notion of rmw sequences in the LKMM is similar to, but not quite
+the same as, that of release sequences in the C11 memory model.  They
+were added to the LKMM to fix an obscure bug; without them, atomic
+updates with full-barrier semantics did not always guarantee ordering
+at least as strong as atomic updates with release-barrier semantics.)
+
 
 THE PRESERVED PROGRAM ORDER RELATION: ppo
 -----------------------------------------
diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index d70315fddef6..07f884f9b2bf 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -74,8 +74,9 @@ let ppo = to-r | to-w | fence | (po-unlock-lock-po &amp; int)
 
 (* Propagation: Ordering from release operations and strong fences. *)
 let A-cumul(r) = (rfe ; [Marked])? ; r
+let rmw-sequence = (rf ; rmw)*
 let cumul-fence = [Marked] ; (A-cumul(strong-fence | po-rel) | wmb |
-	po-unlock-lock-po) ; [Marked]
+	po-unlock-lock-po) ; [Marked] ; rmw-sequence
 let prop = [Marked] ; (overwrite &amp; ext)? ; cumul-fence* ;
 	[Marked] ; rfe? ; [Marked]
 
@@ -174,7 +175,7 @@ let vis = cumul-fence* ; rfe? ; [Marked] ;
 let w-pre-bounded = [Marked] ; (addr | fence)?
 let r-pre-bounded = [Marked] ; (addr | nonrw-fence |
 	([R4rmb] ; fencerel(Rmb) ; [~Noreturn]))?
-let w-post-bounded = fence? ; [Marked]
+let w-post-bounded = fence? ; [Marked] ; rmw-sequence
 let r-post-bounded = (nonrw-fence | ([~Noreturn] ; fencerel(Rmb) ; [R4rmb]))? ;
 	[Marked]
 </pre><hr><pre>commit 7a09c1269702db8eccb6f718da2b00173e1e0034
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 2 14:13:19 2022 -0400

    USB: core: Change configuration warnings to notices
    
    It has been pointed out that the kernel log messages warning about
    problems in USB configuration and related descriptors are vexing for
    users.  The warning log level has a fairly high priority, but the user
    can do nothing to fix the underlying errors in the device's firmware.
    
    To reduce the amount of useless information produced by tools that
    filter high-priority log messages, we can change these warnings to
    notices, i.e., change dev_warn() to dev_notice().  The same holds for
    a few messages that currently use dev_err(): Unless they indicate a
    failure that might make a device unusable (such as inability to
    transfer a config descriptor), change them to dev_notice() also.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=216630
    Suggested-by: Artem S. Tashkinov &lt;aros@gmx.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/Y2KzPx0h6z1jXCuN@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 48bc8a4814ac..725b8dbcfe5f 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -61,7 +61,7 @@ static void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,
 	desc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;
 	if (desc-&gt;bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||
 	    size &lt; USB_DT_SSP_ISOC_EP_COMP_SIZE) {
-		dev_warn(ddev, "Invalid SuperSpeedPlus isoc endpoint companion"
+		dev_notice(ddev, "Invalid SuperSpeedPlus isoc endpoint companion"
 			 "for config %d interface %d altsetting %d ep %d.\n",
 			 cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		return;
@@ -83,7 +83,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 
 	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||
 			size &lt; USB_DT_SS_EP_COMP_SIZE) {
-		dev_warn(ddev, "No SuperSpeed endpoint companion for config %d "
+		dev_notice(ddev, "No SuperSpeed endpoint companion for config %d "
 				" interface %d altsetting %d ep %d: "
 				"using minimum values\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -109,13 +109,13 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 
 	/* Check the various values */
 	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bMaxBurst != 0) {
-		dev_warn(ddev, "Control endpoint with bMaxBurst = %d in "
+		dev_notice(ddev, "Control endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bMaxBurst = 0;
 	} else if (desc-&gt;bMaxBurst &gt; 15) {
-		dev_warn(ddev, "Endpoint with bMaxBurst = %d in "
+		dev_notice(ddev, "Endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 15\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -125,7 +125,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) ||
 			usb_endpoint_xfer_int(&amp;ep-&gt;desc)) &amp;&amp;
 				desc-&gt;bmAttributes != 0) {
-		dev_warn(ddev, "%s endpoint with bmAttributes = %d in "
+		dev_notice(ddev, "%s endpoint with bmAttributes = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n",
 				usb_endpoint_xfer_control(&amp;ep-&gt;desc) ? "Control" : "Bulk",
@@ -134,7 +134,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 		ep-&gt;ss_ep_comp.bmAttributes = 0;
 	} else if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp;
 			desc-&gt;bmAttributes &gt; 16) {
-		dev_warn(ddev, "Bulk endpoint with more than 65536 streams in "
+		dev_notice(ddev, "Bulk endpoint with more than 65536 streams in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to max\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -142,7 +142,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	} else if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp;
 		   !USB_SS_SSP_ISOC_COMP(desc-&gt;bmAttributes) &amp;&amp;
 		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {
-		dev_warn(ddev, "Isoc endpoint has Mult of %d in "
+		dev_notice(ddev, "Isoc endpoint has Mult of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 3\n",
 				USB_SS_MULT(desc-&gt;bmAttributes),
@@ -160,7 +160,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	else
 		max_tx = 999999;
 	if (le16_to_cpu(desc-&gt;wBytesPerInterval) &gt; max_tx) {
-		dev_warn(ddev, "%s endpoint with wBytesPerInterval of %d in "
+		dev_notice(ddev, "%s endpoint with wBytesPerInterval of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to %d\n",
 				usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) ? "Isoc" : "Int",
@@ -273,7 +273,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	else if (d-&gt;bLength &gt;= USB_DT_ENDPOINT_SIZE)
 		n = USB_DT_ENDPOINT_SIZE;
 	else {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
+		dev_notice(ddev, "config %d interface %d altsetting %d has an "
 		    "invalid endpoint descriptor of length %d, skipping\n",
 		    cfgno, inum, asnum, d-&gt;bLength);
 		goto skip_to_next_endpoint_or_interface_descriptor;
@@ -281,7 +281,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 
 	i = d-&gt;bEndpointAddress &amp; ~USB_ENDPOINT_DIR_MASK;
 	if (i &gt;= 16 || i == 0) {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
+		dev_notice(ddev, "config %d interface %d altsetting %d has an "
 		    "invalid endpoint with address 0x%X, skipping\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		goto skip_to_next_endpoint_or_interface_descriptor;
@@ -293,7 +293,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 
 	/* Check for duplicate endpoint addresses */
 	if (config_endpoint_is_duplicate(config, inum, asnum, d)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
 				cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		goto skip_to_next_endpoint_or_interface_descriptor;
 	}
@@ -301,7 +301,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	/* Ignore some endpoints */
 	if (udev-&gt;quirks &amp; USB_QUIRK_ENDPOINT_IGNORE) {
 		if (usb_endpoint_is_ignored(udev, ifp, d)) {
-			dev_warn(ddev, "config %d interface %d altsetting %d has an ignored endpoint with address 0x%X, skipping\n",
+			dev_notice(ddev, "config %d interface %d altsetting %d has an ignored endpoint with address 0x%X, skipping\n",
 					cfgno, inum, asnum,
 					d-&gt;bEndpointAddress);
 			goto skip_to_next_endpoint_or_interface_descriptor;
@@ -378,7 +378,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 		}
 	}
 	if (d-&gt;bInterval &lt; i || d-&gt;bInterval &gt; j) {
-		dev_warn(ddev, "config %d interface %d altsetting %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d "
 		    "endpoint 0x%X has an invalid bInterval %d, "
 		    "changing to %d\n",
 		    cfgno, inum, asnum,
@@ -391,7 +391,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 * them usable, we will try treating them as Interrupt endpoints.
 	 */
 	if (udev-&gt;speed == USB_SPEED_LOW &amp;&amp; usb_endpoint_xfer_bulk(d)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d "
 		    "endpoint 0x%X is Bulk; changing to Interrupt\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		endpoint-&gt;desc.bmAttributes = USB_ENDPOINT_XFER_INT;
@@ -408,7 +408,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 */
 	maxp = le16_to_cpu(endpoint-&gt;desc.wMaxPacketSize);
 	if (maxp == 0 &amp;&amp; !(usb_endpoint_xfer_isoc(d) &amp;&amp; asnum == 0)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 	}
 
@@ -439,7 +439,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];
 
 	if (maxp &gt; j) {
-		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);
 		maxp = j;
 		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);
@@ -452,7 +452,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 */
 	if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; usb_endpoint_xfer_bulk(d)) {
 		if (maxp != 512)
-			dev_warn(ddev, "config %d interface %d altsetting %d "
+			dev_notice(ddev, "config %d interface %d altsetting %d "
 				"bulk endpoint 0x%X has invalid maxpacket %d\n",
 				cfgno, inum, asnum, d-&gt;bEndpointAddress,
 				maxp);
@@ -533,7 +533,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	      i &lt; intfc-&gt;num_altsetting;
 	     (++i, ++alt)) {
 		if (alt-&gt;desc.bAlternateSetting == asnum) {
-			dev_warn(ddev, "Duplicate descriptor for config %d "
+			dev_notice(ddev, "Duplicate descriptor for config %d "
 			    "interface %d altsetting %d, skipping\n",
 			    cfgno, inum, asnum);
 			goto skip_to_next_interface_descriptor;
@@ -559,7 +559,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	num_ep = num_ep_orig = alt-&gt;desc.bNumEndpoints;
 	alt-&gt;desc.bNumEndpoints = 0;		/* Use as a counter */
 	if (num_ep &gt; USB_MAXENDPOINTS) {
-		dev_warn(ddev, "too many endpoints for config %d interface %d "
+		dev_notice(ddev, "too many endpoints for config %d interface %d "
 		    "altsetting %d: %d, using maximum allowed: %d\n",
 		    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);
 		num_ep = USB_MAXENDPOINTS;
@@ -590,7 +590,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	}
 
 	if (n != num_ep_orig)
-		dev_warn(ddev, "config %d interface %d altsetting %d has %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d has %d "
 		    "endpoint descriptor%s, different from the interface "
 		    "descriptor's value: %d\n",
 		    cfgno, inum, asnum, n, plural(n), num_ep_orig);
@@ -625,7 +625,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
 	    config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE ||
 	    config-&gt;desc.bLength &gt; size) {
-		dev_err(ddev, "invalid descriptor for config index %d: "
+		dev_notice(ddev, "invalid descriptor for config index %d: "
 		    "type = 0x%X, length = %d\n", cfgidx,
 		    config-&gt;desc.bDescriptorType, config-&gt;desc.bLength);
 		return -EINVAL;
@@ -636,7 +636,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	size -= config-&gt;desc.bLength;
 
 	if (nintf &gt; USB_MAXINTERFACES) {
-		dev_warn(ddev, "config %d has too many interfaces: %d, "
+		dev_notice(ddev, "config %d has too many interfaces: %d, "
 		    "using maximum allowed: %d\n",
 		    cfgno, nintf, USB_MAXINTERFACES);
 		nintf = USB_MAXINTERFACES;
@@ -650,7 +650,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	     (buffer2 += header-&gt;bLength, size2 -= header-&gt;bLength)) {
 
 		if (size2 &lt; sizeof(struct usb_descriptor_header)) {
-			dev_warn(ddev, "config %d descriptor has %d excess "
+			dev_notice(ddev, "config %d descriptor has %d excess "
 			    "byte%s, ignoring\n",
 			    cfgno, size2, plural(size2));
 			break;
@@ -658,7 +658,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 		header = (struct usb_descriptor_header *) buffer2;
 		if ((header-&gt;bLength &gt; size2) || (header-&gt;bLength &lt; 2)) {
-			dev_warn(ddev, "config %d has an invalid descriptor "
+			dev_notice(ddev, "config %d has an invalid descriptor "
 			    "of length %d, skipping remainder of the config\n",
 			    cfgno, header-&gt;bLength);
 			break;
@@ -670,7 +670,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			d = (struct usb_interface_descriptor *) header;
 			if (d-&gt;bLength &lt; USB_DT_INTERFACE_SIZE) {
-				dev_warn(ddev, "config %d has an invalid "
+				dev_notice(ddev, "config %d has an invalid "
 				    "interface descriptor of length %d, "
 				    "skipping\n", cfgno, d-&gt;bLength);
 				continue;
@@ -680,7 +680,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			if ((dev-&gt;quirks &amp; USB_QUIRK_HONOR_BNUMINTERFACES) &amp;&amp;
 			    n &gt;= nintf_orig) {
-				dev_warn(ddev, "config %d has more interface "
+				dev_notice(ddev, "config %d has more interface "
 				    "descriptors, than it declares in "
 				    "bNumInterfaces, ignoring interface "
 				    "number: %d\n", cfgno, inum);
@@ -688,7 +688,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 			}
 
 			if (inum &gt;= nintf_orig)
-				dev_warn(ddev, "config %d has an invalid "
+				dev_notice(ddev, "config %d has an invalid "
 				    "interface number: %d but max is %d\n",
 				    cfgno, inum, nintf_orig - 1);
 
@@ -713,14 +713,14 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			d = (struct usb_interface_assoc_descriptor *)header;
 			if (d-&gt;bLength &lt; USB_DT_INTERFACE_ASSOCIATION_SIZE) {
-				dev_warn(ddev,
+				dev_notice(ddev,
 					 "config %d has an invalid interface association descriptor of length %d, skipping\n",
 					 cfgno, d-&gt;bLength);
 				continue;
 			}
 
 			if (iad_num == USB_MAXIADS) {
-				dev_warn(ddev, "found more Interface "
+				dev_notice(ddev, "found more Interface "
 					       "Association Descriptors "
 					       "than allocated for in "
 					       "configuration %d\n", cfgno);
@@ -731,7 +731,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 		} else if (header-&gt;bDescriptorType == USB_DT_DEVICE ||
 			    header-&gt;bDescriptorType == USB_DT_CONFIG)
-			dev_warn(ddev, "config %d contains an unexpected "
+			dev_notice(ddev, "config %d contains an unexpected "
 			    "descriptor of type 0x%X, skipping\n",
 			    cfgno, header-&gt;bDescriptorType);
 
@@ -740,11 +740,11 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	config-&gt;desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);
 
 	if (n != nintf)
-		dev_warn(ddev, "config %d has %d interface%s, different from "
+		dev_notice(ddev, "config %d has %d interface%s, different from "
 		    "the descriptor's value: %d\n",
 		    cfgno, n, plural(n), nintf_orig);
 	else if (n == 0)
-		dev_warn(ddev, "config %d has no interfaces?\n", cfgno);
+		dev_notice(ddev, "config %d has no interfaces?\n", cfgno);
 	config-&gt;desc.bNumInterfaces = nintf = n;
 
 	/* Check for missing interface numbers */
@@ -754,7 +754,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 				break;
 		}
 		if (j &gt;= nintf)
-			dev_warn(ddev, "config %d has no interface number "
+			dev_notice(ddev, "config %d has no interface number "
 			    "%d\n", cfgno, i);
 	}
 
@@ -762,7 +762,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	for (i = 0; i &lt; nintf; ++i) {
 		j = nalts[i];
 		if (j &gt; USB_MAXALTSETTING) {
-			dev_warn(ddev, "too many alternate settings for "
+			dev_notice(ddev, "too many alternate settings for "
 			    "config %d interface %d: %d, "
 			    "using maximum allowed: %d\n",
 			    cfgno, inums[i], j, USB_MAXALTSETTING);
@@ -811,7 +811,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 					break;
 			}
 			if (n &gt;= intfc-&gt;num_altsetting)
-				dev_warn(ddev, "config %d interface %d has no "
+				dev_notice(ddev, "config %d interface %d has no "
 				    "altsetting %d\n", cfgno, inums[i], j);
 		}
 	}
@@ -868,7 +868,7 @@ int usb_get_configuration(struct usb_device *dev)
 	int result;
 
 	if (ncfg &gt; USB_MAXCONFIG) {
-		dev_warn(ddev, "too many configurations: %d, "
+		dev_notice(ddev, "too many configurations: %d, "
 		    "using maximum allowed: %d\n", ncfg, USB_MAXCONFIG);
 		dev-&gt;descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;
 	}
@@ -902,7 +902,7 @@ int usb_get_configuration(struct usb_device *dev)
 			    "descriptor/%s: %d\n", cfgno, "start", result);
 			if (result != -EPIPE)
 				goto err;
-			dev_err(ddev, "chopping to %d config(s)\n", cfgno);
+			dev_notice(ddev, "chopping to %d config(s)\n", cfgno);
 			dev-&gt;descriptor.bNumConfigurations = cfgno;
 			break;
 		} else if (result &lt; 4) {
@@ -934,7 +934,7 @@ int usb_get_configuration(struct usb_device *dev)
 			goto err;
 		}
 		if (result &lt; length) {
-			dev_warn(ddev, "config index %d descriptor too short "
+			dev_notice(ddev, "config index %d descriptor too short "
 			    "(expected %i, got %i)\n", cfgno, length, result);
 			length = result;
 		}
@@ -993,7 +993,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	/* Get BOS descriptor */
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
 	if (ret &lt; USB_DT_BOS_SIZE || bos-&gt;bLength &lt; USB_DT_BOS_SIZE) {
-		dev_err(ddev, "unable to get BOS descriptor or descriptor too short\n");
+		dev_notice(ddev, "unable to get BOS descriptor or descriptor too short\n");
 		if (ret &gt;= 0)
 			ret = -ENOMSG;
 		kfree(bos);
@@ -1021,7 +1021,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);
 	if (ret &lt; total_len) {
-		dev_err(ddev, "unable to get BOS descriptor set\n");
+		dev_notice(ddev, "unable to get BOS descriptor set\n");
 		if (ret &gt;= 0)
 			ret = -ENOMSG;
 		goto err;
@@ -1046,7 +1046,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 		}
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
-			dev_warn(ddev, "descriptor type invalid, skip\n");
+			dev_notice(ddev, "descriptor type invalid, skip\n");
 			continue;
 		}
 </pre><hr><pre>commit 41fd1cb6151439b205ac7611883d85ae14250172
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 21:31:40 2022 +0200

    media: mceusb: Use new usb_control_msg_*() routines
    
    Automatic kernel fuzzing led to a WARN about invalid pipe direction in
    the mceusb driver:
    
    ------------[ cut here ]------------
    usb 6-1: BOGUS control dir, pipe 80000380 doesn't match bRequestType 40
    WARNING: CPU: 0 PID: 2465 at drivers/usb/core/urb.c:410
    usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Modules linked in:
    CPU: 0 PID: 2465 Comm: kworker/0:2 Not tainted 5.19.0-rc4-00208-g69cb6c6556ad #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Code: 7c 24 40 e8 ac 23 91 fd 48 8b 7c 24 40 e8 b2 70 1b ff 45 89 e8
    44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 a0 30 a9 86 e8 48 07 11 02 &lt;0f&gt; 0b
    e9 1c f0 ff ff e8 7e 23 91 fd 0f b6 1d 63 22 83 05 31 ff 41
    RSP: 0018:ffffc900032becf0 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881100f3058 RCX: 0000000000000000
    RDX: ffffc90004961000 RSI: ffff888114c6d580 RDI: fffff52000657d90
    RBP: ffff888105ad90f0 R08: ffffffff812c3638 R09: 0000000000000000
    R10: 0000000000000005 R11: ffffed1023504ef1 R12: ffff888105ad9000
    R13: 0000000000000040 R14: 0000000080000380 R15: ffff88810ba96500
    FS: 0000000000000000(0000) GS:ffff88811a800000(0000) knlGS:0000000000000000
    CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ffe810bda58 CR3: 000000010b720000 CR4: 0000000000350ef0
    Call Trace:
    &lt;TASK&gt;
    usb_start_wait_urb+0x101/0x4c0 drivers/usb/core/message.c:58
    usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
    usb_control_msg+0x31c/0x4a0 drivers/usb/core/message.c:153
    mceusb_gen1_init drivers/media/rc/mceusb.c:1431 [inline]
    mceusb_dev_probe+0x258e/0x33f0 drivers/media/rc/mceusb.c:1807
    
    The reason for the warning is clear enough; the driver sends an
    unusual read request on endpoint 0 but does not set the USB_DIR_IN bit
    in the bRequestType field.
    
    More importantly, the whole situation can be avoided and the driver
    simplified by converting it over to the relatively new
    usb_control_msg_recv() and usb_control_msg_send() routines.  That's
    what this fix does.
    
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Link: https://lore.kernel.org/all/CAB7eexLLApHJwZfMQ=X-PtRhw0BgO+5KcSMS05FNUYejJXqtSA@mail.gmail.com/
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: Sean Young &lt;sean@mess.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index 0834d5f866fd..39d2b03e2631 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -1416,42 +1416,37 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 {
 	int ret;
 	struct device *dev = ir-&gt;dev;
-	char *data;
-
-	data = kzalloc(USB_CTRL_MSG_SZ, GFP_KERNEL);
-	if (!data) {
-		dev_err(dev, "%s: memory allocation failed!", __func__);
-		return;
-	}
+	char data[USB_CTRL_MSG_SZ];
 
 	/*
 	 * This is a strange one. Windows issues a set address to the device
 	 * on the receive control pipe and expect a certain value pair back
 	 */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_rcvctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_ADDRESS, USB_TYPE_VENDOR, 0, 0,
-			      data, USB_CTRL_MSG_SZ, 3000);
+	ret = usb_control_msg_recv(ir-&gt;usbdev, 0, USB_REQ_SET_ADDRESS,
+				   USB_DIR_IN | USB_TYPE_VENDOR,
+				   0, 0, data, USB_CTRL_MSG_SZ, 3000,
+				   GFP_KERNEL);
 	dev_dbg(dev, "set address - ret = %d", ret);
 	dev_dbg(dev, "set address - data[0] = %d, data[1] = %d",
 						data[0], data[1]);
 
 	/* set feature: bit rate 38400 bps */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			      0xc04e, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+				   0xc04e, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 
 	dev_dbg(dev, "set feature - ret = %d", ret);
 
 	/* bRequest 4: set char length to 8 bits */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      4, USB_TYPE_VENDOR,
-			      0x0808, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   4, USB_TYPE_VENDOR,
+				   0x0808, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set char length - retB = %d", ret);
 
 	/* bRequest 2: set handshaking to use DTR/DSR */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      2, USB_TYPE_VENDOR,
-			      0x0000, 0x0100, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   2, USB_TYPE_VENDOR,
+				   0x0000, 0x0100, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set handshake  - retC = %d", ret);
 
 	/* device resume */
@@ -1459,8 +1454,6 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 
 	/* get hw/sw revision? */
 	mce_command_out(ir, GET_REVISION, sizeof(GET_REVISION));
-
-	kfree(data);
 }
 
 static void mceusb_gen2_init(struct mceusb_dev *ir)</pre><hr><pre>commit 766a96dc558385be735a370db867e302c8f22153
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 1 10:36:34 2022 -0400

    USB: core: Fix RST error in hub.c
    
    A recent commit added an invalid RST expression to a kerneldoc comment
    in hub.c.  The fix is trivial.
    
    Fixes: 9c6d778800b9 ("USB: core: Prevent nested device-reset calls")
    Cc: &lt;stable@vger.kernel.org&gt;
    Reported-by: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Reviewed-by: Bagas Sanjaya &lt;bagasdotme@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YxDDcsLtRZ7c20pq@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d4b1e70d1498..bbab424b0d55 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -6039,7 +6039,7 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  *
  * Return: The same as for usb_reset_and_verify_device().
  * However, if a reset is already in progress (for instance, if a
- * driver doesn't have pre_ or post_reset() callbacks, and while
+ * driver doesn't have pre_reset() or post_reset() callbacks, and while
  * being unbound or re-bound during the ongoing reset its disconnect()
  * or probe() routine tries to perform a second, nested reset), the
  * routine returns -EINPROGRESS.</pre><hr><pre>commit 608e58a0f4617977178131f5f68a3fce1d3f5316
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:40 2022 -0400

    media: mceusb: Use new usb_control_msg_*() routines
    
    Automatic kernel fuzzing led to a WARN about invalid pipe direction in
    the mceusb driver:
    
    ------------[ cut here ]------------
    usb 6-1: BOGUS control dir, pipe 80000380 doesn't match bRequestType 40
    WARNING: CPU: 0 PID: 2465 at drivers/usb/core/urb.c:410
    usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Modules linked in:
    CPU: 0 PID: 2465 Comm: kworker/0:2 Not tainted 5.19.0-rc4-00208-g69cb6c6556ad #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Code: 7c 24 40 e8 ac 23 91 fd 48 8b 7c 24 40 e8 b2 70 1b ff 45 89 e8
    44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 a0 30 a9 86 e8 48 07 11 02 &lt;0f&gt; 0b
    e9 1c f0 ff ff e8 7e 23 91 fd 0f b6 1d 63 22 83 05 31 ff 41
    RSP: 0018:ffffc900032becf0 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881100f3058 RCX: 0000000000000000
    RDX: ffffc90004961000 RSI: ffff888114c6d580 RDI: fffff52000657d90
    RBP: ffff888105ad90f0 R08: ffffffff812c3638 R09: 0000000000000000
    R10: 0000000000000005 R11: ffffed1023504ef1 R12: ffff888105ad9000
    R13: 0000000000000040 R14: 0000000080000380 R15: ffff88810ba96500
    FS: 0000000000000000(0000) GS:ffff88811a800000(0000) knlGS:0000000000000000
    CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ffe810bda58 CR3: 000000010b720000 CR4: 0000000000350ef0
    Call Trace:
    &lt;TASK&gt;
    usb_start_wait_urb+0x101/0x4c0 drivers/usb/core/message.c:58
    usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
    usb_control_msg+0x31c/0x4a0 drivers/usb/core/message.c:153
    mceusb_gen1_init drivers/media/rc/mceusb.c:1431 [inline]
    mceusb_dev_probe+0x258e/0x33f0 drivers/media/rc/mceusb.c:1807
    
    The reason for the warning is clear enough; the driver sends an
    unusual read request on endpoint 0 but does not set the USB_DIR_IN bit
    in the bRequestType field.
    
    More importantly, the whole situation can be avoided and the driver
    simplified by converting it over to the relatively new
    usb_control_msg_recv() and usb_control_msg_send() routines.  That's
    what this fix does.
    
    Link: https://lore.kernel.org/all/CAB7eexLLApHJwZfMQ=X-PtRhw0BgO+5KcSMS05FNUYejJXqtSA@mail.gmail.com/
    Cc: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkfnBFCSEVC6XZu@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index 0834d5f866fd..39d2b03e2631 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -1416,42 +1416,37 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 {
 	int ret;
 	struct device *dev = ir-&gt;dev;
-	char *data;
-
-	data = kzalloc(USB_CTRL_MSG_SZ, GFP_KERNEL);
-	if (!data) {
-		dev_err(dev, "%s: memory allocation failed!", __func__);
-		return;
-	}
+	char data[USB_CTRL_MSG_SZ];
 
 	/*
 	 * This is a strange one. Windows issues a set address to the device
 	 * on the receive control pipe and expect a certain value pair back
 	 */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_rcvctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_ADDRESS, USB_TYPE_VENDOR, 0, 0,
-			      data, USB_CTRL_MSG_SZ, 3000);
+	ret = usb_control_msg_recv(ir-&gt;usbdev, 0, USB_REQ_SET_ADDRESS,
+				   USB_DIR_IN | USB_TYPE_VENDOR,
+				   0, 0, data, USB_CTRL_MSG_SZ, 3000,
+				   GFP_KERNEL);
 	dev_dbg(dev, "set address - ret = %d", ret);
 	dev_dbg(dev, "set address - data[0] = %d, data[1] = %d",
 						data[0], data[1]);
 
 	/* set feature: bit rate 38400 bps */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			      0xc04e, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+				   0xc04e, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 
 	dev_dbg(dev, "set feature - ret = %d", ret);
 
 	/* bRequest 4: set char length to 8 bits */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      4, USB_TYPE_VENDOR,
-			      0x0808, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   4, USB_TYPE_VENDOR,
+				   0x0808, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set char length - retB = %d", ret);
 
 	/* bRequest 2: set handshaking to use DTR/DSR */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      2, USB_TYPE_VENDOR,
-			      0x0000, 0x0100, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   2, USB_TYPE_VENDOR,
+				   0x0000, 0x0100, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set handshake  - retC = %d", ret);
 
 	/* device resume */
@@ -1459,8 +1454,6 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 
 	/* get hw/sw revision? */
 	mce_command_out(ir, GET_REVISION, sizeof(GET_REVISION));
-
-	kfree(data);
 }
 
 static void mceusb_gen2_init(struct mceusb_dev *ir)</pre><hr><pre>commit 9c6d778800b921bde3bff3cff5003d1650f942d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:32 2022 -0400

    USB: core: Prevent nested device-reset calls
    
    Automatic kernel fuzzing revealed a recursive locking violation in
    usb-storage:
    
    ============================================
    WARNING: possible recursive locking detected
    5.18.0 #3 Not tainted
    --------------------------------------------
    kworker/1:3/1205 is trying to acquire lock:
    ffff888018638db8 (&amp;us_interface_key[i]){+.+.}-{3:3}, at:
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    
    but task is already holding lock:
    ffff888018638db8 (&amp;us_interface_key[i]){+.+.}-{3:3}, at:
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    
    ...
    
    stack backtrace:
    CPU: 1 PID: 1205 Comm: kworker/1:3 Not tainted 5.18.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    Call Trace:
    &lt;TASK&gt;
    __dump_stack lib/dump_stack.c:88 [inline]
    dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
    print_deadlock_bug kernel/locking/lockdep.c:2988 [inline]
    check_deadlock kernel/locking/lockdep.c:3031 [inline]
    validate_chain kernel/locking/lockdep.c:3816 [inline]
    __lock_acquire.cold+0x152/0x3ca kernel/locking/lockdep.c:5053
    lock_acquire kernel/locking/lockdep.c:5665 [inline]
    lock_acquire+0x1ab/0x520 kernel/locking/lockdep.c:5630
    __mutex_lock_common kernel/locking/mutex.c:603 [inline]
    __mutex_lock+0x14f/0x1610 kernel/locking/mutex.c:747
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    usb_reset_device+0x37d/0x9a0 drivers/usb/core/hub.c:6109
    r871xu_dev_remove+0x21a/0x270 drivers/staging/rtl8712/usb_intf.c:622
    usb_unbind_interface+0x1bd/0x890 drivers/usb/core/driver.c:458
    device_remove drivers/base/dd.c:545 [inline]
    device_remove+0x11f/0x170 drivers/base/dd.c:537
    __device_release_driver drivers/base/dd.c:1222 [inline]
    device_release_driver_internal+0x1a7/0x2f0 drivers/base/dd.c:1248
    usb_driver_release_interface+0x102/0x180 drivers/usb/core/driver.c:627
    usb_forced_unbind_intf+0x4d/0xa0 drivers/usb/core/driver.c:1118
    usb_reset_device+0x39b/0x9a0 drivers/usb/core/hub.c:6114
    
    This turned out not to be an error in usb-storage but rather a nested
    device reset attempt.  That is, as the rtl8712 driver was being
    unbound from a composite device in preparation for an unrelated USB
    reset (that driver does not have pre_reset or post_reset callbacks),
    its -&gt;remove routine called usb_reset_device() -- thus nesting one
    reset call within another.
    
    Performing a reset as part of disconnect processing is a questionable
    practice at best.  However, the bug report points out that the USB
    core does not have any protection against nested resets.  Adding a
    reset_in_progress flag and testing it will prevent such errors in the
    future.
    
    Link: https://lore.kernel.org/all/CAB7eexKUpvX-JNiLzhXBDWgfg2T9e9_0Tw4HQ6keN==voRbP0g@mail.gmail.com/
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkflDxvg0KWqyZK@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2633acde7ac1..d4b1e70d1498 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -6038,6 +6038,11 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  * the reset is over (using their post_reset method).
  *
  * Return: The same as for usb_reset_and_verify_device().
+ * However, if a reset is already in progress (for instance, if a
+ * driver doesn't have pre_ or post_reset() callbacks, and while
+ * being unbound or re-bound during the ongoing reset its disconnect()
+ * or probe() routine tries to perform a second, nested reset), the
+ * routine returns -EINPROGRESS.
  *
  * Note:
  * The caller must own the device lock.  For example, it's safe to use
@@ -6071,6 +6076,10 @@ int usb_reset_device(struct usb_device *udev)
 		return -EISDIR;
 	}
 
+	if (udev-&gt;reset_in_progress)
+		return -EINPROGRESS;
+	udev-&gt;reset_in_progress = 1;
+
 	port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
 
 	/*
@@ -6135,6 +6144,7 @@ int usb_reset_device(struct usb_device *udev)
 
 	usb_autosuspend_device(udev);
 	memalloc_noio_restore(noio_flag);
+	udev-&gt;reset_in_progress = 0;
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_reset_device);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index f7a9914fc97f..9ff1ad4dfad1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -575,6 +575,7 @@ struct usb3_lpm_parameters {
  * @devaddr: device address, XHCI: assigned by HW, others: same as devnum
  * @can_submit: URBs may be submitted
  * @persist_enabled:  USB_PERSIST enabled for this device
+ * @reset_in_progress: the device is being reset
  * @have_langid: whether string_langid is valid
  * @authorized: policy has said we can use it;
  *	(user space) policy determines if we authorize this device to be
@@ -662,6 +663,7 @@ struct usb_device {
 
 	unsigned can_submit:1;
 	unsigned persist_enabled:1;
+	unsigned reset_in_progress:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
 	unsigned authenticated:1;</pre><hr><pre>commit 1016fc0c096c92dd0e6e0541daac7a7868169903
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:17 2022 -0400

    USB: gadget: Fix obscure lockdep violation for udc_mutex
    
    A recent commit expanding the scope of the udc_lock mutex in the
    gadget core managed to cause an obscure and slightly bizarre lockdep
    violation.  In abbreviated form:
    
    ======================================================
    WARNING: possible circular locking dependency detected
    5.19.0-rc7+ #12510 Not tainted
    ------------------------------------------------------
    udevadm/312 is trying to acquire lock:
    ffff80000aae1058 (udc_lock){+.+.}-{3:3}, at: usb_udc_uevent+0x54/0xe0
    
    but task is already holding lock:
    ffff000002277548 (kn-&gt;active#4){++++}-{0:0}, at: kernfs_seq_start+0x34/0xe0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -&gt; #3 (kn-&gt;active#4){++++}-{0:0}:
      lock_acquire+0x68/0x84
      __kernfs_remove+0x268/0x380
      kernfs_remove_by_name_ns+0x58/0xac
      sysfs_remove_file_ns+0x18/0x24
      device_del+0x15c/0x440
    
    -&gt; #2 (device_links_lock){+.+.}-{3:3}:
      lock_acquire+0x68/0x84
      __mutex_lock+0x9c/0x430
      mutex_lock_nested+0x38/0x64
      device_link_remove+0x3c/0xa0
      _regulator_put.part.0+0x168/0x190
      regulator_put+0x3c/0x54
      devm_regulator_release+0x14/0x20
    
    -&gt; #1 (regulator_list_mutex){+.+.}-{3:3}:
      lock_acquire+0x68/0x84
      __mutex_lock+0x9c/0x430
      mutex_lock_nested+0x38/0x64
      regulator_lock_dependent+0x54/0x284
      regulator_enable+0x34/0x80
      phy_power_on+0x24/0x130
      __dwc2_lowlevel_hw_enable+0x100/0x130
      dwc2_lowlevel_hw_enable+0x18/0x40
      dwc2_hsotg_udc_start+0x6c/0x2f0
      gadget_bind_driver+0x124/0x1f4
    
    -&gt; #0 (udc_lock){+.+.}-{3:3}:
      __lock_acquire+0x1298/0x20cc
      lock_acquire.part.0+0xe0/0x230
      lock_acquire+0x68/0x84
      __mutex_lock+0x9c/0x430
      mutex_lock_nested+0x38/0x64
      usb_udc_uevent+0x54/0xe0
    
    Evidently this was caused by the scope of udc_mutex being too large.
    The mutex is only meant to protect udc-&gt;driver along with a few other
    things.  As far as I can tell, there's no reason for the mutex to be
    held while the gadget core calls a gadget driver's -&gt;bind or -&gt;unbind
    routine, or while a UDC is being started or stopped.  (This accounts
    for link #1 in the chain above, where the mutex is held while the
    dwc2_hsotg_udc is started as part of driver probing.)
    
    Gadget drivers' -&gt;disconnect callbacks are problematic.  Even though
    usb_gadget_disconnect() will now acquire the udc_mutex, there's a
    window in usb_gadget_bind_driver() between the times when the mutex is
    released and the -&gt;bind callback is invoked.  If a disconnect occurred
    during that window, we could call the driver's -&gt;disconnect routine
    before its -&gt;bind routine.  To prevent this from happening, it will be
    necessary to prevent a UDC from connecting while it has no gadget
    driver.  This should be done already but it doesn't seem to be;
    currently usb_gadget_connect() has no check for this.  Such a check
    will have to be added later.
    
    Some degree of mutual exclusion is required in soft_connect_store(),
    which can dereference udc-&gt;driver at arbitrary times since it is a
    sysfs callback.  The solution here is to acquire the gadget's device
    lock rather than the udc_mutex.  Since the driver core guarantees that
    the device lock is always held during driver binding and unbinding,
    this will make the accesses in soft_connect_store() mutually exclusive
    with any changes to udc-&gt;driver.
    
    Lastly, it turns out there is one place which should hold the
    udc_mutex but currently does not: The function_show() routine needs
    protection while it dereferences udc-&gt;driver.  The missing lock and
    unlock calls are added.
    
    Link: https://lore.kernel.org/all/b2ba4245-9917-e399-94c8-03a383e7070e@samsung.com/
    Fixes: 2191c00855b0 ("USB: gadget: Fix use-after-free Read in usb_udc_uevent()")
    Cc: Felipe Balbi &lt;balbi@kernel.org&gt;
    Cc: stable@vger.kernel.org
    Reported-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;
    Tested-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkfhdxA/I2nOcK7@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index cafcf260394c..c63c0c2cf649 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -736,7 +736,10 @@ int usb_gadget_disconnect(struct usb_gadget *gadget)
 	ret = gadget-&gt;ops-&gt;pullup(gadget, 0);
 	if (!ret) {
 		gadget-&gt;connected = 0;
-		gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);
+		mutex_lock(&amp;udc_lock);
+		if (gadget-&gt;udc-&gt;driver)
+			gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);
+		mutex_unlock(&amp;udc_lock);
 	}
 
 out:
@@ -1489,7 +1492,6 @@ static int gadget_bind_driver(struct device *dev)
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
 
-	mutex_lock(&amp;udc_lock);
 	ret = driver-&gt;bind(udc-&gt;gadget, driver);
 	if (ret)
 		goto err_bind;
@@ -1499,7 +1501,6 @@ static int gadget_bind_driver(struct device *dev)
 		goto err_start;
 	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
-	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 	return 0;
@@ -1512,6 +1513,7 @@ static int gadget_bind_driver(struct device *dev)
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
 			driver-&gt;function, ret);
 
+	mutex_lock(&amp;udc_lock);
 	udc-&gt;driver = NULL;
 	driver-&gt;is_bound = false;
 	mutex_unlock(&amp;udc_lock);
@@ -1529,7 +1531,6 @@ static void gadget_unbind_driver(struct device *dev)
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 
-	mutex_lock(&amp;udc_lock);
 	usb_gadget_disconnect(gadget);
 	usb_gadget_disable_async_callbacks(udc);
 	if (gadget-&gt;irq)
@@ -1537,6 +1538,7 @@ static void gadget_unbind_driver(struct device *dev)
 	udc-&gt;driver-&gt;unbind(gadget);
 	usb_gadget_udc_stop(udc);
 
+	mutex_lock(&amp;udc_lock);
 	driver-&gt;is_bound = false;
 	udc-&gt;driver = NULL;
 	mutex_unlock(&amp;udc_lock);
@@ -1612,7 +1614,7 @@ static ssize_t soft_connect_store(struct device *dev,
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
 	ssize_t			ret;
 
-	mutex_lock(&amp;udc_lock);
+	device_lock(&amp;udc-&gt;gadget-&gt;dev);
 	if (!udc-&gt;driver) {
 		dev_err(dev, "soft-connect without a gadget driver\n");
 		ret = -EOPNOTSUPP;
@@ -1633,7 +1635,7 @@ static ssize_t soft_connect_store(struct device *dev,
 
 	ret = n;
 out:
-	mutex_unlock(&amp;udc_lock);
+	device_unlock(&amp;udc-&gt;gadget-&gt;dev);
 	return ret;
 }
 static DEVICE_ATTR_WO(soft_connect);
@@ -1652,11 +1654,15 @@ static ssize_t function_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
-	struct usb_gadget_driver *drv = udc-&gt;driver;
+	struct usb_gadget_driver *drv;
+	int			rc = 0;
 
-	if (!drv || !drv-&gt;function)
-		return 0;
-	return scnprintf(buf, PAGE_SIZE, "%s\n", drv-&gt;function);
+	mutex_lock(&amp;udc_lock);
+	drv = udc-&gt;driver;
+	if (drv &amp;&amp; drv-&gt;function)
+		rc = scnprintf(buf, PAGE_SIZE, "%s\n", drv-&gt;function);
+	mutex_unlock(&amp;udc_lock);
+	return rc;
 }
 static DEVICE_ATTR_RO(function);
 </pre>
    <div class="pagination">
        <a href='2_3.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><span>[4]</span><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_5.html'>Next&gt;&gt;</a>
    <div>
</body>
