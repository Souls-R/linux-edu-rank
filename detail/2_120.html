<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_119.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><span>[120]</span><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_121.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 01d883d44a1ca8dc77486635d428cba63e7fdadf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:18 2006 -0400

    usbcore: non-hub-specific uses of autosuspend
    
    This patch (as741) makes the non-hub parts of usbcore actually use the
    autosuspend facilities added by an earlier patch.
    
            Devices opened through usbfs are autoresumed and then
            autosuspended upon close.
    
            Likewise for usb-skeleton.
    
            Devices are autoresumed for usb_set_configuration.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 43c08724a2d8..fd345ad810f8 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -558,10 +558,12 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		dev = usbdev_lookup_minor(iminor(inode));
 	if (!dev)
 		dev = inode-&gt;i_private;
-	if (!dev) {
-		kfree(ps);
+	if (!dev)
 		goto out;
-	}
+	ret = usb_autoresume_device(dev, 1);
+	if (ret)
+		goto out;
+
 	usb_get_dev(dev);
 	ret = 0;
 	ps-&gt;dev = dev;
@@ -581,6 +583,8 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
  out:
+	if (ret)
+		kfree(ps);
 	mutex_unlock(&amp;usbfs_mutex);
 	return ret;
 }
@@ -604,6 +608,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
+	usb_autosuspend_device(dev, 1);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	kfree(ps);
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 5358e656477c..16332cc57946 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -172,14 +172,10 @@ static void generic_disconnect(struct usb_device *udev)
 
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
-	if (udev-&gt;state == USB_STATE_CONFIGURED)
+	if (udev-&gt;actconfig)
 		usb_set_configuration(udev, 0);
 
 	usb_remove_sysfs_dev_files(udev);
-
-	/* in case the call failed or the device was suspended */
-	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
-		usb_disable_device(udev, 0);
 }
 
 #ifdef	CONFIG_PM
@@ -208,4 +204,5 @@ struct usb_device_driver usb_generic_driver = {
 	.suspend = generic_suspend,
 	.resume = generic_resume,
 #endif
+	.supports_autosuspend = 1,
 };
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 1580c81a0db7..28c6cf225780 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1366,9 +1366,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (cp &amp;&amp; configuration == 0)
 		dev_warn(&amp;dev-&gt;dev, "config 0 descriptor??\n");
 
-	if (dev-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	/* Allocate memory for new interfaces before doing anything else,
 	 * so that if we run out then nothing will have changed. */
 	n = nintf = 0;
@@ -1403,6 +1400,11 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					configuration, -i);
 	}
 
+	/* Wake up the device so we can send it the Set-Config request */
+	ret = usb_autoresume_device(dev, 1);
+	if (ret)
+		goto free_interfaces;
+
 	/* if it's already configured, clear out old state first.
 	 * getting rid of old interfaces means unbinding their drivers.
 	 */
@@ -1422,6 +1424,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	dev-&gt;actconfig = cp;
 	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
+		usb_autosuspend_device(dev, 1);
 		goto free_interfaces;
 	}
 	usb_set_device_state(dev, USB_STATE_CONFIGURED);
@@ -1490,6 +1493,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		usb_create_sysfs_intf_files (intf);
 	}
 
+	usb_autosuspend_device(dev, 1);
 	return 0;
 }
 
diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index 9b542a6ba978..1b51d3187a95 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -90,6 +90,11 @@ static int skel_open(struct inode *inode, struct file *file)
 		goto exit;
 	}
 
+	/* prevent the device from being autosuspended */
+	retval = usb_autopm_get_interface(interface);
+	if (retval)
+		goto exit;
+
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
 
@@ -108,6 +113,12 @@ static int skel_release(struct inode *inode, struct file *file)
 	if (dev == NULL)
 		return -ENODEV;
 
+	/* allow the device to be autosuspended */
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (dev-&gt;interface)
+		usb_autopm_put_interface(dev-&gt;interface);
+	mutex_unlock(&amp;dev-&gt;io_mutex);
+
 	/* decrement the count on our device */
 	kref_put(&amp;dev-&gt;kref, skel_delete);
 	return 0;</pre><hr><pre>commit 645daaab0b6adc35c1838df2a82f9d729fdb1767
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:02 2006 -0400

    usbcore: add autosuspend/autoresume infrastructure
    
    This patch (as739) adds the basic infrastructure for USB autosuspend
    and autoresume.  The main features are:
    
            PM usage counters added to struct usb_device and struct
            usb_interface, indicating whether it's okay to autosuspend
            them or they are currently in use.
    
            Flag added to usb_device indicating whether the current
            suspend/resume operation originated from outside or as an
            autosuspend/autoresume.
    
            Flag added to usb_driver indicating whether the driver
            supports autosuspend.  If not, no device bound to the driver
            will be autosuspended.
    
            Mutex added to usb_device for protecting PM operations.
            Unlike the device semaphore, the locking rule for the pm_mutex
            is that you must acquire the locks going _up_ the device tree.
    
            New routines handling autosuspend/autoresume requests for
            interfaces and devices.
    
            Suspend and resume requests are propagated up the device tree
            (but not outside the USB subsystem).
    
            work_struct added to usb_device, for carrying out delayed
            autosuspend requests.
    
            Autoresume added (and autosuspend prevented) during probe and
            disconnect.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a5d11461f5a9..2b2000ac05ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -157,12 +157,13 @@ static int usb_probe_device(struct device *dev)
 
 	udev = to_usb_device(dev);
 
-	/* FIXME: resume a suspended device */
-	if (udev-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	/* TODO: Add real matching code */
 
+	/* The device should always appear to be in use
+	 * unless the driver suports autosuspend.
+	 */
+	udev-&gt;pm_usage_cnt = !(udriver-&gt;supports_autosuspend);
+
 	error = udriver-&gt;probe(udev);
 	return error;
 }
@@ -182,6 +183,7 @@ static int usb_probe_interface(struct device *dev)
 {
 	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf;
+	struct usb_device *udev;
 	const struct usb_device_id *id;
 	int error = -ENODEV;
 
@@ -191,10 +193,7 @@ static int usb_probe_interface(struct device *dev)
 		return error;
 
 	intf = to_usb_interface(dev);
-
-	/* FIXME we'd much prefer to just resume it ... */
-	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
+	udev = interface_to_usbdev(intf);
 
 	id = usb_match_id(intf, driver-&gt;id_table);
 	if (!id)
@@ -202,18 +201,31 @@ static int usb_probe_interface(struct device *dev)
 	if (id) {
 		dev_dbg(dev, "%s - got id\n", __FUNCTION__);
 
+		error = usb_autoresume_device(udev, 1);
+		if (error)
+			return error;
+
 		/* Interface "power state" doesn't correspond to any hardware
 		 * state whatsoever.  We use it to record when it's bound to
 		 * a driver that may start I/0:  it's not frozen/quiesced.
 		 */
 		mark_active(intf);
 		intf-&gt;condition = USB_INTERFACE_BINDING;
+
+		/* The interface should always appear to be in use
+		 * unless the driver suports autosuspend.
+		 */
+		intf-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+
 		error = driver-&gt;probe(intf, id);
 		if (error) {
 			mark_quiesced(intf);
+			intf-&gt;needs_remote_wakeup = 0;
 			intf-&gt;condition = USB_INTERFACE_UNBOUND;
 		} else
 			intf-&gt;condition = USB_INTERFACE_BOUND;
+
+		usb_autosuspend_device(udev, 1);
 	}
 
 	return error;
@@ -224,9 +236,15 @@ static int usb_unbind_interface(struct device *dev)
 {
 	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf = to_usb_interface(dev);
+	struct usb_device *udev;
+	int error;
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
+	/* Autoresume for set_interface call below */
+	udev = interface_to_usbdev(intf);
+	error = usb_autoresume_device(udev, 1);
+
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
 
@@ -237,8 +255,13 @@ static int usb_unbind_interface(struct device *dev)
 			intf-&gt;altsetting[0].desc.bInterfaceNumber,
 			0);
 	usb_set_intfdata(intf, NULL);
+
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(intf);
+	intf-&gt;needs_remote_wakeup = 0;
+
+	if (!error)
+		usb_autosuspend_device(udev, 1);
 
 	return 0;
 }
@@ -267,14 +290,19 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 				struct usb_interface *iface, void* priv)
 {
 	struct device *dev = &amp;iface-&gt;dev;
+	struct usb_device *udev = interface_to_usbdev(iface);
 
 	if (dev-&gt;driver)
 		return -EBUSY;
 
 	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
+	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -304,6 +332,7 @@ void usb_driver_release_interface(struct usb_driver *driver,
 					struct usb_interface *iface)
 {
 	struct device *dev = &amp;iface-&gt;dev;
+	struct usb_device *udev = interface_to_usbdev(iface);
 
 	/* this should never happen, don't release something that's not ours */
 	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;drvwrap.driver)
@@ -321,8 +350,12 @@ void usb_driver_release_interface(struct usb_driver *driver,
 
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	iface-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(iface);
+	iface-&gt;needs_remote_wakeup = 0;
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 }
 EXPORT_SYMBOL(usb_driver_release_interface);
 
@@ -751,7 +784,7 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-/* Caller has locked udev */
+/* Caller has locked udev-&gt;pm_mutex */
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -763,6 +796,7 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 
 	/* For devices that don't have a driver, we do a standard suspend. */
 	if (udev-&gt;dev.driver == NULL) {
+		udev-&gt;do_remote_wakeup = 0;
 		status = usb_port_suspend(udev);
 		goto done;
 	}
@@ -771,12 +805,13 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver-&gt;suspend(udev, msg);
 
 done:
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
-/* Caller has locked udev */
+/* Caller has locked udev-&gt;pm_mutex */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
@@ -796,12 +831,13 @@ static int resume_device(struct usb_device *udev)
 	status = udriver-&gt;resume(udev);
 
 done:
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	return status;
 }
 
-/* Caller has locked intf's usb_device */
+/* Caller has locked intf's usb_device's pm_mutex */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -812,31 +848,33 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 			!is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)		/* This can't happen */
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)	/* This can't happen */
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
-		if (status)
+		if (status == 0)
+			mark_quiesced(intf);
+		else if (!interface_to_usbdev(intf)-&gt;auto_pm)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
-		else
-			mark_quiesced(intf);
 	} else {
 		// FIXME else if there's no suspend method, disconnect...
+		// Not possible if auto_pm is set...
 		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
 				driver-&gt;name);
 		mark_quiesced(intf);
 	}
 
 done:
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		intf-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
-/* Caller has locked intf's usb_device */
+/* Caller has locked intf's usb_device's pm_mutex */
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
@@ -846,8 +884,12 @@ static int resume_interface(struct usb_interface *intf)
 			is_active(intf))
 		goto done;
 
+	/* Don't let autoresume interfere with unbinding */
+	if (intf-&gt;condition == USB_INTERFACE_UNBINDING)
+		goto done;
+
 	/* Can't resume it if it doesn't have a driver. */
-	if (intf-&gt;dev.driver == NULL) {
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
 		status = -ENOTCONN;
 		goto done;
 	}
@@ -867,18 +909,88 @@ static int resume_interface(struct usb_interface *intf)
 	}
 
 done:
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	return status;
 }
 
-/* Caller has locked udev */
+/**
+ * usb_suspend_both - suspend a USB device and its interfaces
+ * @udev: the usb_device to suspend
+ * @msg: Power Management message describing this state transition
+ *
+ * This is the central routine for suspending USB devices.  It calls the
+ * suspend methods for all the interface drivers in @udev and then calls
+ * the suspend method for @udev itself.  If an error occurs at any stage,
+ * all the interfaces which were suspended are resumed so that they remain
+ * in the same state as the device.
+ *
+ * If an autosuspend is in progress (@udev-&gt;auto_pm is set), the routine
+ * checks first to make sure that neither the device itself or any of its
+ * active interfaces is in use (pm_usage_cnt is greater than 0).  If they
+ * are, the autosuspend fails.
+ *
+ * If the suspend succeeds, the routine recursively queues an autosuspend
+ * request for @udev's parent device, thereby propagating the change up
+ * the device tree.  If all of the parent's children are now suspended,
+ * the parent will autosuspend in turn.
+ *
+ * The suspend method calls are subject to mutual exclusion under control
+ * of @udev's pm_mutex.  Many of these calls are also under the protection
+ * of @udev's device lock (including all requests originating outside the
+ * USB subsystem), but autosuspend requests generated by a child device or
+ * interface driver may not be.  Usbcore will insure that the method calls
+ * do not arrive during bind, unbind, or reset operations.  However, drivers
+ * must be prepared to handle suspend calls arriving at unpredictable times.
+ * The only way to block such calls is to do an autoresume (preventing
+ * autosuspends) while holding @udev's device lock (preventing outside
+ * suspends).
+ *
+ * The caller must hold @udev-&gt;pm_mutex.
+ *
+ * This routine can run only in process context.
+ */
 int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 {
 	int			status = 0;
 	int			i = 0;
 	struct usb_interface	*intf;
+	struct usb_device	*parent = udev-&gt;parent;
+
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		return 0;
 
+	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+
+	/* For autosuspend, fail fast if anything is in use.
+	 * Also fail if any interfaces require remote wakeup but it
+	 * isn't available. */
+	if (udev-&gt;auto_pm) {
+		if (udev-&gt;pm_usage_cnt &gt; 0)
+			return -EBUSY;
+		if (udev-&gt;actconfig) {
+			for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+				intf = udev-&gt;actconfig-&gt;interface[i];
+				if (!is_active(intf))
+					continue;
+				if (intf-&gt;pm_usage_cnt &gt; 0)
+					return -EBUSY;
+				if (intf-&gt;needs_remote_wakeup &amp;&amp;
+						!udev-&gt;do_remote_wakeup) {
+					dev_dbg(&amp;udev-&gt;dev,
+	"remote wakeup needed for autosuspend\n");
+					return -EOPNOTSUPP;
+				}
+			}
+			i = 0;
+		}
+	}
+
+	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
 		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -896,40 +1008,282 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			resume_interface(intf);
 		}
-	}
+
+	/* If the suspend succeeded, propagate it up the tree */
+	} else if (parent)
+		usb_autosuspend_device(parent, 0);
+
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
-/* Caller has locked udev */
+/**
+ * usb_resume_both - resume a USB device and its interfaces
+ * @udev: the usb_device to resume
+ *
+ * This is the central routine for resuming USB devices.  It calls the
+ * the resume method for @udev and then calls the resume methods for all
+ * the interface drivers in @udev.
+ *
+ * Before starting the resume, the routine calls itself recursively for
+ * the parent device of @udev, thereby propagating the change up the device
+ * tree and assuring that @udev will be able to resume.  If the parent is
+ * unable to resume successfully, the routine fails.
+ *
+ * The resume method calls are subject to mutual exclusion under control
+ * of @udev's pm_mutex.  Many of these calls are also under the protection
+ * of @udev's device lock (including all requests originating outside the
+ * USB subsystem), but autoresume requests generated by a child device or
+ * interface driver may not be.  Usbcore will insure that the method calls
+ * do not arrive during bind, unbind, or reset operations.  However, drivers
+ * must be prepared to handle resume calls arriving at unpredictable times.
+ * The only way to block such calls is to do an autoresume (preventing
+ * other autoresumes) while holding @udev's device lock (preventing outside
+ * resumes).
+ *
+ * The caller must hold @udev-&gt;pm_mutex.
+ *
+ * This routine can run only in process context.
+ */
 int usb_resume_both(struct usb_device *udev)
 {
-	int			status;
+	int			status = 0;
 	int			i;
 	struct usb_interface	*intf;
+	struct usb_device	*parent = udev-&gt;parent;
+
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
 
-	/* Can't resume if the parent is suspended */
-	if (udev-&gt;parent &amp;&amp; udev-&gt;parent-&gt;state == USB_STATE_SUSPENDED) {
-		dev_warn(&amp;udev-&gt;dev, "can't resume; parent is suspended\n");
-		return -EHOSTUNREACH;
+	/* Propagate the resume up the tree, if necessary */
+	if (udev-&gt;state == USB_STATE_SUSPENDED) {
+		if (parent) {
+			mutex_lock_nested(&amp;parent-&gt;pm_mutex, parent-&gt;level);
+			parent-&gt;auto_pm = 1;
+			status = usb_resume_both(parent);
+		} else {
+
+			/* We can't progagate beyond the USB subsystem,
+			 * so if a root hub's controller is suspended
+			 * then we're stuck. */
+			if (udev-&gt;dev.parent-&gt;power.power_state.event !=
+					PM_EVENT_ON)
+				status = -EHOSTUNREACH;
+		}
+		if (status == 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
+			status = resume_device(udev);
+		if (parent)
+			mutex_unlock(&amp;parent-&gt;pm_mutex);
 	}
 
-	status = resume_device(udev);
+	/* Now the parent won't suspend until we are finished */
+
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			resume_interface(intf);
 		}
 	}
+
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	return status;
+}
+
+#ifdef CONFIG_USB_SUSPEND
+
+/**
+ * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
+ * @udev - the usb_device to autosuspend
+ * @dec_usage_cnt - flag to decrement @udev's PM-usage counter
+ *
+ * This routine should be called when a core subsystem is finished using
+ * @udev and wants to allow it to autosuspend.  Examples would be when
+ * @udev's device file in usbfs is closed or after a configuration change.
+ *
+ * @dec_usage_cnt should be 1 if the subsystem previously incremented
+ * @udev's usage counter (such as by passing 1 to usb_autoresume_device);
+ * otherwise it should be 0.
+ *
+ * If the usage counter for @udev or any of its active interfaces is greater
+ * than 0, the autosuspend request will not be queued.  (If an interface
+ * driver does not support autosuspend then its usage counter is permanently
+ * positive.)  Likewise, if an interface driver requires remote-wakeup
+ * capability during autosuspend but remote wakeup is disabled, the
+ * autosuspend will fail.
+ *
+ * Often the caller will hold @udev's device lock, but this is not
+ * necessary.
+ *
+ * This routine can run only in process context.
+ */
+void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
+{
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
+	if (udev-&gt;pm_usage_cnt &lt;= 0)
+		schedule_delayed_work(&amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
+}
+
+/**
+ * usb_autoresume_device - immediately autoresume a USB device and its interfaces
+ * @udev - the usb_device to autoresume
+ * @inc_usage_cnt - flag to increment @udev's PM-usage counter
+ *
+ * This routine should be called when a core subsystem wants to use @udev
+ * and needs to guarantee that it is not suspended.  In addition, the
+ * caller can prevent @udev from being autosuspended subsequently.  (Note
+ * that this will not prevent suspend events originating in the PM core.)
+ * Examples would be when @udev's device file in usbfs is opened (autosuspend
+ * should be prevented until the file is closed) or when a remote-wakeup
+ * request is received (later autosuspends should not be prevented).
+ *
+ * @inc_usage_cnt should be 1 to increment @udev's usage counter and prevent
+ * autosuspends.  This prevention will persist until the usage counter is
+ * decremented again (such as by passing 1 to usb_autosuspend_device).
+ * Otherwise @inc_usage_cnt should be 0 to leave the usage counter unchanged.
+ * Regardless, if the autoresume fails then the usage counter is not
+ * incremented.
+ *
+ * Often the caller will hold @udev's device lock, but this is not
+ * necessary (and attempting it might cause deadlock).
+ *
+ * This routine can run only in process context.
+ */
+int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
+{
+	int	status;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;pm_usage_cnt += inc_usage_cnt;
+	udev-&gt;auto_pm = 1;
+	status = usb_resume_both(udev);
+	if (status != 0)
+		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
+	return status;
+}
+
+/**
+ * usb_autopm_put_interface - decrement a USB interface's PM-usage counter
+ * @intf - the usb_interface whose counter should be decremented
+ *
+ * This routine should be called by an interface driver when it is
+ * finished using @intf and wants to allow it to autosuspend.  A typical
+ * example would be a character-device driver when its device file is
+ * closed.
+ *
+ * The routine decrements @intf's usage counter.  When the counter reaches
+ * 0, a delayed autosuspend request for @intf's device is queued.  When
+ * the delay expires, if @intf-&gt;pm_usage_cnt is still &lt;= 0 along with all
+ * the other usage counters for the sibling interfaces and @intf's
+ * usb_device, the device and all its interfaces will be autosuspended.
+ *
+ * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
+ * core will not change its value other than the increment and decrement
+ * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
+ * may use this simple counter-oriented discipline or may set the value
+ * any way it likes.
+ *
+ * If the driver has set @intf-&gt;needs_remote_wakeup then autosuspend will
+ * take place only if the device's remote-wakeup facility is enabled.
+ *
+ * Suspend method calls queued by this routine can arrive at any time
+ * while @intf is resumed and its usage counter is equal to 0.  They are
+ * not protected by the usb_device's lock but only by its pm_mutex.
+ * Drivers must provide their own synchronization.
+ *
+ * This routine can run only in process context.
+ */
+void usb_autopm_put_interface(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	if (intf-&gt;condition != USB_INTERFACE_UNBOUND) {
+		if (--intf-&gt;pm_usage_cnt &lt;= 0)
+			schedule_delayed_work(&amp;udev-&gt;autosuspend,
+					USB_AUTOSUSPEND_DELAY);
+	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
+	//		__FUNCTION__, intf-&gt;pm_usage_cnt);
+}
+EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
+
+/**
+ * usb_autopm_get_interface - increment a USB interface's PM-usage counter
+ * @intf - the usb_interface whose counter should be incremented
+ *
+ * This routine should be called by an interface driver when it wants to
+ * use @intf and needs to guarantee that it is not suspended.  In addition,
+ * the routine prevents @intf from being autosuspended subsequently.  (Note
+ * that this will not prevent suspend events originating in the PM core.)
+ * This prevention will persist until usb_autopm_put_interface() is called
+ * or @intf is unbound.  A typical example would be a character-device
+ * driver when its device file is opened.
+ *
+ * The routine increments @intf's usage counter.  So long as the counter
+ * is greater than 0, autosuspend will not be allowed for @intf or its
+ * usb_device.  When the driver is finished using @intf it should call
+ * usb_autopm_put_interface() to decrement the usage counter and queue
+ * a delayed autosuspend request (if the counter is &lt;= 0).
+ *
+ * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
+ * core will not change its value other than the increment and decrement
+ * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
+ * may use this simple counter-oriented discipline or may set the value
+ * any way it likes.
+ *
+ * Resume method calls generated by this routine can arrive at any time
+ * while @intf is suspended.  They are not protected by the usb_device's
+ * lock but only by its pm_mutex.  Drivers must provide their own
+ * synchronization.
+ *
+ * This routine can run only in process context.
+ */
+int usb_autopm_get_interface(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+	int			status;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
+		status = -ENODEV;
+	else {
+		++intf-&gt;pm_usage_cnt;
+		udev-&gt;auto_pm = 1;
+		status = usb_resume_both(udev);
+		if (status != 0)
+			--intf-&gt;pm_usage_cnt;
+	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
+EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
+
+#endif /* CONFIG_USB_SUSPEND */
 
 static int usb_suspend(struct device *dev, pm_message_t message)
 {
 	int	status;
 
-	if (is_usb_device(dev))
-		status = usb_suspend_both(to_usb_device(dev), message);
-	else
+	if (is_usb_device(dev)) {
+		struct usb_device *udev = to_usb_device(dev);
+
+		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		udev-&gt;auto_pm = 0;
+		status = usb_suspend_both(udev, message);
+		mutex_unlock(&amp;udev-&gt;pm_mutex);
+	} else
 		status = 0;
 	return status;
 }
@@ -939,7 +1293,12 @@ static int usb_resume(struct device *dev)
 	int	status;
 
 	if (is_usb_device(dev)) {
-		status = usb_resume_both(to_usb_device(dev));
+		struct usb_device *udev = to_usb_device(dev);
+
+		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		udev-&gt;auto_pm = 0;
+		status = usb_resume_both(udev);
+		mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 		/* Rebind drivers that had no suspend method? */
 	} else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 78e910b2046c..dee812bc6c43 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1017,19 +1017,22 @@ void usb_set_device_state(struct usb_device *udev,
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		;	/* do nothing */
 	else if (new_state != USB_STATE_NOTATTACHED) {
-		udev-&gt;state = new_state;
 
 		/* root hub wakeup capabilities are managed out-of-band
 		 * and may involve silicon errata ... ignore them here.
 		 */
 		if (udev-&gt;parent) {
-			if (new_state == USB_STATE_CONFIGURED)
+			if (udev-&gt;state == USB_STATE_SUSPENDED
+					|| new_state == USB_STATE_SUSPENDED)
+				;	/* No change to wakeup settings */
+			else if (new_state == USB_STATE_CONFIGURED)
 				device_init_wakeup(&amp;udev-&gt;dev,
 					(udev-&gt;actconfig-&gt;desc.bmAttributes
 					 &amp; USB_CONFIG_ATT_WAKEUP));
-			else if (new_state != USB_STATE_SUSPENDED)
+			else
 				device_init_wakeup(&amp;udev-&gt;dev, 0);
 		}
+		udev-&gt;state = new_state;
 	} else
 		recursively_mark_NOTATTACHED(udev);
 	spin_unlock_irqrestore(&amp;device_state_lock, flags);
@@ -1507,7 +1510,7 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when
 	 * we don't explicitly enable it here.
 	 */
-	if (device_may_wakeup(&amp;udev-&gt;dev)) {
+	if (udev-&gt;do_remote_wakeup) {
 		status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
 				USB_DEVICE_REMOTE_WAKEUP, 0,
@@ -1533,7 +1536,8 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 				USB_CTRL_SET_TIMEOUT);
 	} else {
 		/* device has up to 10 msec to fully suspend */
-		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
 	}
@@ -1573,7 +1577,8 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
 				udev);
 	else {
-		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 	}
 	return status;
@@ -1687,7 +1692,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 
 		/* drive resume for at least 20 msec */
 		if (udev)
-			dev_dbg(&amp;udev-&gt;dev, "RESUME\n");
+			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+					udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
 #define LIVE_FLAGS	( USB_PORT_STAT_POWER \
@@ -1754,8 +1760,11 @@ int usb_port_resume(struct usb_device *udev)
 		// NOTE this fails if parent is also suspended...
 		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
 				udev-&gt;portnum, udev);
-	} else
+	} else {
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		status = finish_port_resume(udev);
+	}
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;
@@ -1765,19 +1774,23 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* don't repeat RESUME sequence if this device
-	 * was already woken up by some other task
-	 */
+	/* All this just to avoid sending a port-resume message
+	 * to the parent hub! */
+
 	usb_lock_device(udev);
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
 		status = finish_port_resume(udev);
+		if (status == 0)
+			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 	if (status == 0)
-		usb_resume_both(udev);
+		usb_autoresume_device(udev, 0);
 	usb_unlock_device(udev);
 	return status;
 }
@@ -1834,7 +1847,9 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 					== PM_EVENT_ON
 #endif
 				) {
-			dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
+			if (!hdev-&gt;auto_pm)
+				dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n",
+						port1);
 			return -EBUSY;
 		}
 	}
@@ -2587,7 +2602,7 @@ static void hub_events(void)
 		 * stub "device" node was never suspended.
 		 */
 		if (i)
-			usb_resume_both(hdev);
+			usb_autoresume_device(hdev, 0);
 
 		/* If this is an inactive or suspended hub, do nothing */
 		if (hub-&gt;quiescing)
@@ -2993,6 +3008,9 @@ int usb_reset_composite_device(struct usb_device *udev,
 		return -EINVAL;
 	}
 
+	/* Prevent autosuspend during the reset */
+	usb_autoresume_device(udev, 1);
+
 	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
 		iface = NULL;
 
@@ -3034,6 +3052,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 		}
 	}
 
+	usb_autosuspend_device(udev, 1);
 	return ret;
 }
 EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b0c0a993338f..6b029cdb8671 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -168,6 +168,10 @@ static void usb_release_dev(struct device *dev)
 
 	udev = to_usb_device(dev);
 
+#ifdef	CONFIG_PM
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	flush_scheduled_work();
+#endif
 	usb_destroy_configuration(udev);
 	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
 	kfree(udev-&gt;product);
@@ -176,6 +180,21 @@ static void usb_release_dev(struct device *dev)
 	kfree(udev);
 }
 
+#ifdef	CONFIG_PM
+
+/* usb_autosuspend_work - callback routine to autosuspend a USB device */
+static void usb_autosuspend_work(void *_udev)
+{
+	struct usb_device	*udev = _udev;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;auto_pm = 1;
+	usb_suspend_both(udev, PMSG_SUSPEND);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+}
+
+#endif
+
 /**
  * usb_alloc_dev - usb device constructor (usbcore-internal)
  * @parent: hub to which device is connected; null to allocate a root hub
@@ -251,6 +270,10 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
 
+#ifdef	CONFIG_PM
+	mutex_init(&amp;dev-&gt;pm_mutex);
+	INIT_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work, dev);
+#endif
 	return dev;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5162cb370215..10688ad73c6d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -49,6 +49,20 @@ static inline int usb_resume_both(struct usb_device *udev)
 
 #endif
 
+#ifdef CONFIG_USB_SUSPEND
+
+#define USB_AUTOSUSPEND_DELAY	(HZ*2)
+
+extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
+extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+
+#else
+
+#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
+#define usb_autoresume_device(udev, inc_busy_cnt)	0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index df5c93eb3ce9..0da15b0b02be 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -19,6 +19,7 @@
 #include &lt;linux/fs.h&gt;		/* for struct file_operations */
 #include &lt;linux/completion.h&gt;	/* for struct completion */
 #include &lt;linux/sched.h&gt;	/* for current &amp;&amp; schedule_timeout */
+#include &lt;linux/mutex.h&gt;	/* for struct mutex */
 
 struct usb_device;
 struct usb_driver;
@@ -103,8 +104,12 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
+ * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
+ *	capability during autosuspend.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
+ * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
+ *	allowed unless the counter is 0.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -144,9 +149,11 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
@@ -372,6 +379,15 @@ struct usb_device {
 
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
+
+#ifdef CONFIG_PM
+	struct work_struct autosuspend;	/* for delayed autosuspends */
+	struct mutex pm_mutex;		/* protects PM operations */
+	int pm_usage_cnt;		/* usage counter for autosuspend */
+
+	unsigned auto_pm:1;		/* autosuspend/resume in progress */
+	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+#endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -392,6 +408,17 @@ extern int usb_reset_composite_device(struct usb_device *dev,
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
+/* USB autosuspend and autoresume */
+#ifdef CONFIG_USB_SUSPEND
+extern int usb_autopm_get_interface(struct usb_interface *intf);
+extern void usb_autopm_put_interface(struct usb_interface *intf);
+
+#else
+#define usb_autopm_get_interface(intf)		0
+#define usb_autopm_put_interface(intf)		do {} while (0)
+#endif
+
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */
@@ -593,6 +620,8 @@ struct usbdrv_wrap {
  * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for interfaces bound to this driver.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -631,6 +660,7 @@ struct usb_driver {
 	struct usb_dynids dynids;
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 
@@ -648,6 +678,8 @@ struct usb_driver {
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
  * @drvwrap: Driver-model core structure wrapper.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for devices bound to this driver.
  *
  * USB drivers must provide all the fields listed above except drvwrap.
  */
@@ -660,6 +692,7 @@ struct usb_device_driver {
 	int (*suspend) (struct usb_device *udev, pm_message_t message);
 	int (*resume) (struct usb_device *udev);
 	struct usbdrv_wrap drvwrap;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
 		drvwrap.driver)</pre><hr><pre>commit b6956ffa595db97656d5901ca8fec77ef272d41a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:46:48 2006 -0400

    usbcore: store each usb_device's level in the tree
    
    This patch (as778) adds a field to struct usb_device to store the
    device's level in the USB tree.  In itself this number isn't really
    important.  But the overhead is very low, and in a later patch it will
    be used for preventing bogus warnings from the lockdep checker.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f5adce049b35..78e910b2046c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2414,6 +2414,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_set_device_state(udev, USB_STATE_POWERED);
 		udev-&gt;speed = USB_SPEED_UNKNOWN;
  		udev-&gt;bus_mA = hub-&gt;mA_per_port;
+		udev-&gt;level = hdev-&gt;level + 1;
 
 		/* set the address */
 		choose_address(udev);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c66303285a45..df5c93eb3ce9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 
 	unsigned short bus_mA;		/* Current available from the bus */
 	u8 portnum;			/* Parent port number (origin 1) */
+	u8 level;			/* Number of USB hub ancestors */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */</pre><hr><pre>commit 4d6cd48380c4d361cc8ec34359df22377d85d202
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:35:21 2006 -0400

    usbmon: don't call mon_dmapeek if DMA isn't being used
    
    This patch (as755b) fixes a bug in usbmon.  Rather than assuming all
    USB host controllers use DMA, the code will check the usb_bus data
    structure.  If DMA isn't used, we don't want to try peeking into a
    non-existent DMA buffer!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index e0ed36cdfd8b..394bbf2f68d4 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -301,6 +301,7 @@ static void mon_bus_init(struct dentry *mondir, struct usb_bus *ubus)
 	 */
 	mbus-&gt;u_bus = ubus;
 	ubus-&gt;mon_bus = mbus;
+	mbus-&gt;uses_dma = ubus-&gt;uses_dma;
 
 	rc = snprintf(name, NAMESZ, "%dt", ubus-&gt;busnum);
 	if (rc &lt;= 0 || rc &gt;= NAMESZ)
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 775e374a960c..7a2346c53284 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -75,13 +75,13 @@ static void mon_text_ctor(void *, kmem_cache_t *, unsigned long);
  */
 
 static inline char mon_text_get_setup(struct mon_event_text *ep,
-    struct urb *urb, char ev_type)
+    struct urb *urb, char ev_type, struct mon_bus *mbus)
 {
 
 	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
 		return '-';
 
-	if (urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)
+	if (mbus-&gt;uses_dma &amp;&amp; (urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 		return mon_dmapeek(ep-&gt;setup, urb-&gt;setup_dma, SETUP_MAX);
 	if (urb-&gt;setup_packet == NULL)
 		return 'Z';	/* '0' would be not as pretty. */
@@ -91,7 +91,7 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
 }
 
 static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
-    int len, char ev_type)
+    int len, char ev_type, struct mon_bus *mbus)
 {
 	int pipe = urb-&gt;pipe;
 
@@ -117,7 +117,7 @@ static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
 	 * contain non-NULL garbage in case the upper level promised to
 	 * set DMA for the HCD.
 	 */
-	if (urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)
+	if (mbus-&gt;uses_dma &amp;&amp; (urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
 		return mon_dmapeek(ep-&gt;data, urb-&gt;transfer_dma, len);
 
 	if (urb-&gt;transfer_buffer == NULL)
@@ -161,8 +161,9 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	/* Collecting status makes debugging sense for submits, too */
 	ep-&gt;status = urb-&gt;status;
 
-	ep-&gt;setup_flag = mon_text_get_setup(ep, urb, ev_type);
-	ep-&gt;data_flag = mon_text_get_data(ep, urb, ep-&gt;length, ev_type);
+	ep-&gt;setup_flag = mon_text_get_setup(ep, urb, ev_type, rp-&gt;r.m_bus);
+	ep-&gt;data_flag = mon_text_get_data(ep, urb, ep-&gt;length, ev_type,
+			rp-&gt;r.m_bus);
 
 	rp-&gt;nevents++;
 	list_add_tail(&amp;ep-&gt;e_link, &amp;rp-&gt;e_list);
diff --git a/drivers/usb/mon/usb_mon.h b/drivers/usb/mon/usb_mon.h
index 50efc8ee7c21..ab9d02d5df77 100644
--- a/drivers/usb/mon/usb_mon.h
+++ b/drivers/usb/mon/usb_mon.h
@@ -20,6 +20,7 @@ struct mon_bus {
 	struct dentry *dent_s;		/* Debugging file */
 	struct dentry *dent_t;		/* Text interface file */
 	struct usb_bus *u_bus;
+	int uses_dma;
 
 	/* Ref */
 	int nreaders;			/* Under mon_lock AND mbus-&gt;lock */</pre><hr><pre>commit 1720058343fa43a1a25bfad9e62ea06e7e9743b6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:32:52 2006 -0400

    usbcore: trim down usb_bus structure
    
    As part of the ongoing program to flatten out the HCD bus-glue layer,
    this patch (as771b) eliminates the hcpriv, release, and kref fields
    from struct usb_bus.  hcpriv and release were not being used for
    anything worthwhile, and kref has been moved into the enclosing
    usb_hcd structure.
    
    Along with those changes, the patch gets rid of usb_bus_get and
    usb_bus_put, replacing them with usb_get_hcd and usb_put_hcd.
    
    The one interesting aspect is that the dev_set_drvdata call was
    removed from usb_put_hcd, where it clearly doesn't belong.  This means
    the driver private data won't get reset to NULL.  It shouldn't cause
    any problems, since the private data is undefined when no driver is
    bound.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/buffer.c b/drivers/usb/core/buffer.c
index f4f4ef0f377a..840442a25b61 100644
--- a/drivers/usb/core/buffer.c
+++ b/drivers/usb/core/buffer.c
@@ -104,7 +104,7 @@ void *hcd_buffer_alloc (
 	dma_addr_t		*dma
 )
 {
-	struct usb_hcd		*hcd = bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(bus);
 	int 			i;
 
 	/* some USB hosts just use PIO */
@@ -127,7 +127,7 @@ void hcd_buffer_free (
 	dma_addr_t		dma
 )
 {
-	struct usb_hcd		*hcd = bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(bus);
 	int 			i;
 
 	if (!addr)
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0cc14206920a..9dfc812de034 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -664,31 +664,6 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 
 /*-------------------------------------------------------------------------*/
 
-/* exported only within usbcore */
-struct usb_bus *usb_bus_get(struct usb_bus *bus)
-{
-	if (bus)
-		kref_get(&amp;bus-&gt;kref);
-	return bus;
-}
-
-static void usb_host_release(struct kref *kref)
-{
-	struct usb_bus *bus = container_of(kref, struct usb_bus, kref);
-
-	if (bus-&gt;release)
-		bus-&gt;release(bus);
-}
-
-/* exported only within usbcore */
-void usb_bus_put(struct usb_bus *bus)
-{
-	if (bus)
-		kref_put(&amp;bus-&gt;kref, usb_host_release);
-}
-
-/*-------------------------------------------------------------------------*/
-
 static struct class *usb_host_class;
 
 int usb_host_init(void)
@@ -720,15 +695,12 @@ static void usb_bus_init (struct usb_bus *bus)
 	bus-&gt;devnum_next = 1;
 
 	bus-&gt;root_hub = NULL;
-	bus-&gt;hcpriv = NULL;
 	bus-&gt;busnum = -1;
 	bus-&gt;bandwidth_allocated = 0;
 	bus-&gt;bandwidth_int_reqs  = 0;
 	bus-&gt;bandwidth_isoc_reqs = 0;
 
 	INIT_LIST_HEAD (&amp;bus-&gt;bus_list);
-
-	kref_init(&amp;bus-&gt;kref);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1081,7 +1053,7 @@ static void urb_unlink (struct urb *urb)
 int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
-	struct usb_hcd		*hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 	struct usb_host_endpoint *ep;
 	unsigned long		flags;
 
@@ -1189,7 +1161,8 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 /* called in any context */
 int usb_hcd_get_frame_number (struct usb_device *udev)
 {
-	struct usb_hcd	*hcd = (struct usb_hcd *)udev-&gt;bus-&gt;hcpriv;
+	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
+
 	if (!HC_IS_RUNNING (hcd-&gt;state))
 		return -ESHUTDOWN;
 	return hcd-&gt;driver-&gt;get_frame_number (hcd);
@@ -1262,7 +1235,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	spin_lock (&amp;hcd_data_lock);
 
 	sys = &amp;urb-&gt;dev-&gt;dev;
-	hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
+	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 	if (hcd == NULL) {
 		retval = -ENODEV;
 		goto done;
@@ -1333,7 +1306,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
 
-	hcd = udev-&gt;bus-&gt;hcpriv;
+	hcd = bus_to_hcd(udev-&gt;bus);
 
 	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT &amp;&amp;
 			udev-&gt;state != USB_STATE_NOTATTACHED);
@@ -1673,14 +1646,6 @@ EXPORT_SYMBOL_GPL (usb_hc_died);
 
 /*-------------------------------------------------------------------------*/
 
-static void hcd_release (struct usb_bus *bus)
-{
-	struct usb_hcd *hcd;
-
-	hcd = container_of(bus, struct usb_hcd, self);
-	kfree(hcd);
-}
-
 /**
  * usb_create_hcd - create and initialize an HCD structure
  * @driver: HC driver that will use this hcd
@@ -1705,10 +1670,9 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		return NULL;
 	}
 	dev_set_drvdata(dev, hcd);
+	kref_init(&amp;hcd-&gt;kref);
 
 	usb_bus_init(&amp;hcd-&gt;self);
-	hcd-&gt;self.hcpriv = hcd;
-	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
 	hcd-&gt;self.bus_name = bus_name;
 	hcd-&gt;self.uses_dma = (dev-&gt;dma_mask != NULL);
@@ -1725,10 +1689,25 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 }
 EXPORT_SYMBOL (usb_create_hcd);
 
+static void hcd_release (struct kref *kref)
+{
+	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
+
+	kfree(hcd);
+}
+
+struct usb_hcd *usb_get_hcd (struct usb_hcd *hcd)
+{
+	if (hcd)
+		kref_get (&amp;hcd-&gt;kref);
+	return hcd;
+}
+EXPORT_SYMBOL (usb_get_hcd);
+
 void usb_put_hcd (struct usb_hcd *hcd)
 {
-	dev_set_drvdata(hcd-&gt;self.controller, NULL);
-	usb_bus_put(&amp;hcd-&gt;self);
+	if (hcd)
+		kref_put (&amp;hcd-&gt;kref, hcd_release);
 }
 EXPORT_SYMBOL (usb_put_hcd);
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 83e229914797..7a2bcba2ae61 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -55,12 +55,13 @@
 
 /*-------------------------------------------------------------------------*/
 
-struct usb_hcd {	/* usb_bus.hcpriv points to this */
+struct usb_hcd {
 
 	/*
 	 * housekeeping
 	 */
 	struct usb_bus		self;		/* hcd is-a bus */
+	struct kref		kref;		/* reference counter */
 
 	const char		*product_desc;	/* product/vendor string */
 	char			irq_descr[24];	/* driver + bus # */
@@ -129,8 +130,10 @@ static inline struct usb_bus *hcd_to_bus (struct usb_hcd *hcd)
 	return &amp;hcd-&gt;self;
 }
 
-
-// urb.hcpriv is really hardware-specific
+static inline struct usb_hcd *bus_to_hcd (struct usb_bus *bus)
+{
+	return container_of(bus, struct usb_hcd, self);
+}
 
 struct hcd_timeout {	/* timeouts we allocate */
 	struct list_head	timeout_list;
@@ -210,6 +213,7 @@ extern int usb_hcd_get_frame_number (struct usb_device *udev);
 
 extern struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		struct device *dev, char *bus_name);
+extern struct usb_hcd *usb_get_hcd (struct usb_hcd *hcd);
 extern void usb_put_hcd (struct usb_hcd *hcd);
 extern int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags);
@@ -356,9 +360,6 @@ extern struct list_head usb_bus_list;
 extern struct mutex usb_bus_list_lock;
 extern wait_queue_head_t usb_kill_urb_queue;
 
-extern struct usb_bus *usb_bus_get (struct usb_bus *bus);
-extern void usb_bus_put (struct usb_bus *bus);
-
 extern void usb_enable_root_hub_irq (struct usb_bus *bus);
 
 extern int usb_find_interface_driver (struct usb_device *dev,
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 7ab9d29215f8..b0c0a993338f 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -169,7 +169,7 @@ static void usb_release_dev(struct device *dev)
 	udev = to_usb_device(dev);
 
 	usb_destroy_configuration(udev);
-	usb_bus_put(udev-&gt;bus);
+	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
 	kfree(udev-&gt;product);
 	kfree(udev-&gt;manufacturer);
 	kfree(udev-&gt;serial);
@@ -197,8 +197,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	if (!dev)
 		return NULL;
 
-	bus = usb_bus_get(bus);
-	if (!bus) {
+	if (!usb_get_hcd(bus_to_hcd(bus))) {
 		kfree(dev);
 		return NULL;
 	}
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 7d1c22c34957..fdab97a27c08 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -889,11 +889,9 @@ EXPORT_SYMBOL (net2280_set_fifo_mode);
 static void
 dummy_gadget_release (struct device *dev)
 {
-#if 0		/* usb_bus_put isn't EXPORTed! */
 	struct dummy	*dum = gadget_dev_to_dummy (dev);
 
-	usb_bus_put (&amp;dummy_to_hcd (dum)-&gt;self);
-#endif
+	usb_put_hcd (dummy_to_hcd (dum));
 }
 
 static int dummy_udc_probe (struct platform_device *pdev)
@@ -915,9 +913,7 @@ static int dummy_udc_probe (struct platform_device *pdev)
 	if (rc &lt; 0)
 		return rc;
 
-#if 0		/* usb_bus_get isn't EXPORTed! */
-	usb_bus_get (&amp;dummy_to_hcd (dum)-&gt;self);
-#endif
+	usb_get_hcd (dummy_to_hcd (dum));
 
 	platform_set_drvdata (pdev, dum);
 	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 65ac9fef3a7c..215ce6d06394 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -451,7 +451,7 @@ show_async (struct class_device *class_dev, char *buf)
 	*buf = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -497,7 +497,7 @@ show_periodic (struct class_device *class_dev, char *buf)
 	seen_count = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -634,7 +634,7 @@ show_registers (struct class_device *class_dev, char *buf)
 	static char		label [] = "";
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index da52609a9290..534d07dcb824 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -477,7 +477,7 @@ show_async (struct class_device *class_dev, char *buf)
 	unsigned long		flags;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 
 	/* display control and bulk lists together, for simplicity */
@@ -510,7 +510,7 @@ show_periodic (struct class_device *class_dev, char *buf)
 	seen_count = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -607,7 +607,7 @@ show_registers (struct class_device *class_dev, char *buf)
 	u32			rdata;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	regs = ohci-&gt;regs;
 	next = buf;
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index 275a66f83058..e0ed36cdfd8b 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -265,7 +265,6 @@ static void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus)
 	ubus-&gt;mon_bus = NULL;
 	mbus-&gt;u_bus = NULL;
 	mb();
-	// usb_bus_put(ubus);
 }
 
 /*
@@ -297,10 +296,9 @@ static void mon_bus_init(struct dentry *mondir, struct usb_bus *ubus)
 	INIT_LIST_HEAD(&amp;mbus-&gt;r_list);
 
 	/*
-	 * This usb_bus_get here is superfluous, because we receive
-	 * a notification if usb_bus is about to be removed.
+	 * We don't need to take a reference to ubus, because we receive
+	 * a notification if the bus is about to be removed.
 	 */
-	// usb_bus_get(ubus);
 	mbus-&gt;u_bus = ubus;
 	ubus-&gt;mon_bus = mbus;
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 09661759621f..c66303285a45 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -280,7 +280,6 @@ struct usb_bus {
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
-	void *hcpriv;                   /* Host Controller private data */
 
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
@@ -295,8 +294,6 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* reference counting for this bus */
-	void (*release)(struct usb_bus *bus);
 
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */</pre><hr><pre>commit dd990f16a39d4e615c0b70a0ab50b79b32bfb16d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:29:56 2006 -0400

    usbcore: Add flag for whether a host controller uses DMA
    
    This patch (as770b) introduces a new field to usb_bus: a flag
    indicating whether or not the host controller uses DMA.  This serves
    to encapsulate the computation.  It also means we will have only one
    spot to update if the DMA API changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 2102c4deec1e..0cc14206920a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1152,7 +1152,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	/* lower level hcd code should use *_dma exclusively,
 	 * unless it uses pio or talks to another transport.
 	 */
-	if (hcd-&gt;self.controller-&gt;dma_mask) {
+	if (hcd-&gt;self.uses_dma) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
@@ -1585,8 +1585,9 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs
 	at_root_hub = (urb-&gt;dev == hcd-&gt;self.root_hub);
 	urb_unlink (urb);
 
-	/* lower level hcd code should use *_dma exclusively */
-	if (hcd-&gt;self.controller-&gt;dma_mask &amp;&amp; !at_root_hub) {
+	/* lower level hcd code should use *_dma exclusively if the
+	 * host controller does DMA */
+	if (hcd-&gt;self.uses_dma &amp;&amp; !at_root_hub) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
@@ -1710,6 +1711,7 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
 	hcd-&gt;self.bus_name = bus_name;
+	hcd-&gt;self.uses_dma = (dev-&gt;dma_mask != NULL);
 
 	init_timer(&amp;hcd-&gt;rh_timer);
 	hcd-&gt;rh_timer.function = rh_timer_func;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4709033f8fa7..09661759621f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -269,6 +269,7 @@ struct usb_bus {
 	struct device *controller;	/* host/master side hardware */
 	int busnum;			/* Bus number (in order of reg) */
 	char *bus_name;			/* stable id (PCI slot_name etc) */
+	u8 uses_dma;			/* Does the host controller use DMA? */
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */</pre><hr><pre>commit a6d2bb9ff919b4685bd684620ec7a1ffa8bf2349
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:27:36 2006 -0400

    USB: remove struct usb_operations
    
    All of the currently-supported USB host controller drivers use the HCD
    bus-glue framework.  As part of the program for flattening out the glue
    layer, this patch (as769) removes the usb_operations structure.  All
    function calls now go directly to the HCD routines (slightly renamed
    to remain within the "usb_" namespace).
    
    The patch also removes usb_alloc_bus(), because it's not useful in the
    HCD framework and it wasn't referenced anywhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index ea20a3a5a9b9..2102c4deec1e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -731,30 +731,6 @@ static void usb_bus_init (struct usb_bus *bus)
 	kref_init(&amp;bus-&gt;kref);
 }
 
-/**
- * usb_alloc_bus - creates a new USB host controller structure
- * @op: pointer to a struct usb_operations that this bus structure should use
- * Context: !in_interrupt()
- *
- * Creates a USB host controller bus structure with the specified 
- * usb_operations and initializes all the necessary internal objects.
- *
- * If no memory is available, NULL is returned.
- *
- * The caller should call usb_put_bus() when it is finished with the structure.
- */
-struct usb_bus *usb_alloc_bus (struct usb_operations *op)
-{
-	struct usb_bus *bus;
-
-	bus = kzalloc (sizeof *bus, GFP_KERNEL);
-	if (!bus)
-		return NULL;
-	usb_bus_init (bus);
-	bus-&gt;op = op;
-	return bus;
-}
-
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -1102,7 +1078,7 @@ static void urb_unlink (struct urb *urb)
  * expects usb_submit_urb() to have sanity checked and conditioned all
  * inputs in the urb
  */
-static int hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
+int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
 	struct usb_hcd		*hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
@@ -1211,7 +1187,7 @@ static int hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 /*-------------------------------------------------------------------------*/
 
 /* called in any context */
-static int hcd_get_frame_number (struct usb_device *udev)
+int usb_hcd_get_frame_number (struct usb_device *udev)
 {
 	struct usb_hcd	*hcd = (struct usb_hcd *)udev-&gt;bus-&gt;hcpriv;
 	if (!HC_IS_RUNNING (hcd-&gt;state))
@@ -1253,7 +1229,7 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  * caller guarantees urb won't be recycled till both unlink()
  * and the urb's completion function return
  */
-static int hcd_unlink_urb (struct urb *urb, int status)
+int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_host_endpoint	*ep;
 	struct usb_hcd			*hcd = NULL;
@@ -1351,8 +1327,8 @@ static int hcd_unlink_urb (struct urb *urb, int status)
  * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
  * type, maxpacket size, toggle, halt status, and scheduling.
  */
-static void
-hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
+void usb_hcd_endpoint_disable (struct usb_device *udev,
+		struct usb_host_endpoint *ep)
 {
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
@@ -1589,20 +1565,6 @@ EXPORT_SYMBOL (usb_bus_start_enum);
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * usb_hcd_operations - adapts usb_bus framework to HCD framework (bus glue)
- */
-static struct usb_operations usb_hcd_operations = {
-	.get_frame_number =	hcd_get_frame_number,
-	.submit_urb =		hcd_submit_urb,
-	.unlink_urb =		hcd_unlink_urb,
-	.buffer_alloc =		hcd_buffer_alloc,
-	.buffer_free =		hcd_buffer_free,
-	.disable =		hcd_endpoint_disable,
-};
-
-/*-------------------------------------------------------------------------*/
-
 /**
  * usb_hcd_giveback_urb - return URB from HCD to device driver
  * @hcd: host controller returning the URB
@@ -1744,7 +1706,6 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	dev_set_drvdata(dev, hcd);
 
 	usb_bus_init(&amp;hcd-&gt;self);
-	hcd-&gt;self.op = &amp;usb_hcd_operations;
 	hcd-&gt;self.hcpriv = hcd;
 	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index fc71a08a1af4..83e229914797 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -139,28 +139,6 @@ struct hcd_timeout {	/* timeouts we allocate */
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * FIXME usb_operations should vanish or become hc_driver,
- * when usb_bus and usb_hcd become the same thing.
- */
-
-struct usb_operations {
-	int (*get_frame_number) (struct usb_device *usb_dev);
-	int (*submit_urb) (struct urb *urb, gfp_t mem_flags);
-	int (*unlink_urb) (struct urb *urb, int status);
-
-	/* allocate dma-consistent buffer for URB_DMA_NOMAPPING */
-	void *(*buffer_alloc)(struct usb_bus *bus, size_t size,
-			gfp_t mem_flags,
-			dma_addr_t *dma);
-	void (*buffer_free)(struct usb_bus *bus, size_t size,
-			void *addr, dma_addr_t dma);
-
-	void (*disable)(struct usb_device *udev,
-			struct usb_host_endpoint *ep);
-};
-
-/* each driver provides one of these, and hardware init support */
 
 struct pt_regs;
 
@@ -222,7 +200,13 @@ struct hc_driver {
 		/* Needed only if port-change IRQs are level-triggered */
 };
 
-extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs);
+extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
+extern int usb_hcd_unlink_urb (struct urb *urb, int status);
+extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb,
+		struct pt_regs *regs);
+extern void usb_hcd_endpoint_disable (struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern int usb_hcd_get_frame_number (struct usb_device *udev);
 
 extern struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		struct device *dev, char *bus_name);
@@ -361,8 +345,6 @@ extern long usb_calc_bus_time (int speed, int is_input,
 
 /*-------------------------------------------------------------------------*/
 
-extern struct usb_bus *usb_alloc_bus (struct usb_operations *);
-
 extern void usb_set_device_state(struct usb_device *udev,
 		enum usb_device_state new_state);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 333b22c68aa4..1580c81a0db7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -984,8 +984,8 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 		ep = dev-&gt;ep_in[epnum];
 		dev-&gt;ep_in[epnum] = NULL;
 	}
-	if (ep &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;op &amp;&amp; dev-&gt;bus-&gt;op-&gt;disable)
-		dev-&gt;bus-&gt;op-&gt;disable(dev, ep);
+	if (ep &amp;&amp; dev-&gt;bus)
+		usb_hcd_endpoint_disable(dev, ep);
 }
 
 /**
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9864988377c7..576919927f53 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -221,7 +221,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int			pipe, temp, max;
 	struct usb_device	*dev;
-	struct usb_operations	*op;
 	int			is_out;
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
@@ -233,8 +232,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (dev-&gt;bus-&gt;controller-&gt;power.power_state.event != PM_EVENT_ON
 			|| dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
-	if (!(op = dev-&gt;bus-&gt;op) || !op-&gt;submit_urb)
-		return -ENODEV;
 
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
@@ -376,7 +373,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		urb-&gt;interval = temp;
 	}
 
-	return op-&gt;submit_urb (urb, mem_flags);
+	return usb_hcd_submit_urb (urb, mem_flags);
 }
 
 /*-------------------------------------------------------------------*/
@@ -440,9 +437,9 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
+	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
 		return -ENODEV;
-	return urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ECONNRESET);
+	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
 /**
@@ -468,13 +465,13 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
+	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
 		return;
 	spin_lock_irq(&amp;urb-&gt;lock);
 	++urb-&gt;reject;
 	spin_unlock_irq(&amp;urb-&gt;lock);
 
-	urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ENOENT);
+	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&amp;urb-&gt;use_count) == 0);
 
 	spin_lock_irq(&amp;urb-&gt;lock);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 4eb98eb3804f..7ab9d29215f8 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -480,7 +480,7 @@ struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)
  */
 int usb_get_current_frame_number(struct usb_device *dev)
 {
-	return dev-&gt;bus-&gt;op-&gt;get_frame_number (dev);
+	return usb_hcd_get_frame_number (dev);
 }
 
 /**
@@ -677,9 +677,9 @@ void *usb_buffer_alloc (
 	dma_addr_t *dma
 )
 {
-	if (!dev || !dev-&gt;bus || !dev-&gt;bus-&gt;op || !dev-&gt;bus-&gt;op-&gt;buffer_alloc)
+	if (!dev || !dev-&gt;bus)
 		return NULL;
-	return dev-&gt;bus-&gt;op-&gt;buffer_alloc (dev-&gt;bus, size, mem_flags, dma);
+	return hcd_buffer_alloc (dev-&gt;bus, size, mem_flags, dma);
 }
 
 /**
@@ -700,11 +700,11 @@ void usb_buffer_free (
 	dma_addr_t dma
 )
 {
-	if (!dev || !dev-&gt;bus || !dev-&gt;bus-&gt;op || !dev-&gt;bus-&gt;op-&gt;buffer_free)
+	if (!dev || !dev-&gt;bus)
 		return;
 	if (!addr)
 		return;
-	dev-&gt;bus-&gt;op-&gt;buffer_free (dev-&gt;bus, size, addr, dma);
+	hcd_buffer_free (dev-&gt;bus, size, addr, dma);
 }
 
 /**
diff --git a/include/linux/usb.h b/include/linux/usb.h
index f104efa04d79..4709033f8fa7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -257,8 +257,6 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 
 /* ----------------------------------------------------------------------- */
 
-struct usb_operations;
-
 /* USB device number allocation bitmap */
 struct usb_devmap {
 	unsigned long devicemap[128 / (8*sizeof(unsigned long))];
@@ -279,7 +277,6 @@ struct usb_bus {
 					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
-	struct usb_operations *op;	/* Operations (specific to the HC) */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
 	void *hcpriv;                   /* Host Controller private data */
@@ -1051,7 +1048,6 @@ extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 
-#define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,</pre><hr><pre>commit 088dc270e1da03744d977cbd9edd4311af142348
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 12:08:19 2006 -0400

    usbcore: help drivers to change device configs
    
    It's generally a bad idea for USB interface drivers to try to change a
    device's configuration, and usbcore doesn't provide any way for them
    to do it.  However in a few exceptional circumstances it can make
    sense.  This patch (as767) adds a roundabout mechanism to help drivers
    that may need it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 49cfd7928a1c..333b22c68aa4 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1493,6 +1493,65 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	return 0;
 }
 
+struct set_config_request {
+	struct usb_device	*udev;
+	int			config;
+	struct work_struct	work;
+};
+
+/* Worker routine for usb_driver_set_configuration() */
+static void driver_set_config_work(void *_req)
+{
+	struct set_config_request *req = _req;
+
+	usb_lock_device(req-&gt;udev);
+	usb_set_configuration(req-&gt;udev, req-&gt;config);
+	usb_unlock_device(req-&gt;udev);
+	usb_put_dev(req-&gt;udev);
+	kfree(req);
+}
+
+/**
+ * usb_driver_set_configuration - Provide a way for drivers to change device configurations
+ * @udev: the device whose configuration is being updated
+ * @config: the configuration being chosen.
+ * Context: In process context, must be able to sleep
+ *
+ * Device interface drivers are not allowed to change device configurations.
+ * This is because changing configurations will destroy the interface the
+ * driver is bound to and create new ones; it would be like a floppy-disk
+ * driver telling the computer to replace the floppy-disk drive with a
+ * tape drive!
+ *
+ * Still, in certain specialized circumstances the need may arise.  This
+ * routine gets around the normal restrictions by using a work thread to
+ * submit the change-config request.
+ *
+ * Returns 0 if the request was succesfully queued, error code otherwise.
+ * The caller has no way to know whether the queued request will eventually
+ * succeed.
+ */
+int usb_driver_set_configuration(struct usb_device *udev, int config)
+{
+	struct set_config_request *req;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	req-&gt;udev = udev;
+	req-&gt;config = config;
+	INIT_WORK(&amp;req-&gt;work, driver_set_config_work, req);
+
+	usb_get_dev(udev);
+	if (!schedule_work(&amp;req-&gt;work)) {
+		usb_put_dev(udev);
+		kfree(req);
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_driver_set_configuration);
+
 // synchronous request completion model
 EXPORT_SYMBOL(usb_control_msg);
 EXPORT_SYMBOL(usb_bulk_msg);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 26d8a5f36896..f104efa04d79 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1099,6 +1099,9 @@ extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
 
+/* this request isn't really synchronous, but it belongs with the others */
+extern int usb_driver_set_configuration(struct usb_device *udev, int config);
+
 /*
  * timeouts, in milliseconds, used for sending/receiving control messages
  * they typically complete within a few frames (msec) after they're issued</pre><hr><pre>commit 3a3416b12f1fbd607bc137a57c924a628aa5485c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 12:00:53 2006 -0400

    usb-storage: fix for UFI LUN detection
    
    The UFI specification doesn't permit devices to indicate non-existent
    LUNs in the manner prescribed by the SCSI spec.  This patch (as773)
    sets a special flag so that the SCSI scanner will recognize these
    devices and treat them specially.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a4b7df9ff8c1..e1072d52d641 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -72,12 +72,27 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
+	struct us_data *us = host_to_us(sdev-&gt;host);
+
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
 	 * less than 36 bytes.
 	 */
 	sdev-&gt;inquiry_len = 36;
+
+	/*
+	 * The UFI spec treates the Peripheral Qualifier bits in an
+	 * INQUIRY result as reserved and requires devices to set them
+	 * to 0.  However the SCSI spec requires these bits to be set
+	 * to 3 to indicate when a LUN is not present.
+	 *
+	 * Let the scanning code know if this target merely sets
+	 * Peripheral Device Type to 0x1f to indicate no LUN.
+	 */
+	if (us-&gt;subclass == US_SC_UFI)
+		sdev-&gt;sdev_target-&gt;pdt_1f_for_no_lun = 1;
+
 	return 0;
 }
 </pre><hr><pre>commit d5cbad4b8b37acfde3e63d31b92561b87288ad0f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 16:52:39 2006 -0400

    usbcore: khubd and busy-port handling
    
    We don't want khubd to start interfering in the device-resume process
    merely because the PORT_STATUS_C_SUSPEND feature happens to be set.
    Ports need to be marked as busy while a resume is taking place.
    
    In addition, so long as ports are marked as busy, khubd won't be able to
    clear their various status-change features.  On an interrupt-driven root
    hub this could lead to an interrupt storm.  Root hub IRQs should not be
    re-enabled until the busy_bits value is equal to 0.
    
    This patch (as765) fixes these two potential problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 3924dd080bea..bdf5be099650 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1658,6 +1658,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 
 	// dev_dbg(hub-&gt;intfdev, "resume port %d\n", port1);
 
+	set_bit(port1, hub-&gt;busy_bits);
+
 	/* see 7.1.7.7; affects power usage, but not budgeting */
 	status = clear_port_feature(hub-&gt;hdev,
 			port1, USB_PORT_FEAT_SUSPEND);
@@ -1707,6 +1709,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	if (status &lt; 0)
 		hub_port_logical_disconnect(hub, port1);
 
+	clear_bit(port1, hub-&gt;busy_bits);
+	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
+		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
+
 	return status;
 }
 
@@ -2690,7 +2696,7 @@ static void hub_events(void)
 
 		/* If this is a root hub, tell the HCD it's okay to
 		 * re-enable port-change interrupts now. */
-		if (!hdev-&gt;parent)
+		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 			usb_enable_root_hub_irq(hdev-&gt;bus);
 
 loop:
@@ -2865,6 +2871,9 @@ int usb_reset_device(struct usb_device *udev)
 			break;
 	}
 	clear_bit(port1, parent_hub-&gt;busy_bits);
+	if (!parent_hdev-&gt;parent &amp;&amp; !parent_hub-&gt;busy_bits[0])
+		usb_enable_root_hub_irq(parent_hdev-&gt;bus);
+
 	if (ret &lt; 0)
 		goto re_enumerate;
  
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 29d5f45a8456..0f8e82a4d480 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -212,7 +212,8 @@ struct usb_hub {
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
-	unsigned long		busy_bits[1];	/* ports being reset */
+	unsigned long		busy_bits[1];	/* ports being reset or
+							resumed */
 #if USB_MAXCHILDREN &gt; 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif</pre>
    <div class="pagination">
        <a href='2_119.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><span>[120]</span><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_121.html'>Next&gt;&gt;</a>
    <div>
</body>
