<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_101.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><span>[102]</span><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_103.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b0d9efba3ec53468984aecef8eeaf079089f2e5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:39:21 2007 -0400

    USB: centralize -EREMOTEIO handling
    
    This patch (as969) continues the ongoing changes to the way HCDs
    report URB statuses.  The programming interface has been simplified by
    making usbcore responsible for clearing urb-&gt;hcpriv and for setting
    -EREMOTEIO status when an URB with the URB_SHORT_NOT_OK flag ends up
    as a short transfer.
    
    By moving the work out of the HCDs, this removes a fair amount of
    repeated code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index a853f63b9254..22a098b318c0 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -366,6 +366,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	spin_unlock_irq(&amp;hcd_root_hub_lock);
 	if (status)
 		return status;
+	urb-&gt;hcpriv = hcd;	/* Indicate it's queued */
 
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
@@ -579,7 +580,6 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 			hcd-&gt;poll_pending = 0;
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;status = 0;
-			urb-&gt;hcpriv = NULL;
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
@@ -675,7 +675,6 @@ static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			del_timer (&amp;hcd-&gt;rh_timer);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
-			urb-&gt;hcpriv = NULL;
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
@@ -1192,6 +1191,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
 		unmap_urb_for_dma(hcd, urb);
+		urb-&gt;hcpriv = NULL;
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
 		if (urb-&gt;reject)
@@ -1265,6 +1265,11 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
+	urb-&gt;hcpriv = NULL;
+	if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
+			!urb-&gt;status))
+		urb-&gt;status = -EREMOTEIO;
 
 	/* pass ownership to the completion handler */
 	urb-&gt;complete (urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c441d10c087e..0cb032526ca2 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1099,8 +1099,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		 *
 		 * partially filling a buffer optionally blocks queue advances
 		 * (so completion handlers can clean up the queue) but we don't
-		 * need to emulate such data-in-flight.  so we only show part
-		 * of the URB_SHORT_NOT_OK effect: completion status.
+		 * need to emulate such data-in-flight.
 		 */
 		if (is_short) {
 			if (host_len == dev_len) {
@@ -1111,10 +1110,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 				if (dev_len &gt; host_len)
 					maybe_set_status (urb, -EOVERFLOW);
 				else
-					maybe_set_status (urb,
-						(urb-&gt;transfer_flags
-							&amp; URB_SHORT_NOT_OK)
-						? -EREMOTEIO : 0);
+					maybe_set_status (urb, 0);
 			} else if (!to_host) {
 				maybe_set_status (urb, 0);
 				if (host_len &gt; dev_len)
@@ -1516,7 +1512,6 @@ static void dummy_timer (unsigned long _dum)
 			continue;
 
 return_urb:
-		urb-&gt;hcpriv = NULL;
 		list_del (&amp;urbp-&gt;urbp_list);
 		kfree (urbp);
 		if (ep)
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 1da2de4d34ed..e80b5c417d74 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -232,7 +232,6 @@ __acquires(ehci-&gt;lock)
 	}
 
 	spin_lock (&amp;urb-&gt;lock);
-	urb-&gt;hcpriv = NULL;
 	switch (urb-&gt;status) {
 	case -EINPROGRESS:		/* success */
 		urb-&gt;status = 0;
@@ -395,8 +394,10 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* remove it from the queue */
 		spin_lock (&amp;urb-&gt;lock);
 		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
-		do_status = (urb-&gt;status == -EREMOTEIO)
-				&amp;&amp; usb_pipecontrol (urb-&gt;pipe);
+		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
+			do_status = usb_pipecontrol(urb-&gt;pipe);
+			urb-&gt;status = 0;
+		}
 		spin_unlock (&amp;urb-&gt;lock);
 
 		if (stopped &amp;&amp; qtd-&gt;qtd_list.prev != &amp;qh-&gt;qtd_list) {
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index f2b5d6281c5d..c2919dbc3f54 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -282,7 +282,6 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 {
 	unsigned i;
 
-	urb-&gt;hcpriv = NULL;
 	ep-&gt;error_count = 0;
 
 	if (usb_pipecontrol(urb-&gt;pipe))
@@ -446,12 +445,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			if (PTD_GET_ACTIVE(ptd)
 			    || (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E))
 				break;
-			if ((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
-					urb-&gt;actual_length &lt;
-						urb-&gt;transfer_buffer_length)
-				status = -EREMOTEIO;
-			else
-				status = 0;
+			status = 0;
 			ep-&gt;nextpid = 0;
 			break;
 		default:
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 889c0720743b..8aad6199cdcc 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -43,21 +43,10 @@ __acquires(ohci-&gt;lock)
 	// ASSERT (urb-&gt;hcpriv != 0);
 
 	urb_free_priv (ohci, urb-&gt;hcpriv);
-	urb-&gt;hcpriv = NULL;
 
 	spin_lock (&amp;urb-&gt;lock);
 	if (likely (urb-&gt;status == -EINPROGRESS))
 		urb-&gt;status = 0;
-	/* report short control reads right even though the data TD always
-	 * has TD_R set.  (much simpler, but creates the 1-td limit.)
-	 */
-	if (unlikely (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			&amp;&amp; unlikely (usb_pipecontrol (urb-&gt;pipe))
-			&amp;&amp; urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length
-			&amp;&amp; usb_pipein (urb-&gt;pipe)
-			&amp;&amp; urb-&gt;status == 0) {
-		urb-&gt;status = -EREMOTEIO;
-	}
 	spin_unlock (&amp;urb-&gt;lock);
 
 	switch (usb_pipetype (urb-&gt;pipe)) {
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 49cf998c172a..60248b01ce14 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -783,7 +783,6 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 
 		if (urb) {
 			urb-&gt;status = -ENODEV;
-			urb-&gt;hcpriv = NULL;
 			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
 					urb);
 
@@ -1134,7 +1133,6 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 		if (usb_pipeisoc(urb-&gt;pipe))
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
-		urb-&gt;hcpriv = NULL;
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
 
 		spin_unlock(&amp;r8a66597-&gt;lock);
@@ -1202,9 +1200,6 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 		td-&gt;zero_packet = 1;
 	if (rcv_len &lt; bufsize) {
 		td-&gt;short_packet = 1;
-		if (urb-&gt;transfer_buffer_length != urb-&gt;actual_length &amp;&amp;
-		    urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			status = -EREMOTEIO;
 	}
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].actual_length = size;
@@ -1214,7 +1209,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	}
 
 	/* check transfer finish */
-	if (check_transfer_finish(td, urb)) {
+	if (finish || check_transfer_finish(td, urb)) {
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		finish = 1;
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 15a93f946afd..e90953a9c9fb 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -438,7 +438,6 @@ static void finish_request(
 	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	urb-&gt;hcpriv = NULL;
 	spin_unlock(&amp;urb-&gt;lock);
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
@@ -545,17 +544,10 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
 					buf, len);
 			usb_dotoggle(udev, ep-&gt;epnum, 0);
-			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length)
+			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length
+					|| len &lt; ep-&gt;maxpacket)
 				urbstat = 0;
-			else if (len &lt; ep-&gt;maxpacket) {
-				if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-					urbstat = -EREMOTEIO;
-				else
-					urbstat = 0;
-			}
-			if (usb_pipecontrol(urb-&gt;pipe)
-					&amp;&amp; (urbstat == -EREMOTEIO
-						|| urbstat == 0)) {
+			if (usb_pipecontrol(urb-&gt;pipe) &amp;&amp; urbstat == 0) {
 
 				/* NOTE if the status stage STALLs (why?),
 				 * this reports the wrong urb status.
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index c87660b5edc3..1381275d448f 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -519,7 +519,6 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
         urb-&gt;status = status;
-        urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -560,7 +559,6 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
         urb-&gt;status = status;
-        urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -2430,7 +2428,6 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
                         list_del(scan);
                         endp-&gt;queue_size -= 1;
                         urb-&gt;error_count = 0;
-                        urb-&gt;hcpriv = NULL;
                         usb_hcd_giveback_urb(hcd, urb);
                         return 0;
                 } else
@@ -2472,7 +2469,6 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         endp-&gt;edset_flush = 1;
                         u132_endp_queue_work(u132, endp, 0);
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
-                        urb-&gt;hcpriv = NULL;
                         return 0;
                 } else {
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
@@ -2517,7 +2513,6 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                                         irqs);
                                 kfree(urbq);
                         } urb-&gt;error_count = 0;
-                        urb-&gt;hcpriv = NULL;
                         usb_hcd_giveback_urb(hcd, urb);
                         return 0;
                 } else if (list_empty(&amp;endp-&gt;urb_more)) {
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 793a04685ef4..fbc3af392c26 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -757,7 +757,6 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		uhci_free_td(uhci, td);
 	}
 
-	urbp-&gt;urb-&gt;hcpriv = NULL;
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
@@ -1494,13 +1493,6 @@ __acquires(uhci-&gt;lock)
 		 * unlinked first.  Regardless, don't confuse people with a
 		 * negative length. */
 		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
-
-		/* Report erroneous short transfers */
-		if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
-				urb-&gt;actual_length &lt;
-					urb-&gt;transfer_buffer_length &amp;&amp;
-				urb-&gt;status == 0))
-			urb-&gt;status = -EREMOTEIO;
 	}
 
 	/* When giving back the first URB in an Isochronous queue,</pre><hr><pre>commit ee7d1f3f0c32d8abe9627aa73dc62ee5bf2daf7f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:37:50 2007 -0400

    USB: remove Iso status value in uhci-hcd
    
    This patch (968) changes the way uhci-hcd reports status for
    Isochronous URBs.  Until now urb-&gt;status has been set to the last
    detected error code.  But other HCDs don't do this; they leave the
    status set to 0 and report errors only in the individual iso packet
    descriptors.  So this patch removes the extra computation and makes
    uhci-hcd behave like the others.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 1b3d23406ac4..e46d2b0203cb 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -146,7 +146,6 @@ struct uhci_qh {
 	short phase;			/* Between 0 and period-1 */
 	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
-	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bff200cb3d2e..793a04685ef4 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1324,7 +1324,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	if (list_empty(&amp;qh-&gt;queue)) {
 		qh-&gt;iso_packet_desc = &amp;urb-&gt;iso_frame_desc[0];
 		qh-&gt;iso_frame = urb-&gt;start_frame;
-		qh-&gt;iso_status = 0;
 	}
 
 	qh-&gt;skel = SKEL_ISO;
@@ -1361,18 +1360,15 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 			qh-&gt;iso_packet_desc-&gt;actual_length = actlength;
 			qh-&gt;iso_packet_desc-&gt;status = status;
 		}
-
-		if (status) {
+		if (status)
 			urb-&gt;error_count++;
-			qh-&gt;iso_status = status;
-		}
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
 		qh-&gt;iso_frame += qh-&gt;period;
 		++qh-&gt;iso_packet_desc;
 	}
-	return qh-&gt;iso_status;
+	return 0;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
@@ -1517,7 +1513,6 @@ __acquires(uhci-&gt;lock)
 
 		qh-&gt;iso_packet_desc = &amp;nurb-&gt;iso_frame_desc[0];
 		qh-&gt;iso_frame = nurb-&gt;start_frame;
-		qh-&gt;iso_status = 0;
 	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
@@ -1586,7 +1581,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		}
 
 		uhci_giveback_urb(uhci, qh, urb);
-		if (status &lt; 0 &amp;&amp; qh-&gt;type != USB_ENDPOINT_XFER_ISOC)
+		if (status &lt; 0)
 			break;
 	}
 </pre><hr><pre>commit dfd1e53777afe1050e3a0a3f0dd063a64242b818
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:36:52 2007 -0400

    USB: minor fixes for r8a66597 driver
    
    This patch (as967) makes a few relatively minor changes to the
    r8a66597 driver:
    
            finish_request() does nothing but call done(), so merge the
            two routines.
    
            Detect and report -EOVERFLOW errors.
    
            Fix the calculation that checks for short packets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 94bb229df3bc..49cf998c172a 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1109,8 +1109,9 @@ static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 }
 
 /* this function must be called with interrupt disabled */
-static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		 u16 pipenum, struct urb *urb)
+static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
+		u16 pipenum, struct urb *urb)
+__releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 {
 	int restart = 0;
 	struct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);
@@ -1151,14 +1152,6 @@ static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
 	}
 }
 
-/* this function must be called with interrupt disabled */
-static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-			   u16 pipenum, struct urb *urb)
-__releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
-{
-	done(r8a66597, td, pipenum, urb);
-}
-
 static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	u16 tmp;
@@ -1167,6 +1160,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 	struct urb *urb;
 	int finish = 0;
+	int status = 0;
 
 	if (unlikely(!td))
 		return;
@@ -1185,7 +1179,6 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 
 	/* prepare parameters */
 	rcv_len = tmp &amp; DTLN;
-	bufsize = td-&gt;maxpacket;
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		buf = (u16 *)(urb-&gt;transfer_buffer +
 				urb-&gt;iso_frame_desc[td-&gt;iso_cnt].offset);
@@ -1194,25 +1187,30 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 		buf = (void *)urb-&gt;transfer_buffer + urb-&gt;actual_length;
 		urb_len = urb-&gt;transfer_buffer_length - urb-&gt;actual_length;
 	}
-	if (rcv_len &lt; bufsize)
-		size = min(rcv_len, urb_len);
-	else
-		size = min(bufsize, urb_len);
+	bufsize = min(urb_len, (int) td-&gt;maxpacket);
+	if (rcv_len &lt;= bufsize) {
+		size = rcv_len;
+	} else {
+		size = bufsize;
+		status = -EOVERFLOW;
+		finish = 1;
+	}
 
 	/* update parameters */
 	urb-&gt;actual_length += size;
 	if (rcv_len == 0)
 		td-&gt;zero_packet = 1;
-	if ((size % td-&gt;maxpacket) &gt; 0) {
+	if (rcv_len &lt; bufsize) {
 		td-&gt;short_packet = 1;
 		if (urb-&gt;transfer_buffer_length != urb-&gt;actual_length &amp;&amp;
 		    urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			td-&gt;urb-&gt;status = -EREMOTEIO;
+			status = -EREMOTEIO;
 	}
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].actual_length = size;
-		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].status = 0;
+		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].status = status;
 		td-&gt;iso_cnt++;
+		finish = 0;
 	}
 
 	/* check transfer finish */
@@ -1233,7 +1231,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 
 	if (finish &amp;&amp; pipenum != 0) {
 		if (td-&gt;urb-&gt;status == -EINPROGRESS)
-			td-&gt;urb-&gt;status = 0;
+			td-&gt;urb-&gt;status = status;
 		finish_request(r8a66597, td, pipenum, urb);
 	}
 }
@@ -1807,7 +1805,7 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, td-&gt;pipenum);
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
-		done(r8a66597, td, td-&gt;pipenum, urb);
+		finish_request(r8a66597, td, td-&gt;pipenum, urb);
 	}
  done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
@@ -1841,7 +1839,7 @@ static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
 	td = r8a66597_get_td(r8a66597, pipenum);
 	if (td)
 		urb = td-&gt;urb;
-	done(r8a66597, td, pipenum, urb);
+	finish_request(r8a66597, td, pipenum, urb);
 	kfree(hep-&gt;hcpriv);
 	hep-&gt;hcpriv = NULL;
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);</pre><hr><pre>commit e39ab592f182cd0be48acc4ad49f93ef4100017c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 16 16:17:49 2007 -0400

    USB: remove unnecessary tests in isp116x and sl811
    
    This patch (as962) cleans up some code I forgot to remove earlier in
    the isp116x and sl811 HCDs.  There is no longer any need to check for
    unlink-during-submit; it can't happen since the endpoint queues are
    now under the protection of the HCD-private spinlock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index d5027dc75a57..f2b5d6281c5d 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -815,12 +815,6 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 		}
 	}
 
-	/* in case of unlink-during-submit */
-	if (urb-&gt;status != -EINPROGRESS) {
-		finish_request(isp116x, ep, urb);
-		ret = 0;
-		goto fail;
-	}
 	urb-&gt;hcpriv = hep;
 	start_atl_transfers(isp116x);
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 3d3a63d002c5..15a93f946afd 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -957,17 +957,7 @@ static int sl811h_urb_enqueue(
 		sofirq_on(sl811);
 	}
 
-	/* in case of unlink-during-submit */
-	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
-		finish_request(sl811, ep, urb, 0);
-		retval = 0;
-		goto fail;
-	}
 	urb-&gt;hcpriv = hep;
-	spin_unlock(&amp;urb-&gt;lock);
-
 	start_transfer(sl811);
 	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811-&gt;irq_enable);
 fail:</pre><hr><pre>commit 79a7d9ee1a2e8b8dc44dd217f07496911850ec0e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 17:10:11 2007 -0400

    USB: cleanups for g_file_storage
    
    This patch (as957) makes some minor cleanups to the g_file_storage
    driver:
    
            Update the copyright date and version string;
    
            Uniformize the logging macros for the gadget and the LUNs;
    
            Remove "inline" markers -- nowadays we rely on the compiler
            to decide which routines are best inlined;
    
            Use the print_hex_dump() library routines;
    
            Remove some unnecessary assignments within conditionals
            and fix some close-brace indenting levels;
    
            Fix some column-80 violations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 0019116ee411..9998cd7af418 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1,7 +1,7 @@
 /*
  * file_storage.c -- File-backed USB Storage Gadget, for USB development
  *
- * Copyright (C) 2003-2005 Alan Stern
+ * Copyright (C) 2003-2007 Alan Stern
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -218,7 +218,7 @@
 
 
 /* #define VERBOSE_DEBUG */
-#undef DUMP_MSGS
+/* #define DUMP_MSGS */
 
 
 #include &lt;linux/blkdev.h&gt;
@@ -249,7 +249,7 @@
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"28 November 2005"
+#define DRIVER_VERSION		"7 August 2007"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -275,12 +275,9 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 /*-------------------------------------------------------------------------*/
 
-#define yprintk(l,level,fmt,args...) \
-	dev_printk(level , &amp;(l)-&gt;dev , fmt , ## args)
-
 #ifdef DEBUG
 #define LDBG(lun,fmt,args...) \
-	yprintk(lun , KERN_DEBUG , fmt , ## args)
+	dev_dbg(&amp;(lun)-&gt;dev , fmt , ## args)
 #define MDBG(fmt,args...) \
 	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
 #else
@@ -300,11 +297,11 @@ MODULE_LICENSE("Dual BSD/GPL");
 #endif /* VERBOSE_DEBUG */
 
 #define LERROR(lun,fmt,args...) \
-	yprintk(lun , KERN_ERR , fmt , ## args)
+	dev_err(&amp;(lun)-&gt;dev , fmt , ## args)
 #define LWARN(lun,fmt,args...) \
-	yprintk(lun , KERN_WARNING , fmt , ## args)
+	dev_warn(&amp;(lun)-&gt;dev , fmt , ## args)
 #define LINFO(lun,fmt,args...) \
-	yprintk(lun , KERN_INFO , fmt , ## args)
+	dev_info(&amp;(lun)-&gt;dev , fmt , ## args)
 
 #define MINFO(fmt,args...) \
 	printk(KERN_INFO DRIVER_NAME ": " fmt , ## args)
@@ -558,7 +555,7 @@ struct lun {
 
 #define backing_file_is_open(curlun)	((curlun)-&gt;filp != NULL)
 
-static inline struct lun *dev_to_lun(struct device *dev)
+static struct lun *dev_to_lun(struct device *dev)
 {
 	return container_of(dev, struct lun, dev);
 }
@@ -691,13 +688,13 @@ struct fsg_dev {
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
 
-static int inline exception_in_progress(struct fsg_dev *fsg)
+static int exception_in_progress(struct fsg_dev *fsg)
 {
 	return (fsg-&gt;state &gt; FSG_STATE_IDLE);
 }
 
 /* Make bulk-out requests be divisible by the maxpacket size */
-static void inline set_bulk_out_req_length(struct fsg_dev *fsg,
+static void set_bulk_out_req_length(struct fsg_dev *fsg,
 		struct fsg_buffhd *bh, unsigned int length)
 {
 	unsigned int	rem;
@@ -723,50 +720,36 @@ static void	close_all_backing_files(struct fsg_dev *fsg);
 static void dump_msg(struct fsg_dev *fsg, const char *label,
 		const u8 *buf, unsigned int length)
 {
-	unsigned int	start, num, i;
-	char		line[52], *p;
-
-	if (length &gt;= 512)
-		return;
-	DBG(fsg, "%s, length %u:\n", label, length);
-
-	start = 0;
-	while (length &gt; 0) {
-		num = min(length, 16u);
-		p = line;
-		for (i = 0; i &lt; num; ++i) {
-			if (i == 8)
-				*p++ = ' ';
-			sprintf(p, " %02x", buf[i]);
-			p += 3;
-		}
-		*p = 0;
-		printk(KERN_DEBUG "%6x: %s\n", start, line);
-		buf += num;
-		start += num;
-		length -= num;
+	if (length &lt; 512) {
+		DBG(fsg, "%s, length %u:\n", label, length);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET,
+				16, 1, buf, length, 0);
 	}
 }
 
-static void inline dump_cdb(struct fsg_dev *fsg)
+static void dump_cdb(struct fsg_dev *fsg)
 {}
 
 #else
 
-static void inline dump_msg(struct fsg_dev *fsg, const char *label,
+static void dump_msg(struct fsg_dev *fsg, const char *label,
 		const u8 *buf, unsigned int length)
 {}
 
-static void inline dump_cdb(struct fsg_dev *fsg)
-{
-	int	i;
-	char	cmdbuf[3*MAX_COMMAND_SIZE + 1];
+#ifdef VERBOSE_DEBUG
 
-	for (i = 0; i &lt; fsg-&gt;cmnd_size; ++i)
-		sprintf(cmdbuf + i*3, " %02x", fsg-&gt;cmnd[i]);
-	VDBG(fsg, "SCSI CDB: %s\n", cmdbuf);
+static void dump_cdb(struct fsg_dev *fsg)
+{
+	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,
+			16, 1, fsg-&gt;cmnd, fsg-&gt;cmnd_size, 0);
 }
 
+#else
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#endif /* VERBOSE_DEBUG */
 #endif /* DUMP_MSGS */
 
 
@@ -789,24 +772,24 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 
 /* Routines for unaligned data access */
 
-static u16 inline get_be16(u8 *buf)
+static u16 get_be16(u8 *buf)
 {
 	return ((u16) buf[0] &lt;&lt; 8) | ((u16) buf[1]);
 }
 
-static u32 inline get_be32(u8 *buf)
+static u32 get_be32(u8 *buf)
 {
 	return ((u32) buf[0] &lt;&lt; 24) | ((u32) buf[1] &lt;&lt; 16) |
 			((u32) buf[2] &lt;&lt; 8) | ((u32) buf[3]);
 }
 
-static void inline put_be16(u8 *buf, u16 val)
+static void put_be16(u8 *buf, u16 val)
 {
 	buf[0] = val &gt;&gt; 8;
 	buf[1] = val;
 }
 
-static void inline put_be32(u8 *buf, u32 val)
+static void put_be32(u8 *buf, u32 val)
 {
 	buf[0] = val &gt;&gt; 24;
 	buf[1] = val &gt;&gt; 16;
@@ -992,7 +975,7 @@ static const struct usb_descriptor_header *hs_function[] = {
 #define HS_FUNCTION_PRE_EP_ENTRIES	2
 
 /* Maxpacket and other transfer characteristics vary by speed. */
-static inline struct usb_endpoint_descriptor *
+static struct usb_endpoint_descriptor *
 ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
 		struct usb_endpoint_descriptor *hs)
 {
@@ -1616,7 +1599,8 @@ static int do_read(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg-&gt;next_buffhd_to_fill;
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -1855,7 +1839,8 @@ static int do_write(struct fsg_dev *fsg)
 		}
 
 		/* Wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2339,7 +2324,8 @@ static int pad_with_zeros(struct fsg_dev *fsg)
 
 		/* Wait for the next buffer to be free */
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -2399,7 +2385,8 @@ static int throw_away_data(struct fsg_dev *fsg)
 		}
 
 		/* Otherwise wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 	return 0;
@@ -2521,7 +2508,8 @@ static int send_status(struct fsg_dev *fsg)
 	/* Wait for the next buffer to become available */
 	bh = fsg-&gt;next_buffhd_to_fill;
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2741,9 +2729,10 @@ static int do_scsi_command(struct fsg_dev *fsg)
 	/* Wait for the next buffer to become available for data or status */
 	bh = fsg-&gt;next_buffhd_to_drain = fsg-&gt;next_buffhd_to_fill;
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
-		}
+	}
 	fsg-&gt;phase_error = 0;
 	fsg-&gt;short_packet_received = 0;
 
@@ -3015,9 +3004,10 @@ static int get_next_command(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg-&gt;next_buffhd_to_fill;
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 
 		/* Queue a request to read a Bulk-only CBW */
 		set_bulk_out_req_length(fsg, bh, USB_BULK_CB_WRAP_LEN);
@@ -3031,9 +3021,10 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the CBW to arrive */
 		while (bh-&gt;state != BUF_STATE_FULL) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 		smp_rmb();
 		rc = received_cbw(fsg, bh);
 		bh-&gt;state = BUF_STATE_EMPTY;
@@ -3042,9 +3033,10 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the next command to arrive */
 		while (fsg-&gt;cbbuf_cmnd_size == 0) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 
 		/* Is the previous status interrupt request still busy?
 		 * The host is allowed to skip reading the status,
@@ -3565,7 +3557,8 @@ static ssize_t show_ro(struct device *dev, struct device_attribute *attr, char *
 	return sprintf(buf, "%d\n", curlun-&gt;ro);
 }
 
-static ssize_t show_file(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_file(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);
@@ -3574,8 +3567,8 @@ static ssize_t show_file(struct device *dev, struct device_attribute *attr, char
 
 	down_read(&amp;fsg-&gt;filesem);
 	if (backing_file_is_open(curlun)) {	// Get the complete pathname
-		p = d_path(curlun-&gt;filp-&gt;f_path.dentry, curlun-&gt;filp-&gt;f_path.mnt,
-				buf, PAGE_SIZE - 1);
+		p = d_path(curlun-&gt;filp-&gt;f_path.dentry,
+				curlun-&gt;filp-&gt;f_path.mnt, buf, PAGE_SIZE - 1);
 		if (IS_ERR(p))
 			rc = PTR_ERR(p);
 		else {
@@ -3593,7 +3586,8 @@ static ssize_t show_file(struct device *dev, struct device_attribute *attr, char
 }
 
 
-static ssize_t store_ro(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t store_ro(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	ssize_t		rc = count;
 	struct lun	*curlun = dev_to_lun(dev);
@@ -3617,7 +3611,8 @@ static ssize_t store_ro(struct device *dev, struct device_attribute *attr, const
 	return rc;
 }
 
-static ssize_t store_file(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t store_file(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);</pre><hr><pre>commit d74d4a69dc1cc7ddc0eabb9c9f1e45005e2984eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 11:59:18 2007 -0400

    USB: don't touch sysfs stuff when altsetting is unchanged
    
    This patch (as955) prevents the interface-related sysfs files and
    endpoint pseudo-devices from being deleted and recreated when a call
    to usb_set_interface() specifies the current altsetting.  Since the
    altsetting doesn't get changed, there's no need to do anything.
    
    Furthermore, avoiding changes to the endpoint devices will be
    necessary in the future.  This code is called from usb_reset_device(),
    which gets invoked for reset-resume processing, but upcoming changes
    to the PM and driver cores will make it impossible to register devices
    while a suspend/resume transition is in progress.  Since we don't need
    to re-register those endpoint devices anyhow, it's best to skip the
    whole thing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index c905b35d4f85..d638375e22e7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1173,6 +1173,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	struct usb_host_interface *alt;
 	int ret;
 	int manual = 0;
+	int changed;
 
 	if (dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -1212,7 +1213,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	if (device_is_registered(&amp;iface-&gt;dev))
+	changed = (iface-&gt;cur_altsetting != alt);
+	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1249,7 +1251,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
-	if (device_is_registered(&amp;iface-&gt;dev))
+	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_create_sysfs_intf_files(iface);
 
 	return 0;</pre><hr><pre>commit e9df41c5c5899259541dc928872cad4d07b82076
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 11:48:02 2007 -0400

    USB: make HCDs responsible for managing endpoint queues
    
    This patch (as954) implements a suggestion of David Brownell's.  Now
    the host controller drivers are responsible for linking and unlinking
    URBs to/from their endpoint queues.  This eliminates the possiblity of
    strange situations where usbcore thinks an URB is linked but the HCD
    thinks it isn't.  It also means HCDs no longer have to check for URBs
    being dequeued before they were fully enqueued.
    
    In addition to the core changes, this requires changing every host
    controller driver and the root-hub URB handler.  For the most part the
    required changes are fairly small; drivers have to call
    usb_hcd_link_urb_to_ep() in their urb_enqueue method,
    usb_hcd_check_unlink_urb() in their urb_dequeue method, and
    usb_hcd_unlink_urb_from_ep() before giving URBs back.  A few HCDs make
    matters more complicated by the way they split up the flow of control.
    
    In addition some method interfaces get changed.  The endpoint argument
    for urb_enqueue is now redundant so it is removed.  The unlink status
    is required by usb_hcd_check_unlink_urb(), so it has been added to
    urb_dequeue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index a5a46a55376b..a853f63b9254 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -356,11 +356,17 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	const u8	*bufp = tbuf;
 	int		len = 0;
 	int		patch_wakeup = 0;
-	int		status = 0;
+	int		status;
 	int		n;
 
 	might_sleep();
 
+	spin_lock_irq(&amp;hcd_root_hub_lock);
+	status = usb_hcd_link_urb_to_ep(hcd, urb);
+	spin_unlock_irq(&amp;hcd_root_hub_lock);
+	if (status)
+		return status;
+
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
 	wValue   = le16_to_cpu (cmd-&gt;wValue);
@@ -525,10 +531,9 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	spin_unlock(&amp;urb-&gt;lock);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
 	 * Avoiding calls to local_irq_disable/enable makes the code
@@ -571,26 +576,21 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 		urb = hcd-&gt;status_urb;
 		if (urb) {
-			spin_lock(&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS) {
-				hcd-&gt;poll_pending = 0;
-				hcd-&gt;status_urb = NULL;
-				urb-&gt;status = 0;
-				urb-&gt;hcpriv = NULL;
-				urb-&gt;actual_length = length;
-				memcpy(urb-&gt;transfer_buffer, buffer, length);
-			} else		/* urb has been unlinked */
-				length = 0;
-			spin_unlock(&amp;urb-&gt;lock);
+			hcd-&gt;poll_pending = 0;
+			hcd-&gt;status_urb = NULL;
+			urb-&gt;status = 0;
+			urb-&gt;hcpriv = NULL;
+			urb-&gt;actual_length = length;
+			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			spin_unlock(&amp;hcd_root_hub_lock);
 			usb_hcd_giveback_urb(hcd, urb);
 			spin_lock(&amp;hcd_root_hub_lock);
-		} else
+		} else {
 			length = 0;
-
-		if (length &lt;= 0)
 			hcd-&gt;poll_pending = 1;
+		}
 		spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	}
 
@@ -619,24 +619,26 @@ static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 	int		len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
-	if (urb-&gt;status != -EINPROGRESS)	/* already unlinked */
-		retval = urb-&gt;status;
-	else if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
+	if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
 		dev_dbg (hcd-&gt;self.controller, "not queuing rh status urb\n");
 		retval = -EINVAL;
-	} else {
-		hcd-&gt;status_urb = urb;
-		urb-&gt;hcpriv = hcd;	/* indicate it's queued */
+		goto done;
+	}
 
-		if (!hcd-&gt;uses_new_polling)
-			mod_timer (&amp;hcd-&gt;rh_timer,
-				(jiffies/(HZ/4) + 1) * (HZ/4));
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
+		goto done;
 
-		/* If a status change has already occurred, report it ASAP */
-		else if (hcd-&gt;poll_pending)
-			mod_timer (&amp;hcd-&gt;rh_timer, jiffies);
-		retval = 0;
-	}
+	hcd-&gt;status_urb = urb;
+	urb-&gt;hcpriv = hcd;	/* indicate it's queued */
+	if (!hcd-&gt;uses_new_polling)
+		mod_timer(&amp;hcd-&gt;rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));
+
+	/* If a status change has already occurred, report it ASAP */
+	else if (hcd-&gt;poll_pending)
+		mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
+	retval = 0;
+ done:
 	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
 	return retval;
 }
@@ -655,11 +657,16 @@ static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 /* Unlinks of root-hub control URBs are legal, but they don't do anything
  * since these URBs always execute synchronously.
  */
-static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	unsigned long	flags;
+	int		rc;
 
 	spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
@@ -669,14 +676,16 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;hcpriv = NULL;
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
 			usb_hcd_giveback_urb(hcd, urb);
 			spin_lock(&amp;hcd_root_hub_lock);
 		}
 	}
+ done:
 	spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
-	return 0;
+	return rc;
 }
 
 
@@ -977,12 +986,26 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 
 /*-------------------------------------------------------------------------*/
 
-static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
+/**
+ * usb_hcd_link_urb_to_ep - add an URB to its endpoint queue
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being submitted
+ *
+ * Host controller drivers should call this routine in their enqueue()
+ * method.  The HCD's private spinlock must be held and interrupts must
+ * be disabled.  The actions carried out here are required for URB
+ * submission, as well as for endpoint shutdown and for usb_kill_urb.
+ *
+ * Returns 0 for no error, otherwise a negative error code (in which case
+ * the enqueue() method must fail).  If no error occurs but enqueue() fails
+ * anyway, it must call usb_hcd_unlink_urb_from_ep() before releasing
+ * the private spinlock and returning.
+ */
+int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long	flags;
 	int		rc = 0;
 
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
 
 	/* Check that the URB isn't being killed */
 	if (unlikely(urb-&gt;reject)) {
@@ -1009,48 +1032,48 @@ static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 	}
  done:
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	return rc;
 }
+EXPORT_SYMBOL_GPL(usb_hcd_link_urb_to_ep);
 
-static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+/**
+ * usb_hcd_check_unlink_urb - check whether an URB may be unlinked
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being checked for unlinkability
+ * @status: error code to store in @urb if the unlink succeeds
+ *
+ * Host controller drivers should call this routine in their dequeue()
+ * method.  The HCD's private spinlock must be held and interrupts must
+ * be disabled.  The actions carried out here are required for making
+ * sure than an unlink is valid.
+ *
+ * Returns 0 for no error, otherwise a negative error code (in which case
+ * the dequeue() method must fail).  The possible error codes are:
+ *
+ *	-EIDRM: @urb was not submitted or has already completed.
+ *		The completion function may not have been called yet.
+ *
+ *	-EBUSY: @urb has already been unlinked.
+ */
+int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status)
 {
-	unsigned long		flags;
 	struct list_head	*tmp;
-	int			rc = 0;
-
-	/*
-	 * we contend for urb-&gt;status with the hcd core,
-	 * which changes it while returning the urb.
-	 *
-	 * Caller guaranteed that the urb pointer hasn't been freed, and
-	 * that it was submitted.  But as a rule it can't know whether or
-	 * not it's already been unlinked ... so we respect the reversed
-	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
-	 * unlinking it.
-	 */
-	spin_lock_irqsave(&amp;urb-&gt;lock, flags);
-	spin_lock(&amp;hcd_urb_list_lock);
 
 	/* insist the urb is still queued */
 	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
 		if (tmp == &amp;urb-&gt;urb_list)
 			break;
 	}
-	if (tmp != &amp;urb-&gt;urb_list) {
-		rc = -EIDRM;
-		goto done;
-	}
+	if (tmp != &amp;urb-&gt;urb_list)
+		return -EIDRM;
 
 	/* Any status except -EINPROGRESS means something already started to
 	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	if (urb-&gt;status != -EINPROGRESS) {
-		rc = -EBUSY;
-		goto done;
-	}
+	if (urb-&gt;status != -EINPROGRESS)
+		return -EBUSY;
 	urb-&gt;status = status;
 
 	/* IRQ setup can easily be broken so that USB controllers
@@ -1065,21 +1088,28 @@ static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 	}
 
- done:
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-	return rc;
+	return 0;
 }
+EXPORT_SYMBOL_GPL(usb_hcd_check_unlink_urb);
 
-static void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
+/**
+ * usb_hcd_unlink_urb_from_ep - remove an URB from its endpoint queue
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being unlinked
+ *
+ * Host controller drivers should call this routine before calling
+ * usb_hcd_giveback_urb().  The HCD's private spinlock must be held and
+ * interrupts must be disabled.  The actions carried out here are required
+ * for URB completion.
+ */
+void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long		flags;
-
 	/* clear all state linking urb to this dev (and hcd) */
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
 	list_del_init(&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+	spin_unlock(&amp;hcd_urb_list_lock);
 }
+EXPORT_SYMBOL_GPL(usb_hcd_unlink_urb_from_ep);
 
 static void map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
 {
@@ -1153,20 +1183,15 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	 * URBs must be submitted in process context with interrupts
 	 * enabled.
 	 */
-	status = usb_hcd_link_urb_to_ep(hcd, urb);
-	if (!status) {
-		map_urb_for_dma(hcd, urb);
-		if (is_root_hub(urb-&gt;dev))
-			status = rh_urb_enqueue(hcd, urb);
-		else
-			status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb-&gt;ep, urb,
-					mem_flags);
-	}
+	map_urb_for_dma(hcd, urb);
+	if (is_root_hub(urb-&gt;dev))
+		status = rh_urb_enqueue(hcd, urb);
+	else
+		status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb, mem_flags);
 
 	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
 		unmap_urb_for_dma(hcd, urb);
-		usb_hcd_unlink_urb_from_ep(hcd, urb);
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
 		if (urb-&gt;reject)
@@ -1183,24 +1208,19 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
  * soon as practical.  we've already set up the urb's return status,
  * but we can't know if the callback completed already.
  */
-static int
-unlink1 (struct usb_hcd *hcd, struct urb *urb)
+static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	int		value;
 
 	if (is_root_hub(urb-&gt;dev))
-		value = usb_rh_urb_dequeue (hcd, urb);
+		value = usb_rh_urb_dequeue(hcd, urb, status);
 	else {
 
 		/* The only reason an HCD might fail this call is if
 		 * it has not yet fully queued the urb to begin with.
 		 * Such failures should be harmless. */
-		value = hcd-&gt;driver-&gt;urb_dequeue (hcd, urb);
+		value = hcd-&gt;driver-&gt;urb_dequeue(hcd, urb, status);
 	}
-
-	if (value != 0)
-		dev_dbg (hcd-&gt;self.controller, "dequeue %p --&gt; %d\n",
-				urb, value);
 	return value;
 }
 
@@ -1216,14 +1236,11 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	int			retval;
 
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-
-	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
-	if (!retval)
-		retval = unlink1(hcd, urb);
+	retval = unlink1(hcd, urb, status);
 
 	if (retval == 0)
 		retval = -EINPROGRESS;
-	else if (retval != -EIDRM)
+	else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
 				urb, retval);
 	return retval;
@@ -1245,7 +1262,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	usb_hcd_unlink_urb_from_ep(hcd, urb);
 	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
@@ -1282,7 +1298,6 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 rescan:
 	spin_lock_irq(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
-		int	tmp;
 		int	is_in;
 
 		/* the urb may already have been unlinked */
@@ -1292,34 +1307,26 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		is_in = usb_urb_dir_in(urb);
 		spin_unlock(&amp;hcd_urb_list_lock);
 
-		spin_lock (&amp;urb-&gt;lock);
-		tmp = urb-&gt;status;
-		if (tmp == -EINPROGRESS)
-			urb-&gt;status = -ESHUTDOWN;
-		spin_unlock (&amp;urb-&gt;lock);
-
-		/* kick hcd unless it's already returning this */
-		if (tmp == -EINPROGRESS) {
-			unlink1 (hcd, urb);
-			dev_dbg (hcd-&gt;self.controller,
-				"shutdown urb %p ep%d%s%s\n",
-				urb, usb_endpoint_num(&amp;ep-&gt;desc),
-				is_in ? "in" : "out",
-				({	char *s;
-
-					switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
-					case USB_ENDPOINT_XFER_CONTROL:
-						s = ""; break;
-					case USB_ENDPOINT_XFER_BULK:
-						s = "-bulk"; break;
-					case USB_ENDPOINT_XFER_INT:
-						s = "-intr"; break;
-					default:
-				 		s = "-iso"; break;
-					};
-					s;
-				}));
-		}
+		/* kick hcd */
+		unlink1(hcd, urb, -ESHUTDOWN);
+		dev_dbg (hcd-&gt;self.controller,
+			"shutdown urb %p ep%d%s%s\n",
+			urb, usb_endpoint_num(&amp;ep-&gt;desc),
+			is_in ? "in" : "out",
+			({	char *s;
+
+				 switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
+				 case USB_ENDPOINT_XFER_CONTROL:
+					s = ""; break;
+				 case USB_ENDPOINT_XFER_BULK:
+					s = "-bulk"; break;
+				 case USB_ENDPOINT_XFER_INT:
+					s = "-intr"; break;
+				 default:
+			 		s = "-iso"; break;
+				};
+				s;
+			}));
 		usb_put_urb (urb);
 
 		/* list contents may have changed */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 8683142e70e1..745be2566f62 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -189,11 +189,10 @@ struct hc_driver {
 	int	(*get_frame_number) (struct usb_hcd *hcd);
 
 	/* manage i/o requests, device state */
-	int	(*urb_enqueue) (struct usb_hcd *hcd,
-					struct usb_host_endpoint *ep,
-					struct urb *urb,
-					gfp_t mem_flags);
-	int	(*urb_dequeue) (struct usb_hcd *hcd, struct urb *urb);
+	int	(*urb_enqueue)(struct usb_hcd *hcd,
+				struct urb *urb, gfp_t mem_flags);
+	int	(*urb_dequeue)(struct usb_hcd *hcd,
+				struct urb *urb, int status);
 
 	/* hw synch, freeing endpoint resources that urb_dequeue can't */
 	void 	(*endpoint_disable)(struct usb_hcd *hcd,
@@ -211,6 +210,11 @@ struct hc_driver {
 		/* Needed only if port-change IRQs are level-triggered */
 };
 
+extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
+extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
+extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb);
+
 extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb (struct urb *urb, int status);
 extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index d008d1360a7a..c441d10c087e 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -962,13 +962,13 @@ static struct platform_driver dummy_udc_driver = {
 
 static int dummy_urb_enqueue (
 	struct usb_hcd			*hcd,
-	struct usb_host_endpoint	*ep,
 	struct urb			*urb,
 	gfp_t				mem_flags
 ) {
 	struct dummy	*dum;
 	struct urbp	*urbp;
 	unsigned long	flags;
+	int		rc;
 
 	if (!urb-&gt;transfer_buffer &amp;&amp; urb-&gt;transfer_buffer_length)
 		return -EINVAL;
@@ -980,6 +980,11 @@ static int dummy_urb_enqueue (
 
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	rc = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (rc) {
+		kfree(urbp);
+		goto done;
+	}
 
 	if (!dum-&gt;udev) {
 		dum-&gt;udev = urb-&gt;dev;
@@ -997,22 +1002,28 @@ static int dummy_urb_enqueue (
 		mod_timer (&amp;dum-&gt;timer, jiffies + 1);
 
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
-	return 0;
+ done:
+	return rc;
 }
 
-static int dummy_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct dummy	*dum;
 	unsigned long	flags;
+	int		rc;
 
 	/* giveback happens automatically in timer callback,
 	 * so make sure the callback happens */
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	if (dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp; !list_empty(&amp;dum-&gt;urbp_list))
+
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (!rc &amp;&amp; dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp;
+			!list_empty(&amp;dum-&gt;urbp_list))
 		mod_timer (&amp;dum-&gt;timer, jiffies);
+
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void maybe_set_status (struct urb *urb, int status)
@@ -1511,6 +1522,7 @@ static void dummy_timer (unsigned long _dum)
 		if (ep)
 			ep-&gt;already_seen = ep-&gt;setup_stage = 0;
 
+		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
 		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
 		spin_lock (&amp;dum-&gt;lock);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 35cdba10411b..db00492588b6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -719,7 +719,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
  */
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -734,12 +733,12 @@ static int ehci_urb_enqueue (
 	default:
 		if (!qh_urb_transaction (ehci, urb, &amp;qtd_list, mem_flags))
 			return -ENOMEM;
-		return submit_async (ehci, ep, urb, &amp;qtd_list, mem_flags);
+		return submit_async(ehci, urb, &amp;qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
 		if (!qh_urb_transaction (ehci, urb, &amp;qtd_list, mem_flags))
 			return -ENOMEM;
-		return intr_submit (ehci, ep, urb, &amp;qtd_list, mem_flags);
+		return intr_submit(ehci, urb, &amp;qtd_list, mem_flags);
 
 	case PIPE_ISOCHRONOUS:
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH)
@@ -777,13 +776,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
  * completions normally happen asynchronously
  */
 
-static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct ehci_qh		*qh;
 	unsigned long		flags;
+	int			rc;
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	switch (usb_pipetype (urb-&gt;pipe)) {
 	// case PIPE_CONTROL:
 	// case PIPE_BULK:
@@ -838,7 +842,7 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 	}
 done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 140bfa423e07..1da2de4d34ed 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -262,6 +262,7 @@ __acquires(ehci-&gt;lock)
 #endif
 
 	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
 	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
 	spin_lock (&amp;ehci-&gt;lock);
@@ -913,7 +914,6 @@ static struct ehci_qh *qh_append_tds (
 static int
 submit_async (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -922,10 +922,10 @@ submit_async (
 	int			epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh = NULL;
-	int			rc = 0;
+	int			rc;
 
 	qtd = list_entry (qtd_list-&gt;next, struct ehci_qtd, qtd_list);
-	epnum = ep-&gt;desc.bEndpointAddress;
+	epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
@@ -933,7 +933,7 @@ submit_async (
 		__FUNCTION__, urb-&gt;dev-&gt;devpath, urb,
 		epnum &amp; 0x0f, (epnum &amp; USB_DIR_IN) ? "in" : "out",
 		urb-&gt;transfer_buffer_length,
-		qtd, ep-&gt;hcpriv);
+		qtd, urb-&gt;ep-&gt;hcpriv);
 #endif
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
@@ -942,9 +942,13 @@ submit_async (
 		rc = -ESHUTDOWN;
 		goto done;
 	}
+	rc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(rc))
+		goto done;
 
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	if (unlikely(qh == NULL)) {
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 		rc = -ENOMEM;
 		goto done;
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index e682f2342ef8..8b267b3fd2bb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -797,7 +797,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static int intr_submit (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -805,23 +804,26 @@ static int intr_submit (
 	unsigned		epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh;
-	int			status = 0;
+	int			status;
 	struct list_head	empty;
 
 	/* get endpoint and transfer/schedule data */
-	epnum = ep-&gt;desc.bEndpointAddress;
+	epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
 			&amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-		goto done;
+		goto done_not_linked;
 	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
 
 	/* get qh and force any scheduling errors */
 	INIT_LIST_HEAD (&amp;empty);
-	qh = qh_append_tds (ehci, urb, &amp;empty, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, &amp;empty, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	if (qh == NULL) {
 		status = -ENOMEM;
 		goto done;
@@ -832,13 +834,16 @@ static int intr_submit (
 	}
 
 	/* then queue the urb's tds to the qh */
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	BUG_ON (qh == NULL);
 
 	/* ... update usbfs periodic stats */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_int_reqs++;
 
 done:
+	if (unlikely(status))
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	if (status)
 		qtd_list_free (ehci, urb, qtd_list);
@@ -1686,12 +1691,19 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags)))
+			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (likely (status == 0))
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 done:
@@ -2049,12 +2061,19 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags)))
+			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (status == 0)
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 done:
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 5c851a36de72..d5027dc75a57 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -290,6 +290,7 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 
 	urb_dbg(urb, "Finish");
 
+	usb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);
 	spin_unlock(&amp;isp116x-&gt;lock);
 	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
 	spin_lock(&amp;isp116x-&gt;lock);
@@ -673,7 +674,7 @@ static int balance(struct isp116x *isp116x, u16 period, u16 load)
 /*-----------------------------------------------------------------*/
 
 static int isp116x_urb_enqueue(struct usb_hcd *hcd,
-			       struct usb_host_endpoint *hep, struct urb *urb,
+			       struct urb *urb,
 			       gfp_t mem_flags)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
@@ -682,6 +683,7 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	int is_out = !usb_pipein(pipe);
 	int type = usb_pipetype(pipe);
 	int epnum = usb_pipeendpoint(pipe);
+	struct usb_host_endpoint *hep = urb-&gt;ep;
 	struct isp116x_ep *ep = NULL;
 	unsigned long flags;
 	int i;
@@ -705,7 +707,12 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	if (!HC_IS_RUNNING(hcd-&gt;state)) {
 		kfree(ep);
 		ret = -ENODEV;
-		goto fail;
+		goto fail_not_linked;
+	}
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep-&gt;hcpriv)
@@ -818,6 +825,9 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	start_atl_transfers(isp116x);
 
       fail:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+      fail_not_linked:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 	return ret;
 }
@@ -825,20 +835,21 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 /*
    Dequeue URBs.
 */
-static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	struct usb_host_endpoint *hep;
 	struct isp116x_ep *ep, *ep_act;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&amp;isp116x-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	hep = urb-&gt;hcpriv;
-	/* URB already unlinked (or never linked)? */
-	if (!hep) {
-		spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-		return 0;
-	}
 	ep = hep-&gt;hcpriv;
 	WARN_ON(hep != ep-&gt;hep);
 
@@ -856,9 +867,9 @@ static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 
 	if (urb)
 		finish_request(isp116x, ep, urb);
-
+ done:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void isp116x_endpoint_disable(struct usb_hcd *hcd,
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index d673cb9c36b1..6b06ab69938f 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -117,7 +117,6 @@ MODULE_PARM_DESC (no_handshake, "true (not default) disables BIOS handshake");
  */
 static int ohci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -134,7 +133,7 @@ static int ohci_urb_enqueue (
 #endif
 
 	/* every endpoint has a ed, locate and maybe (re)initialize it */
-	if (! (ed = ed_get (ohci, ep, urb-&gt;dev, pipe, urb-&gt;interval)))
+	if (! (ed = ed_get (ohci, urb-&gt;ep, urb-&gt;dev, pipe, urb-&gt;interval)))
 		return -ENOMEM;
 
 	/* for the private part of the URB we need the number of TDs (size) */
@@ -199,22 +198,17 @@ static int ohci_urb_enqueue (
 		retval = -ENODEV;
 		goto fail;
 	}
-
-	/* in case of unlink-during-submit */
-	spin_lock (&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock (&amp;urb-&gt;lock);
-		urb-&gt;hcpriv = urb_priv;
-		finish_urb (ohci, urb);
-		retval = 0;
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
 		goto fail;
-	}
 
 	/* schedule the ed if needed */
 	if (ed-&gt;state == ED_IDLE) {
 		retval = ed_schedule (ohci, ed);
-		if (retval &lt; 0)
-			goto fail0;
+		if (retval &lt; 0) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			goto fail;
+		}
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 			u16	frame = ohci_frame_no(ohci);
 
@@ -238,8 +232,6 @@ static int ohci_urb_enqueue (
 	urb-&gt;hcpriv = urb_priv;
 	td_submit_urb (ohci, urb);
 
-fail0:
-	spin_unlock (&amp;urb-&gt;lock);
 fail:
 	if (retval)
 		urb_free_priv (ohci, urb_priv);
@@ -253,17 +245,21 @@ static int ohci_urb_enqueue (
  * asynchronously, and we might be dealing with an urb that's
  * partially transferred, or an ED with other urbs being unlinked.
  */
-static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	unsigned long		flags;
+	int			rc;
 
 #ifdef OHCI_VERBOSE_DEBUG
 	urb_print (urb, "UNLINK", 1);
 #endif
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	if (HC_IS_RUNNING(hcd-&gt;state)) {
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc) {
+		;	/* Do nothing */
+	} else if (HC_IS_RUNNING(hcd-&gt;state)) {
 		urb_priv_t  *urb_priv;
 
 		/* Unless an IRQ completed the unlink while it was being
@@ -284,7 +280,7 @@ static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 			finish_urb (ohci, urb);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 547d39be3eb9..889c0720743b 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -74,6 +74,7 @@ __acquires(ohci-&gt;lock)
 #endif
 
 	/* urb-&gt;complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
 	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
 	spin_lock (&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 40a1de4c256e..94bb229df3bc 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -784,6 +784,9 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 		if (urb) {
 			urb-&gt;status = -ENODEV;
 			urb-&gt;hcpriv = NULL;
+			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
+					urb);
+
 			spin_unlock(&amp;r8a66597-&gt;lock);
 			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
 			spin_lock(&amp;r8a66597-&gt;lock);
@@ -1131,6 +1134,8 @@ static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
 		urb-&gt;hcpriv = NULL;
+		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
+
 		spin_unlock(&amp;r8a66597-&gt;lock);
 		usb_hcd_giveback_urb(hcd, urb);
 		spin_lock(&amp;r8a66597-&gt;lock);
@@ -1722,21 +1727,25 @@ static struct r8a66597_td *r8a66597_make_td(struct r8a66597 *r8a66597,
 }
 
 static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
-				struct usb_host_endpoint *hep,
 				struct urb *urb,
 				gfp_t mem_flags)
 {
+	struct usb_host_endpoint *hep = urb-&gt;ep;
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td = NULL;
-	int ret = 0, request = 0;
+	int ret, request = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;r8a66597-&gt;lock, flags);
 	if (!get_urb_to_r8a66597_dev(r8a66597, urb)) {
 		ret = -ENODEV;
-		goto error;
+		goto error_not_linked;
 	}
 
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto error_not_linked;
+
 	if (!hep-&gt;hcpriv) {
 		hep-&gt;hcpriv = kzalloc(sizeof(struct r8a66597_pipe),
 				GFP_ATOMIC);
@@ -1761,15 +1770,7 @@ static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
 	if (list_empty(&amp;r8a66597-&gt;pipe_queue[td-&gt;pipenum]))
 		request = 1;
 	list_add_tail(&amp;td-&gt;queue, &amp;r8a66597-&gt;pipe_queue[td-&gt;pipenum]);
-
-	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
-		ret = -EPIPE;
-		goto error;
-	}
 	urb-&gt;hcpriv = td;
-	spin_unlock(&amp;urb-&gt;lock);
 
 	if (request) {
 		ret = start_transfer(r8a66597, td);
@@ -1781,17 +1782,26 @@ static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
 		set_td_timer(r8a66597, td);
 
 error:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+error_not_linked:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
 	return ret;
 }
 
-static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&amp;r8a66597-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	if (urb-&gt;hcpriv) {
 		td = urb-&gt;hcpriv;
 		pipe_stop(r8a66597, td-&gt;pipe);
@@ -1799,8 +1809,9 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
 		done(r8a66597, td, td-&gt;pipenum, urb);
 	}
+ done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 4cfa3ff2c993..3d3a63d002c5 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -441,6 +441,7 @@ static void finish_request(
 	urb-&gt;hcpriv = NULL;
 	spin_unlock(&amp;urb-&gt;lock);
 
+	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
 	spin_unlock(&amp;sl811-&gt;lock);
 	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
 	spin_lock(&amp;sl811-&gt;lock);
@@ -807,7 +808,6 @@ static int balance(struct sl811 *sl811, u16 period, u16 load)
 
 static int sl811h_urb_enqueue(
 	struct usb_hcd		*hcd,
-	struct usb_host_endpoint *hep,
 	struct urb		*urb,
 	gfp_t			mem_flags
 ) {
@@ -820,7 +820,8 @@ static int sl811h_urb_enqueue(
 	struct sl811h_ep	*ep = NULL;
 	unsigned long		flags;
 	int			i;
-	int			retval = 0;
+	int			retval;
+	struct usb_host_endpoint	*hep = urb-&gt;ep;
 
 #ifdef	DISABLE_ISO
 	if (type == PIPE_ISOCHRONOUS)
@@ -838,7 +839,12 @@ static int sl811h_urb_enqueue(
 			|| !HC_IS_RUNNING(hcd-&gt;state)) {
 		retval = -ENODEV;
 		kfree(ep);
-		goto fail;
+		goto fail_not_linked;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep-&gt;hcpriv) {
@@ -965,23 +971,27 @@ static int sl811h_urb_enqueue(
 	start_transfer(sl811);
 	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811-&gt;irq_enable);
 fail:
+	if (retval)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+fail_not_linked:
 	spin_unlock_irqrestore(&amp;sl811-&gt;lock, flags);
 	return retval;
 }
 
-static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct sl811		*sl811 = hcd_to_sl811(hcd);
 	struct usb_host_endpoint *hep;
 	unsigned long		flags;
 	struct sl811h_ep	*ep;
-	int			retval = 0;
+	int			retval;
 
 	spin_lock_irqsave(&amp;sl811-&gt;lock, flags);
-	hep = urb-&gt;hcpriv;
-	if (!hep)
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
 		goto fail;
 
+	hep = urb-&gt;hcpriv;
 	ep = hep-&gt;hcpriv;
 	if (ep) {
 		/* finish right away if this urb can't be active ...
@@ -1029,8 +1039,8 @@ static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 			VDBG("dequeue, urb %p active %s; wait4irq\n", urb,
 				(sl811-&gt;active_a == ep) ? "A" : "B");
 	} else
-fail:
 		retval = -EINVAL;
+ fail:
 	spin_unlock_irqrestore(&amp;sl811-&gt;lock, flags);
 	return retval;
 }
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 598ad098aeeb..c87660b5edc3 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -521,6 +521,7 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         urb-&gt;status = status;
         urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
         if (ENDP_QUEUE_SIZE &gt; --endp-&gt;queue_size) {
                 endp-&gt;active = 0;
@@ -561,6 +562,7 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         urb-&gt;status = status;
         urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
         if (ENDP_QUEUE_SIZE &gt; --endp-&gt;queue_size) {
                 endp-&gt;active = 0;
@@ -1876,20 +1878,32 @@ static int u132_hcd_reset(struct usb_hcd *hcd)
 }
 
 static int create_endpoint_and_queue_int(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
         gfp_t mem_flags)
 {
         struct u132_ring *ring;
         unsigned long irqs;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         ring = endp-&gt;ring = &amp;u132-&gt;ring[0];
         if (ring-&gt;curr_endp) {
@@ -1905,7 +1919,7 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         endp-&gt;pipetype = usb_pipetype(urb-&gt;pipe);
         u132_endp_init_kref(u132, endp);
         if (usb_pipein(urb-&gt;pipe)) {
@@ -1924,7 +1938,6 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
                 u132_udev_get_kref(u132, udev);
         }
         urb-&gt;hcpriv = u132;
-        spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
         endp-&gt;delayed = 1;
         endp-&gt;jiffies = jiffies + msecs_to_jiffies(urb-&gt;interval);
         endp-&gt;udev_number = address;
@@ -1939,8 +1952,8 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
         return 0;
 }
 
-static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-        struct usb_host_endpoint *hep, struct urb *urb,
+static int queue_int_on_old_endpoint(struct u132 *u132,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp, u8 address)
 {
@@ -1964,21 +1977,33 @@ static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
 }
 
 static int create_endpoint_and_queue_bulk(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
         gfp_t mem_flags)
 {
         int ring_number;
         struct u132_ring *ring;
         unsigned long irqs;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         endp-&gt;dequeueing = 0;
         endp-&gt;edset_flush = 0;
@@ -1986,7 +2011,7 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         endp-&gt;pipetype = usb_pipetype(urb-&gt;pipe);
         u132_endp_init_kref(u132, endp);
         if (usb_pipein(urb-&gt;pipe)) {
@@ -2015,7 +2040,6 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
         }
         ring-&gt;length += 1;
         urb-&gt;hcpriv = u132;
-        spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
         endp-&gt;udev_number = address;
         endp-&gt;usb_addr = usb_addr;
         endp-&gt;usb_endp = usb_endp;
@@ -2029,7 +2053,7 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
 }
 
 static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-         struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp, u8 address)
 {
@@ -2051,19 +2075,32 @@ static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
 }
 
 static int create_endpoint_and_queue_control(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,
         gfp_t mem_flags)
 {
         struct u132_ring *ring;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	unsigned long irqs;
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         ring = endp-&gt;ring = &amp;u132-&gt;ring[0];
         if (ring-&gt;curr_endp) {
@@ -2079,11 +2116,10 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         u132_endp_init_kref(u132, endp);
         u132_endp_get_kref(u132, endp);
         if (usb_addr == 0) {
-                unsigned long irqs;
                 u8 address = u132-&gt;addr[usb_addr].address;
                 struct u132_udev *udev = &amp;u132-&gt;udev[address];
                 endp-&gt;udev_number = address;
@@ -2097,7 +2133,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 udev-&gt;endp_number_in[usb_endp] = endp_number;
                 udev-&gt;endp_number_out[usb_endp] = endp_number;
                 urb-&gt;hcpriv = u132;
-                spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
                 endp-&gt;queue_size = 1;
                 endp-&gt;queue_last = 0;
                 endp-&gt;queue_next = 0;
@@ -2106,7 +2141,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 u132_endp_queue_work(u132, endp, 0);
                 return 0;
         } else {                /*(usb_addr &gt; 0) */
-                unsigned long irqs;
                 u8 address = u132-&gt;addr[usb_addr].address;
                 struct u132_udev *udev = &amp;u132-&gt;udev[address];
                 endp-&gt;udev_number = address;
@@ -2120,7 +2154,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 udev-&gt;endp_number_in[usb_endp] = endp_number;
                 udev-&gt;endp_number_out[usb_endp] = endp_number;
                 urb-&gt;hcpriv = u132;
-                spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
                 endp-&gt;queue_size = 1;
                 endp-&gt;queue_last = 0;
                 endp-&gt;queue_next = 0;
@@ -2132,7 +2165,7 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
 }
 
 static int queue_control_on_old_endpoint(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp)
 {
@@ -2232,8 +2265,8 @@ static int queue_control_on_old_endpoint(struct u132 *u132,
         }
 }
 
-static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
-        struct urb *urb, gfp_t mem_flags)
+static int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
 {
         struct u132 *u132 = hcd_to_u132(hcd);
         if (irqs_disabled()) {
@@ -2258,16 +2291,24 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                 if (usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT) {
                         u8 address = u132-&gt;addr[usb_addr].address;
                         struct u132_udev *udev = &amp;u132-&gt;udev[address];
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         urb-&gt;actual_length = 0;
                         if (endp) {
                                 unsigned long irqs;
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_int_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_int_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2282,8 +2323,8 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else {        /*(endp == NULL) */
                                 return create_endpoint_and_queue_int(u132, udev,
-                                         hep, urb, usb_dev, usb_addr, usb_endp,
-                                        address, mem_flags);
+						urb, usb_dev, usb_addr,
+						usb_endp, address, mem_flags);
                         }
                 } else if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
                         dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "the hardware does no"
@@ -2292,16 +2333,24 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                 } else if (usb_pipetype(urb-&gt;pipe) == PIPE_BULK) {
                         u8 address = u132-&gt;addr[usb_addr].address;
                         struct u132_udev *udev = &amp;u132-&gt;udev[address];
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         urb-&gt;actual_length = 0;
                         if (endp) {
                                 unsigned long irqs;
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_bulk_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_bulk_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2314,10 +2363,10 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else
                                 return create_endpoint_and_queue_bulk(u132,
-                                        udev, hep, urb, usb_dev, usb_addr,
+					udev, urb, usb_dev, usb_addr,
                                         usb_endp, address, mem_flags);
                 } else {
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         u16 urb_size = 8;
                         u8 *b = urb-&gt;setup_packet;
                         int i = 0;
@@ -2340,9 +2389,16 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_control_on_old_endpoint(u132,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_control_on_old_endpoint(
+							u132, urb, usb_dev,
+							endp, usb_addr,
+							usb_endp);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2355,7 +2411,7 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else
                                 return create_endpoint_and_queue_control(u132,
-                                        hep, urb, usb_dev, usb_addr, usb_endp,
+					urb, usb_dev, usb_addr, usb_endp,
                                         mem_flags);
                 }
         }
@@ -2390,10 +2446,17 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
 }
 
 static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb)
+		struct urb *urb, int status)
 {
         unsigned long irqs;
+	int rc;
+
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_check_unlink_urb(u132_to_hcd(u132), urb, status);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		return rc;
+	}
         if (endp-&gt;queue_size == 0) {
                 dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "urb=%p not found in endp[%d]"
                         "=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,
@@ -2438,6 +2501,8 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                 }
                 if (urb_slot) {
                         struct usb_hcd *hcd = u132_to_hcd(u132);
+
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
                         endp-&gt;queue_size -= 1;
                         if (list_empty(&amp;endp-&gt;urb_more)) {
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
@@ -2467,7 +2532,10 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                         return -EINVAL;
                 } else {
-                        int retval = dequeue_from_overflow_chain(u132, endp,
+			int retval;
+
+			usb_hcd_unlink_urb_from_ep(u132_to_hcd(u132), urb);
+			retval = dequeue_from_overflow_chain(u132, endp,
                                 urb);
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                         return retval;
@@ -2475,7 +2543,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
         }
 }
 
-static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
         struct u132 *u132 = hcd_to_u132(hcd);
         if (u132-&gt;going &gt; 2) {
@@ -2490,11 +2558,11 @@ static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
                 if (usb_pipein(urb-&gt;pipe)) {
                         u8 endp_number = udev-&gt;endp_number_in[usb_endp];
                         struct u132_endp *endp = u132-&gt;endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
+                        return u132_endp_urb_dequeue(u132, endp, urb, status);
                 } else {
                         u8 endp_number = udev-&gt;endp_number_out[usb_endp];
                         struct u132_endp *endp = u132-&gt;endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
+                        return u132_endp_urb_dequeue(u132, endp, urb, status);
                 }
         }
 }
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 3bb908ca38e9..bff200cb3d2e 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1376,7 +1376,6 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
-		struct usb_host_endpoint *hep,
 		struct urb *urb, gfp_t mem_flags)
 {
 	int ret;
@@ -1387,19 +1386,19 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
-	ret = urb-&gt;status;
-	if (ret != -EINPROGRESS)		/* URB already unlinked! */
-		goto done;
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto done_not_linked;
 
 	ret = -ENOMEM;
 	urbp = uhci_alloc_urb_priv(uhci, urb);
 	if (!urbp)
 		goto done;
 
-	if (hep-&gt;hcpriv)
-		qh = (struct uhci_qh *) hep-&gt;hcpriv;
+	if (urb-&gt;ep-&gt;hcpriv)
+		qh = urb-&gt;ep-&gt;hcpriv;
 	else {
-		qh = uhci_alloc_qh(uhci, urb-&gt;dev, hep);
+		qh = uhci_alloc_qh(uhci, urb-&gt;dev, urb-&gt;ep);
 		if (!qh)
 			goto err_no_qh;
 	}
@@ -1440,27 +1439,29 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 err_submit_failed:
 	if (qh-&gt;state == QH_STATE_IDLE)
 		uhci_make_qh_idle(uhci, qh);	/* Reclaim unused QH */
-
 err_no_qh:
 	uhci_free_urb_priv(uhci, urbp);
-
 done:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+done_not_linked:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 	return ret;
 }
 
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	struct urb_priv *urbp;
 	struct uhci_qh *qh;
+	int rc;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	urbp = urb-&gt;hcpriv;
-	if (!urbp)			/* URB was never linked! */
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
 		goto done;
-	qh = urbp-&gt;qh;
+
+	qh = ((struct urb_priv *) urb-&gt;hcpriv)-&gt;qh;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
@@ -1477,7 +1478,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 
 done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*
@@ -1529,6 +1530,7 @@ __acquires(uhci-&gt;lock)
 	}
 
 	uhci_free_urb_priv(uhci, urbp);
+	usb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);
 
 	spin_unlock(&amp;uhci-&gt;lock);
 	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);</pre><hr><pre>commit 9a9bf406df3ce238089d14f4cb41157ca56d8ad3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:06:54 2007 -0400

    USB: separate out endpoint queue management and DMA mapping routines
    
    This patch (as953) separates out three key portions from
    usb_hcd_submit_urb(), usb_hcd_unlink_urb(), and usb_hcd_giveback_urb()
    and puts them in separate functions of their own.  In the next patch,
    these functions will be called directly by host controller drivers
    while holding their private spinlocks, which will remove the
    possibility of some unpleasant races.
    
    The code responsible for mapping and unmapping DMA buffers is also
    placed into a couple of separate subroutines, for the sake of
    cleanliness and consistency.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index f8e7deb03ee9..eb2121788264 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -914,99 +914,117 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 
 /*-------------------------------------------------------------------------*/
 
-static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
+static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long		flags;
+	unsigned long	flags;
+	int		rc = 0;
 
-	/* clear all state linking urb to this dev (and hcd) */
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	list_del_init (&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
-	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
-		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
-			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
-					sizeof (struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
-		if (urb-&gt;transfer_buffer_length != 0
-			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
-			dma_unmap_single (hcd-&gt;self.controller,
-					urb-&gt;transfer_dma,
-					urb-&gt;transfer_buffer_length,
-					usb_urb_dir_in(urb)
-					    ? DMA_FROM_DEVICE
-					    : DMA_TO_DEVICE);
+	/* Check that the URB isn't being killed */
+	if (unlikely(urb-&gt;reject)) {
+		rc = -EPERM;
+		goto done;
 	}
-}
-
-/* may be called in any context with a valid urb-&gt;dev usecount
- * caller surrenders "ownership" of urb
- * expects usb_submit_urb() to have sanity checked and conditioned all
- * inputs in the urb
- */
-int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
-{
-	int			status;
-	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	unsigned long		flags;
-
-	if (!hcd)
-		return -ENODEV;
 
-	usbmon_urb_submit(&amp;hcd-&gt;self, urb);
+	if (unlikely(!urb-&gt;ep-&gt;enabled)) {
+		rc = -ENOENT;
+		goto done;
+	}
 
 	/*
-	 * Atomically queue the urb,  first to our records, then to the HCD.
-	 * Access to urb-&gt;status is controlled by urb-&gt;lock ... changes on
-	 * i/o completion (normal or fault) or unlinking.
+	 * Check the host controller's state and add the URB to the
+	 * endpoint's queue.
 	 */
-
-	// FIXME:  verify that quiescing hc works right (RH cleans up)
-
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	if (unlikely(!urb-&gt;ep-&gt;enabled))
-		status = -ENOENT;
-	else if (unlikely (urb-&gt;reject))
-		status = -EPERM;
-	else switch (hcd-&gt;state) {
+	switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
-		list_add_tail (&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
-		status = 0;
+		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		break;
 	default:
-		status = -ESHUTDOWN;
-		break;
+		rc = -ESHUTDOWN;
+		goto done;
 	}
+ done:
 	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
-	if (status) {
-		INIT_LIST_HEAD (&amp;urb-&gt;urb_list);
-		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		return status;
+	return rc;
+}
+
+static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status)
+{
+	unsigned long		flags;
+	struct list_head	*tmp;
+	int			rc = 0;
+
+	/*
+	 * we contend for urb-&gt;status with the hcd core,
+	 * which changes it while returning the urb.
+	 *
+	 * Caller guaranteed that the urb pointer hasn't been freed, and
+	 * that it was submitted.  But as a rule it can't know whether or
+	 * not it's already been unlinked ... so we respect the reversed
+	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
+	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
+	 * unlinking it.
+	 */
+	spin_lock_irqsave(&amp;urb-&gt;lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
+
+	/* insist the urb is still queued */
+	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
+		if (tmp == &amp;urb-&gt;urb_list)
+			break;
+	}
+	if (tmp != &amp;urb-&gt;urb_list) {
+		rc = -EIDRM;
+		goto done;
 	}
 
-	/* increment urb's reference count as part of giving it to the HCD
-	 * (which now controls it).  HCD guarantees that it either returns
-	 * an error or calls giveback(), but not both.
+	/* Any status except -EINPROGRESS means something already started to
+	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	urb = usb_get_urb (urb);
-	atomic_inc (&amp;urb-&gt;use_count);
-
-	if (is_root_hub(urb-&gt;dev)) {
-		/* NOTE:  requirement on hub callers (usbfs and the hub
-		 * driver, for now) that URBs' urb-&gt;transfer_buffer be
-		 * valid and usb_buffer_{sync,unmap}() not be needed, since
-		 * they could clobber root hub response data.
-		 */
-		status = rh_urb_enqueue (hcd, urb);
+	if (urb-&gt;status != -EINPROGRESS) {
+		rc = -EBUSY;
 		goto done;
 	}
+	urb-&gt;status = status;
+
+	/* IRQ setup can easily be broken so that USB controllers
+	 * never get completion IRQs ... maybe even the ones we need to
+	 * finish unlinking the initial failed usb_set_address()
+	 * or device descriptor fetch.
+	 */
+	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
+			!is_root_hub(urb-&gt;dev)) {
+		dev_warn(hcd-&gt;self.controller, "Unlink after no-IRQ?  "
+			"Controller is probably using the wrong IRQ.\n");
+		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
+	}
+
+ done:
+	spin_unlock(&amp;hcd_urb_list_lock);
+	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
+	return rc;
+}
+
+static void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
+{
+	unsigned long		flags;
 
-	/* lower level hcd code should use *_dma exclusively,
+	/* clear all state linking urb to this dev (and hcd) */
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	list_del_init(&amp;urb-&gt;urb_list);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+}
+
+static void map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	/* Map the URB's buffers for DMA access.
+	 * Lower level HCD code should use *_dma exclusively,
 	 * unless it uses pio or talks to another transport.
 	 */
-	if (hcd-&gt;self.uses_dma) {
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
 		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
@@ -1024,16 +1042,73 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
+}
 
-	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, urb-&gt;ep, urb, mem_flags);
-done:
-	if (unlikely (status)) {
-		urb_unlink(hcd, urb);
-		atomic_dec (&amp;urb-&gt;use_count);
-		if (urb-&gt;reject)
-			wake_up (&amp;usb_kill_urb_queue);
+static void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
+			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
+			dma_unmap_single(hcd-&gt;self.controller, urb-&gt;setup_dma,
+					sizeof(struct usb_ctrlrequest),
+					DMA_TO_DEVICE);
+		if (urb-&gt;transfer_buffer_length != 0
+			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
+			dma_unmap_single(hcd-&gt;self.controller,
+					urb-&gt;transfer_dma,
+					urb-&gt;transfer_buffer_length,
+					usb_urb_dir_in(urb)
+					    ? DMA_FROM_DEVICE
+					    : DMA_TO_DEVICE);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* may be called in any context with a valid urb-&gt;dev usecount
+ * caller surrenders "ownership" of urb
+ * expects usb_submit_urb() to have sanity checked and conditioned all
+ * inputs in the urb
+ */
+int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
+{
+	int			status;
+	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
+
+	/* increment urb's reference count as part of giving it to the HCD
+	 * (which will control it).  HCD guarantees that it either returns
+	 * an error or calls giveback(), but not both.
+	 */
+	usb_get_urb(urb);
+	atomic_inc(&amp;urb-&gt;use_count);
+	usbmon_urb_submit(&amp;hcd-&gt;self, urb);
+
+	/* NOTE requirements on root-hub callers (usbfs and the hub
+	 * driver, for now):  URBs' urb-&gt;transfer_buffer must be
+	 * valid and usb_buffer_{sync,unmap}() not be needed, since
+	 * they could clobber root hub response data.  Also, control
+	 * URBs must be submitted in process context with interrupts
+	 * enabled.
+	 */
+	status = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (!status) {
+		map_urb_for_dma(hcd, urb);
+		if (is_root_hub(urb-&gt;dev))
+			status = rh_urb_enqueue(hcd, urb);
+		else
+			status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb-&gt;ep, urb,
+					mem_flags);
+	}
+
+	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		usb_put_urb (urb);
+		unmap_urb_for_dma(hcd, urb);
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
+		atomic_dec(&amp;urb-&gt;use_count);
+		if (urb-&gt;reject)
+			wake_up(&amp;usb_kill_urb_queue);
+		usb_put_urb(urb);
 	}
 	return status;
 }
@@ -1074,78 +1149,20 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  */
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
-	struct usb_hcd			*hcd = NULL;
-	struct device			*sys = NULL;
-	unsigned long			flags;
-	struct list_head		*tmp;
-	int				retval;
-
-	/*
-	 * we contend for urb-&gt;status with the hcd core,
-	 * which changes it while returning the urb.
-	 *
-	 * Caller guaranteed that the urb pointer hasn't been freed, and
-	 * that it was submitted.  But as a rule it can't know whether or
-	 * not it's already been unlinked ... so we respect the reversed
-	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
-	 * unlinking it.
-	 */
-	spin_lock_irqsave (&amp;urb-&gt;lock, flags);
-	spin_lock(&amp;hcd_urb_list_lock);
+	struct usb_hcd		*hcd;
+	int			retval;
 
-	sys = &amp;urb-&gt;dev-&gt;dev;
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	if (hcd == NULL) {
-		retval = -ENODEV;
-		goto done;
-	}
-
-	/* insist the urb is still queued */
-	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
-		if (tmp == &amp;urb-&gt;urb_list)
-			break;
-	}
-	if (tmp != &amp;urb-&gt;urb_list) {
-		retval = -EIDRM;
-		goto done;
-	}
 
-	/* Any status except -EINPROGRESS means something already started to
-	 * unlink this URB from the hardware.  So there's no more work to do.
-	 */
-	if (urb-&gt;status != -EINPROGRESS) {
-		retval = -EBUSY;
-		goto done;
-	}
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (!retval)
+		retval = unlink1(hcd, urb);
 
-	/* IRQ setup can easily be broken so that USB controllers
-	 * never get completion IRQs ... maybe even the ones we need to
-	 * finish unlinking the initial failed usb_set_address()
-	 * or device descriptor fetch.
-	 */
-	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
-			!is_root_hub(urb-&gt;dev)) {
-		dev_warn (hcd-&gt;self.controller, "Unlink after no-IRQ?  "
-			"Controller is probably using the wrong IRQ.\n");
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-	}
-
-	urb-&gt;status = status;
-
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-
-	retval = unlink1 (hcd, urb);
 	if (retval == 0)
 		retval = -EINPROGRESS;
-	return retval;
-
-done:
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-	if (retval != -EIDRM &amp;&amp; sys &amp;&amp; sys-&gt;driver)
-		dev_dbg (sys, "hcd_unlink_urb %p fail %d\n", urb, retval);
+	else if (retval != -EIDRM)
+		dev_dbg(&amp;urb-&gt;dev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
+				urb, retval);
 	return retval;
 }
 
@@ -1165,7 +1182,8 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	urb_unlink(hcd, urb);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
 
@@ -1194,12 +1212,12 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
 
+	might_sleep();
 	hcd = bus_to_hcd(udev-&gt;bus);
-	local_irq_disable ();
 
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
-	spin_lock(&amp;hcd_urb_list_lock);
+	spin_lock_irq(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 		int	is_in;
@@ -1244,13 +1262,11 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		/* list contents may have changed */
 		goto rescan;
 	}
-	spin_unlock(&amp;hcd_urb_list_lock);
-	local_irq_enable ();
+	spin_unlock_irq(&amp;hcd_urb_list_lock);
 
 	/* synchronize with the hardware, so old configuration state
 	 * clears out immediately (and will be freed).
 	 */
-	might_sleep ();
 	if (hcd-&gt;driver-&gt;endpoint_disable)
 		hcd-&gt;driver-&gt;endpoint_disable (hcd, ep);
 </pre><hr><pre>commit 9439eb94b5c374d5b02699f8897fc43aa3603701
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:05:45 2007 -0400

    USB: update spinlock usage for root-hub URBs
    
    This patch (as952) adjusts the spinlock usage in the root-hub
    emulation part of usbcore, to make it match more closely the pattern
    used by regular host controller drivers.  To wit: The private lock
    (usb_hcd_root_hub_lock) is held throughout the important parts, and it
    is dropped temporarily without re-enabling interrupts around the call
    to usb_hcd_giveback_urb().
    
    A nice side effect is that the code now avoids calling
    local_irq_save(), thereby becoming more RT-friendly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 47a055a2acf5..f8e7deb03ee9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -356,10 +356,11 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	const u8	*bufp = tbuf;
 	int		len = 0;
 	int		patch_wakeup = 0;
-	unsigned long	flags;
 	int		status = 0;
 	int		n;
 
+	might_sleep();
+
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
 	wValue   = le16_to_cpu (cmd-&gt;wValue);
@@ -523,13 +524,21 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	}
 
 	/* any errors get returned through the urb completion */
-	local_irq_save (flags);
-	spin_lock (&amp;urb-&gt;lock);
+	spin_lock_irq(&amp;hcd_root_hub_lock);
+	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	spin_unlock (&amp;urb-&gt;lock);
-	usb_hcd_giveback_urb (hcd, urb);
-	local_irq_restore (flags);
+	spin_unlock(&amp;urb-&gt;lock);
+
+	/* This peculiar use of spinlocks echoes what real HC drivers do.
+	 * Avoiding calls to local_irq_disable/enable makes the code
+	 * RT-friendly.
+	 */
+	spin_unlock(&amp;hcd_root_hub_lock);
+	usb_hcd_giveback_urb(hcd, urb);
+	spin_lock(&amp;hcd_root_hub_lock);
+
+	spin_unlock_irq(&amp;hcd_root_hub_lock);
 	return 0;
 }
 
@@ -559,8 +568,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 	if (length &gt; 0) {
 
 		/* try to complete the status urb */
-		local_irq_save (flags);
-		spin_lock(&amp;hcd_root_hub_lock);
+		spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 		urb = hcd-&gt;status_urb;
 		if (urb) {
 			spin_lock(&amp;urb-&gt;lock);
@@ -574,16 +582,16 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 			} else		/* urb has been unlinked */
 				length = 0;
 			spin_unlock(&amp;urb-&gt;lock);
+
+			spin_unlock(&amp;hcd_root_hub_lock);
+			usb_hcd_giveback_urb(hcd, urb);
+			spin_lock(&amp;hcd_root_hub_lock);
 		} else
 			length = 0;
-		spin_unlock(&amp;hcd_root_hub_lock);
 
-		/* local irqs are always blocked in completions */
-		if (length &gt; 0)
-			usb_hcd_giveback_urb (hcd, urb);
-		else
+		if (length &lt;= 0)
 			hcd-&gt;poll_pending = 1;
-		local_irq_restore (flags);
+		spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	}
 
 	/* The USB 2.0 spec says 256 ms.  This is close enough and won't
@@ -651,25 +659,23 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long	flags;
 
+	spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
 	} else {				/* Status URB */
 		if (!hcd-&gt;uses_new_polling)
 			del_timer (&amp;hcd-&gt;rh_timer);
-		local_irq_save (flags);
-		spin_lock (&amp;hcd_root_hub_lock);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;hcpriv = NULL;
-		} else
-			urb = NULL;		/* wasn't fully queued */
-		spin_unlock (&amp;hcd_root_hub_lock);
-		if (urb)
-			usb_hcd_giveback_urb (hcd, urb);
-		local_irq_restore (flags);
-	}
 
+			spin_unlock(&amp;hcd_root_hub_lock);
+			usb_hcd_giveback_urb(hcd, urb);
+			spin_lock(&amp;hcd_root_hub_lock);
+		}
+	}
+	spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	return 0;
 }
 </pre><hr><pre>commit d617bc83ff48ebf0df253605529d8b3bef15773a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:04:52 2007 -0400

    USB: cleanup for previous patches
    
    This patch (as951) cleans up a few loose ends from earlier patches.
    Redundant checks for non-NULL urb-&gt;dev are removed, as are checks of
    urb-&gt;dev-&gt;bus (which can never be NULL).  Conversely, a check for
    non-NULL urb-&gt;ep is added to the unlink paths.
    
    A homegrown round-down-to-power-of-2 loop is simplified by using the
    ilog2 routine.  The comparison in usb_urb_dir_in() is made more
    transparent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 739c5e0aa3b8..47a055a2acf5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1074,11 +1074,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	struct list_head		*tmp;
 	int				retval;
 
-	if (!urb)
-		return -EINVAL;
-	if (!urb-&gt;dev || !urb-&gt;dev-&gt;bus)
-		return -ENODEV;
-
 	/*
 	 * we contend for urb-&gt;status with the hcd core,
 	 * which changes it while returning the urb.
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1acca8696bcd..19f5f66c2733 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -3,6 +3,7 @@
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/init.h&gt;
+#include &lt;linux/log2.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/wait.h&gt;
 #include "hcd.h"
@@ -441,10 +442,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		default:
 			return -EINVAL;
 		}
-		/* power of two? */
-		while (max &gt; urb-&gt;interval)
-			max &gt;&gt;= 1;
-		urb-&gt;interval = max;
+		/* Round down to a power of 2, no more than max */
+		urb-&gt;interval = min(max, 1 &lt;&lt; ilog2(urb-&gt;interval));
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);
@@ -513,8 +512,10 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
+	if (!urb-&gt;dev)
 		return -ENODEV;
+	if (!urb-&gt;ep)
+		return -EIDRM;
 	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
@@ -541,7 +542,7 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
+	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;ep))
 		return;
 	spin_lock_irq(&amp;urb-&gt;lock);
 	++urb-&gt;reject;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 019ae963a9fe..a51f34e80572 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1395,7 +1395,7 @@ extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
  */
 static inline int usb_urb_dir_in(struct urb *urb)
 {
-	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) != URB_DIR_OUT;
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN;
 }
 
 /**</pre>
    <div class="pagination">
        <a href='2_101.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><span>[102]</span><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_103.html'>Next&gt;&gt;</a>
    <div>
</body>
