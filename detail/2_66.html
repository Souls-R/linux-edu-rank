<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_65.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><span>[66]</span><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_67.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 48826626263d4a61d06fd8c5805da31f925aefa0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 22 16:14:48 2010 -0400

    USB: obey the sysfs power/wakeup setting
    
    This patch (as1403) is a partial reversion of an earlier change
    (commit 5f677f1d45b2bf08085bbba7394392dfa586fa8e "USB: fix remote
    wakeup settings during system sleep").  After hearing from a user, I
    realized that remote wakeup should be enabled during system sleep
    whenever userspace allows it, and not only if a driver requests it
    too.
    
    Indeed, there could be a device with no driver, that does nothing but
    generate a wakeup request when the user presses a button.  Such a
    device should be allowed to do its job.
    
    The problem fixed by the earlier patch -- device generating a wakeup
    request for no reason, causing system suspend to abort -- was also
    addressed by a later patch ("USB: don't enable remote wakeup by
    default", accepted but not yet merged into mainline).  The device
    won't be able to generate the bogus wakeup requests because it will be
    disabled for remote wakeup by default.  Hence this reversion will not
    re-introduce any old problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt; [.34]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index de98a94d1853..a6bd53ace035 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1272,8 +1272,7 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 
 static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
 {
-	int			w, i;
-	struct usb_interface	*intf;
+	int	w;
 
 	/* Remote wakeup is needed only when we actually go to sleep.
 	 * For things like FREEZE and QUIESCE, if the device is already
@@ -1285,16 +1284,10 @@ static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
 		return;
 	}
 
-	/* If remote wakeup is permitted, see whether any interface drivers
+	/* Enable remote wakeup if it is allowed, even if no interface drivers
 	 * actually want it.
 	 */
-	w = 0;
-	if (device_may_wakeup(&amp;udev-&gt;dev) &amp;&amp; udev-&gt;actconfig) {
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			intf = udev-&gt;actconfig-&gt;interface[i];
-			w |= intf-&gt;needs_remote_wakeup;
-		}
-	}
+	w = device_may_wakeup(&amp;udev-&gt;dev);
 
 	/* If the device is autosuspended with the wrong wakeup setting,
 	 * autoresume now so the setting can be changed.</pre><hr><pre>commit 64d65872f96e2a754caa12ef48949c314384bd9f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 18 10:16:33 2010 -0400

    USB: fix oops in usb_sg_init()
    
    This patch (as1401) fixes a bug in usb_sg_init() that can cause an
    invalid pointer dereference.  An inner loop reuses some local variables
    in an unsafe manner, so new variables are introduced.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ajay Kumar Gupta &lt;ajay.gupta@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a73e08fdab36..fd4c36ea5e46 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -416,8 +416,11 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 			/* A length of zero means transfer the whole sg list */
 			len = length;
 			if (len == 0) {
-				for_each_sg(sg, sg, nents, i)
-					len += sg-&gt;length;
+				struct scatterlist	*sg2;
+				int			j;
+
+				for_each_sg(sg, sg2, nents, j)
+					len += sg2-&gt;length;
 			}
 		} else {
 			/*</pre><hr><pre>commit c043f1245654a726925529007210e9f786426448
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 4 14:02:42 2010 -0400

    USB: unbind all interfaces before rebinding them
    
    This patch (as1387) fixes a bug introduced during the changeover to
    the runtime PM framework.  When a driver doesn't support resume or
    reset-resume, and consequently its interfaces need to be unbound and
    rebound, we have to unbind all the interfaces before trying to rebind
    any of them.  Otherwise the driver's probe method for one interface
    could try to claim a different interface and fail, because that other
    interface hasn't been unbound yet.
    
    This fixes Bugzilla #15788.  The symptom is that some USB sound cards
    don't work after hibernation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Fran√ßois Valenduc &lt;francois.valenduc@tvcablenet.be&gt;
    Cc: stable &lt;stable@kernel.org&gt; [.34]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ded550eda5d9..de98a94d1853 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1328,6 +1328,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 
 	/* For all other calls, take the device back to full power and
 	 * tell the PM core in case it was autosuspended previously.
+	 * Unbind the interfaces that will need rebinding later.
 	 */
 	} else {
 		status = usb_resume_both(udev, msg);
@@ -1336,6 +1337,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 			pm_runtime_set_active(dev);
 			pm_runtime_enable(dev);
 			udev-&gt;last_busy = jiffies;
+			do_unbind_rebind(udev, DO_REBIND);
 		}
 	}
 </pre><hr><pre>commit f9e8894ae5157796dd69249c56062042d02a431d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 18 15:39:30 2010 -0400

    [SCSI] fix race in scsi_target_reap
    
    This patch (as1357) fixes a race in SCSI target allocation and
    release.  Putting a target in the STARGET_DEL state isn't protected by
    the host lock, so an old target structure could be reused by a new
    device even though it's about to be deleted.  The cure is to change
    the state while still holding the host lock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index c992ecf4e372..a77468cd5a33 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -492,19 +492,20 @@ void scsi_target_reap(struct scsi_target *starget)
 	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);
 	unsigned long flags;
 	enum scsi_target_state state;
-	int empty;
+	int empty = 0;
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	state = starget-&gt;state;
-	empty = --starget-&gt;reap_ref == 0 &amp;&amp;
-		list_empty(&amp;starget-&gt;devices) ? 1 : 0;
+	if (--starget-&gt;reap_ref == 0 &amp;&amp; list_empty(&amp;starget-&gt;devices)) {
+		empty = 1;
+		starget-&gt;state = STARGET_DEL;
+	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 
 	if (!empty)
 		return;
 
 	BUG_ON(state == STARGET_DEL);
-	starget-&gt;state = STARGET_DEL;
 	if (state == STARGET_CREATED)
 		scsi_target_destroy(starget);
 	else</pre><hr><pre>commit ffa156590f98b750161757a16c37ac8e152a7859
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 8 16:46:19 2010 -0500

    Driver core: don't initialize wakeup flags
    
    This patch (as1351) removes an unnecessary and unwanted assignment
    from device_initialize().  The wakeup flags are set to 0 along with
    everything else when the device structure is allocated, so we don't
    need to do it again.  Furthermore, the subsystem might already have
    set these flags to their correct values; we don't want to override it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b56a0ba31d4a..e11c8c3e7416 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -562,7 +562,6 @@ void device_initialize(struct device *dev)
 	init_MUTEX(&amp;dev-&gt;sem);
 	spin_lock_init(&amp;dev-&gt;devres_lock);
 	INIT_LIST_HEAD(&amp;dev-&gt;devres_head);
-	device_init_wakeup(dev, 0);
 	device_pm_init(dev);
 	set_dev_node(dev, -1);
 }</pre><hr><pre>commit 16032c4f5b291af541e9114a09ea20ff5a0dc474
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 12 18:21:35 2010 -0400

    USB: EHCI: fix controller wakeup flag settings during suspend
    
    This patch (as1380) fixes a bug in the wakeup settings for EHCI host
    controllers.  When the controller is suspended, if it isn't enabled
    for remote wakeup then we have to turn off all the port wakeup flags.
    Disabling PCI PME# isn't good enough, because some systems (Intel)
    evidently use alternate wakeup signalling paths.
    
    In addition, the patch improves the handling of the Intel Moorestown
    hardware by performing various power-up and power-down delays just
    once instead of once for each port (i.e., the delays are moved outside
    of the port loops).  This requires extra code, but the total delay
    time is reduced.
    
    There are also a few additional minor cleanups.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Ondrej Zary &lt;linux@rainbow-software.org&gt;
    CC: Alek Du &lt;alek.du@intel.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 7a27b7c4ee84..faa61748db70 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -224,26 +224,17 @@ static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
 		msleep(10);
 
 	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
+	ehci_prepare_ports_for_controller_suspend(ehci);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
 	au1xxx_stop_ehc();
-
-bail:
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 
 	// could save FLADJ in case of Vaux power loss
@@ -273,6 +264,7 @@ static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
 	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
+		ehci_prepare_ports_for_controller_resume(ehci);
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 0e26aa13f158..5cd967d28938 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -313,6 +313,7 @@ static int ehci_fsl_drv_suspend(struct device *dev)
 	struct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);
 	void __iomem *non_ehci = hcd-&gt;regs;
 
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd));
 	if (!fsl_deep_sleep())
 		return 0;
 
@@ -327,6 +328,7 @@ static int ehci_fsl_drv_resume(struct device *dev)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd-&gt;regs;
 
+	ehci_prepare_ports_for_controller_resume(ehci);
 	if (!fsl_deep_sleep())
 		return 0;
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ef956220f854..e7d3d8def282 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -106,12 +106,75 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	ehci-&gt;owned_ports = 0;
 }
 
+static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
+		bool suspending)
+{
+	int		port;
+	u32		temp;
+
+	/* If remote wakeup is enabled for the root hub but disabled
+	 * for the controller, we must adjust all the port wakeup flags
+	 * when the controller is suspended or resumed.  In all other
+	 * cases they don't need to be changed.
+	 */
+	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup ||
+			device_may_wakeup(ehci_to_hcd(ehci)-&gt;self.controller))
+		return;
+
+	/* clear phy low-power mode before changing wakeup flags */
+	if (ehci-&gt;has_hostpc) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			temp = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD, hostpc_reg);
+		}
+		msleep(5);
+	}
+
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
+	while (port--) {
+		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status[port];
+		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
+		u32		t2 = t1 &amp; ~PORT_WAKE_BITS;
+
+		/* If we are suspending the controller, clear the flags.
+		 * If we are resuming the controller, set the wakeup flags.
+		 */
+		if (!suspending) {
+			if (t1 &amp; PORT_CONNECT)
+				t2 |= PORT_WKOC_E | PORT_WKDISC_E;
+			else
+				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
+		}
+		ehci_vdbg(ehci, "port %d, %08x -&gt; %08x\n",
+				port + 1, t1, t2);
+		ehci_writel(ehci, t2, reg);
+	}
+
+	/* enter phy low-power mode again */
+	if (ehci-&gt;has_hostpc) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			temp = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);
+		}
+	}
+}
+
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	int			port;
 	int			mask;
-	u32 __iomem		*hostpc_reg = NULL;
+	int			changed;
 
 	ehci_dbg(ehci, "suspend root hub\n");
 
@@ -155,15 +218,13 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 */
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
+	changed = 0;
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
-		u32		t2 = t1;
+		u32		t2 = t1 &amp; ~PORT_WAKE_BITS;
 
-		if (ehci-&gt;has_hostpc)
-			hostpc_reg = (u32 __iomem *)((u8 *)ehci-&gt;regs
-				+ HOSTPC0 + 4 * (port &amp; 0xff));
 		/* keep track of which ports we suspend */
 		if (t1 &amp; PORT_OWNER)
 			set_bit(port, &amp;ehci-&gt;owned_ports);
@@ -172,40 +233,45 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 			set_bit(port, &amp;ehci-&gt;bus_suspended);
 		}
 
-		/* enable remote wakeup on all ports */
+		/* enable remote wakeup on all ports, if told to do so */
 		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
 			/* only enable appropriate wake bits, otherwise the
 			 * hardware can not go phy low power mode. If a race
 			 * condition happens here(connection change during bits
 			 * set), the port change detection will finally fix it.
 			 */
-			if (t1 &amp; PORT_CONNECT) {
+			if (t1 &amp; PORT_CONNECT)
 				t2 |= PORT_WKOC_E | PORT_WKDISC_E;
-				t2 &amp;= ~PORT_WKCONN_E;
-			} else {
+			else
 				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
-				t2 &amp;= ~PORT_WKDISC_E;
-			}
-		} else
-			t2 &amp;= ~PORT_WAKE_BITS;
+		}
 
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -&gt; %08x\n",
 				port + 1, t1, t2);
 			ehci_writel(ehci, t2, reg);
-			if (hostpc_reg) {
-				u32	t3;
+			changed = 1;
+		}
+	}
 
-				spin_unlock_irq(&amp;ehci-&gt;lock);
-				msleep(5);/* 5ms for HCD enter low pwr mode */
-				spin_lock_irq(&amp;ehci-&gt;lock);
-				t3 = ehci_readl(ehci, hostpc_reg);
-				ehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);
-				t3 = ehci_readl(ehci, hostpc_reg);
-				ehci_dbg(ehci, "Port%d phy low pwr mode %s\n",
+	if (changed &amp;&amp; ehci-&gt;has_hostpc) {
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		msleep(5);	/* 5 ms for HCD to enter low-power mode */
+		spin_lock_irq(&amp;ehci-&gt;lock);
+
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+			u32		t3;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			t3 = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);
+			t3 = ehci_readl(ehci, hostpc_reg);
+			ehci_dbg(ehci, "Port %d phy low-power mode %s\n",
 					port, (t3 &amp; HOSTPC_PHCD) ?
 					"succeeded" : "failed");
-			}
 		}
 	}
 
@@ -291,19 +357,28 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	msleep(8);
 	spin_lock_irq(&amp;ehci-&gt;lock);
 
+	/* clear phy low-power mode before resume */
+	if (ehci-&gt;bus_suspended &amp;&amp; ehci-&gt;has_hostpc) {
+		i = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (i--) {
+			if (test_bit(i, &amp;ehci-&gt;bus_suspended)) {
+				u32 __iomem	*hostpc_reg;
+
+				hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+						+ HOSTPC0 + 4 * i);
+				temp = ehci_readl(ehci, hostpc_reg);
+				ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD,
+						hostpc_reg);
+			}
+		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		msleep(5);
+		spin_lock_irq(&amp;ehci-&gt;lock);
+	}
+
 	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
-		/* clear phy low power mode before resume */
-		if (ehci-&gt;has_hostpc) {
-			u32 __iomem	*hostpc_reg =
-				(u32 __iomem *)((u8 *)ehci-&gt;regs
-				+ HOSTPC0 + 4 * (i &amp; 0xff));
-			temp = ehci_readl(ehci, hostpc_reg);
-			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD,
-				hostpc_reg);
-			mdelay(5);
-		}
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
 		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
@@ -685,23 +760,25 @@ static int ehci_hub_control (
 				goto error;
 			if (ehci-&gt;no_selective_suspend)
 				break;
-			if (temp &amp; PORT_SUSPEND) {
-				if ((temp &amp; PORT_PE) == 0)
-					goto error;
-				/* clear phy low power mode before resume */
-				if (hostpc_reg) {
-					temp1 = ehci_readl(ehci, hostpc_reg);
-					ehci_writel(ehci, temp1 &amp; ~HOSTPC_PHCD,
+			if (!(temp &amp; PORT_SUSPEND))
+				break;
+			if ((temp &amp; PORT_PE) == 0)
+				goto error;
+
+			/* clear phy low-power mode before resume */
+			if (hostpc_reg) {
+				temp1 = ehci_readl(ehci, hostpc_reg);
+				ehci_writel(ehci, temp1 &amp; ~HOSTPC_PHCD,
 						hostpc_reg);
-					mdelay(5);
-				}
-				/* resume signaling for 20 msec */
-				temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
-				ehci_writel(ehci, temp | PORT_RESUME,
-						status_reg);
-				ehci-&gt;reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (20);
+				spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+				msleep(5);/* wait to leave low-power mode */
+				spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 			}
+			/* resume signaling for 20 msec */
+			temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
+			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
+			ehci-&gt;reset_done[wIndex] = jiffies
+					+ msecs_to_jiffies(20);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d120059bbbf7..d43d176161aa 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -287,23 +287,15 @@ static int ehci_pci_suspend(struct usb_hcd *hcd)
 		msleep(10);
 
 	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
+	ehci_prepare_ports_for_controller_suspend(ehci);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
- bail:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 	// could save FLADJ in case of Vaux power loss
@@ -333,6 +325,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 				!hibernated) {
 		int	mask = INTR_MASK;
 
+		ehci_prepare_ports_for_controller_resume(ehci);
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 4ebe9ad209e4..650a687f2854 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -536,6 +536,16 @@ struct ehci_fstn {
 
 /*-------------------------------------------------------------------------*/
 
+/* Prepare the PORTSC wakeup flags during controller suspend/resume */
+
+#define ehci_prepare_ports_for_controller_suspend(ehci)		\
+		ehci_adjust_port_wakeup_flags(ehci, true);
+
+#define ehci_prepare_ports_for_controller_resume(ehci)		\
+		ehci_adjust_port_wakeup_flags(ehci, false);
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef CONFIG_USB_EHCI_ROOT_HUB_TT
 
 /*</pre><hr><pre>commit 89842ae6515c49405e20c0629a6442b6885ad49d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 11 11:44:06 2010 -0400

    USB: fix interface runtime-PM settings
    
    This patch (as1379) reworks the logic for handling USB interface
    runtime-PM settings -- hopefully it's right this time!  The problem is
    that when a driver is unbound or binding fails, runtime PM for the
    interface always gets disabled.  But pm_runtime_disable() nests, so it
    shouldn't be called unless the interface was previously enabled for
    runtime PM.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Rob Duncan &lt;Robert.Duncan@exar.com&gt;
    Tested-by: Rob Duncan &lt;Robert.Duncan@exar.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 207146743ea7..ded550eda5d9 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -334,7 +334,8 @@ static int usb_probe_interface(struct device *dev)
 	usb_cancel_queued_reset(intf);
 
 	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
-	pm_runtime_disable(dev);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
 	usb_autosuspend_device(udev);
@@ -389,7 +390,8 @@ static int usb_unbind_interface(struct device *dev)
 	intf-&gt;needs_remote_wakeup = 0;
 
 	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
-	pm_runtime_disable(dev);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
 	/* Undo any residual pm_autopm_get_interface_* calls */
@@ -438,14 +440,17 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Claimed interfaces are initially inactive (suspended).  They are
-	 * runtime-PM-enabled only if the driver has autosuspend support.
-	 * They are sensitive to their children's power states.
+	/* Claimed interfaces are initially inactive (suspended) and
+	 * runtime-PM-enabled, but only if the driver has autosuspend
+	 * support.  Otherwise they are marked active, to prevent the
+	 * device from being autosuspended, but left disabled.  In either
+	 * case they are sensitive to their children's power states.
 	 */
-	pm_runtime_set_suspended(dev);
 	pm_suspend_ignore_children(dev, false);
 	if (driver-&gt;supports_autosuspend)
 		pm_runtime_enable(dev);
+	else
+		pm_runtime_set_active(dev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()</pre><hr><pre>commit 0ba169aff9181389f30f225ad92e113eeb2290b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 5 15:26:17 2010 -0400

    USB: simplify usb_sg_init()
    
    This patch (as1377) simplifies the code in usb_sg_init(), without
    changing its functionality.  It also removes a couple of unused fields
    from the usb_sg_request structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 63919b8abee1..a73e08fdab36 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -371,79 +371,64 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	spin_lock_init(&amp;io-&gt;lock);
 	io-&gt;dev = dev;
 	io-&gt;pipe = pipe;
-	io-&gt;sg = sg;
-	io-&gt;nents = nents;
-	io-&gt;entries = nents;
 
-	/* initialize all the urbs we'll use */
 	if (dev-&gt;bus-&gt;sg_tablesize &gt; 0) {
-		io-&gt;urbs = kmalloc(sizeof *io-&gt;urbs, mem_flags);
 		use_sg = true;
+		io-&gt;entries = 1;
 	} else {
-		io-&gt;urbs = kmalloc(io-&gt;entries * sizeof *io-&gt;urbs, mem_flags);
 		use_sg = false;
+		io-&gt;entries = nents;
 	}
+
+	/* initialize all the urbs we'll use */
+	io-&gt;urbs = kmalloc(io-&gt;entries * sizeof *io-&gt;urbs, mem_flags);
 	if (!io-&gt;urbs)
 		goto nomem;
 
-	urb_flags = 0;
+	urb_flags = URB_NO_INTERRUPT;
 	if (usb_pipein(pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
-	if (use_sg) {
-		io-&gt;urbs[0] = usb_alloc_urb(0, mem_flags);
-		if (!io-&gt;urbs[0]) {
-			io-&gt;entries = 0;
-			goto nomem;
-		}
-
-		io-&gt;urbs[0]-&gt;dev = NULL;
-		io-&gt;urbs[0]-&gt;pipe = pipe;
-		io-&gt;urbs[0]-&gt;interval = period;
-		io-&gt;urbs[0]-&gt;transfer_flags = urb_flags;
+	for_each_sg(sg, sg, io-&gt;entries, i) {
+		struct urb *urb;
+		unsigned len;
 
-		io-&gt;urbs[0]-&gt;complete = sg_complete;
-		io-&gt;urbs[0]-&gt;context = io;
-
-		/* A length of zero means transfer the whole sg list */
-		io-&gt;urbs[0]-&gt;transfer_buffer_length = length;
-		if (length == 0) {
-			for_each_sg(sg, sg, io-&gt;entries, i) {
-				io-&gt;urbs[0]-&gt;transfer_buffer_length +=
-					sg-&gt;length;
-			}
+		urb = usb_alloc_urb(0, mem_flags);
+		if (!urb) {
+			io-&gt;entries = i;
+			goto nomem;
 		}
-		io-&gt;urbs[0]-&gt;sg = sg;
-		io-&gt;urbs[0]-&gt;num_sgs = io-&gt;entries;
-		io-&gt;entries = 1;
-	} else {
-		urb_flags |= URB_NO_INTERRUPT;
-		for_each_sg(sg, sg, io-&gt;entries, i) {
-			unsigned len;
-
-			io-&gt;urbs[i] = usb_alloc_urb(0, mem_flags);
-			if (!io-&gt;urbs[i]) {
-				io-&gt;entries = i;
-				goto nomem;
+		io-&gt;urbs[i] = urb;
+
+		urb-&gt;dev = NULL;
+		urb-&gt;pipe = pipe;
+		urb-&gt;interval = period;
+		urb-&gt;transfer_flags = urb_flags;
+		urb-&gt;complete = sg_complete;
+		urb-&gt;context = io;
+		urb-&gt;sg = sg;
+
+		if (use_sg) {
+			/* There is no single transfer buffer */
+			urb-&gt;transfer_buffer = NULL;
+			urb-&gt;num_sgs = nents;
+
+			/* A length of zero means transfer the whole sg list */
+			len = length;
+			if (len == 0) {
+				for_each_sg(sg, sg, nents, i)
+					len += sg-&gt;length;
 			}
-
-			io-&gt;urbs[i]-&gt;dev = NULL;
-			io-&gt;urbs[i]-&gt;pipe = pipe;
-			io-&gt;urbs[i]-&gt;interval = period;
-			io-&gt;urbs[i]-&gt;transfer_flags = urb_flags;
-
-			io-&gt;urbs[i]-&gt;complete = sg_complete;
-			io-&gt;urbs[i]-&gt;context = io;
-
+		} else {
 			/*
 			 * Some systems can't use DMA; they use PIO instead.
 			 * For their sakes, transfer_buffer is set whenever
 			 * possible.
 			 */
 			if (!PageHighMem(sg_page(sg)))
-				io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(sg);
+				urb-&gt;transfer_buffer = sg_virt(sg);
 			else
-				io-&gt;urbs[i]-&gt;transfer_buffer = NULL;
+				urb-&gt;transfer_buffer = NULL;
 
 			len = sg-&gt;length;
 			if (length) {
@@ -452,12 +437,10 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 				if (length == 0)
 					io-&gt;entries = i + 1;
 			}
-			io-&gt;urbs[i]-&gt;transfer_buffer_length = len;
-
-			io-&gt;urbs[i]-&gt;sg = sg;
 		}
-		io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
+		urb-&gt;transfer_buffer_length = len;
 	}
+	io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
 
 	/* transaction state */
 	io-&gt;count = io-&gt;entries;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index eec9e74f332f..ce07062ebc28 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1469,8 +1469,6 @@ struct usb_sg_request {
 
 	struct usb_device	*dev;
 	int			pipe;
-	struct scatterlist	*sg;
-	int			nents;
 
 	int			entries;
 	struct urb		**urbs;</pre><hr><pre>commit 85bcb5ee889e0ebb9154718939e049de265fcdfb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 16:35:37 2010 -0400

    USB: remove URB_NO_SETUP_DMA_MAP
    
    Now that URB_NO_SETUP_DMA_MAP is no longer in use, this patch (as1376)
    removes all references to it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/dma.txt b/Documentation/usb/dma.txt
index a37e59cf2786..84ef865237db 100644
--- a/Documentation/usb/dma.txt
+++ b/Documentation/usb/dma.txt
@@ -16,11 +16,11 @@ OR:  they can now be DMA-aware.
   manage dma mappings for existing dma-ready buffers (see below).
 
 - URBs have an additional "transfer_dma" field, as well as a transfer_flags
-  bit saying if it's valid.  (Control requests also have "setup_dma" and a
-  corresponding transfer_flags bit.)
+  bit saying if it's valid.  (Control requests also have "setup_dma", but
+  drivers must not use it.)
 
-- "usbcore" will map those DMA addresses, if a DMA-aware driver didn't do
-  it first and set URB_NO_TRANSFER_DMA_MAP or URB_NO_SETUP_DMA_MAP.  HCDs
+- "usbcore" will map this DMA address, if a DMA-aware driver didn't do
+  it first and set URB_NO_TRANSFER_DMA_MAP.  HCDs
   don't manage dma mappings for URBs.
 
 - There's a new "generic DMA API", parts of which are usable by USB device
@@ -53,12 +53,6 @@ and effects like cache-trashing can impose subtle penalties.
   to use this type of memory ("dma-coherent"), and memory returned from
   kmalloc() will work just fine.
 
-  For control transfers you can use the buffer primitives or not for each
-  of the transfer buffer and setup buffer independently.  Set the flag bits
-  URB_NO_TRANSFER_DMA_MAP and URB_NO_SETUP_DMA_MAP to indicate which
-  buffers you have prepared.  For non-control transfers URB_NO_SETUP_DMA_MAP
-  is ignored.
-
   The memory buffer returned is "dma-coherent"; sometimes you might need to
   force a consistent memory access ordering by using memory barriers.  It's
   not using a streaming DMA mapping, so it's good for small transfers on
@@ -130,8 +124,8 @@ of Documentation/PCI/PCI-DMA-mapping.txt, titled "What memory is DMA-able?")
 	void usb_buffer_unmap (struct urb *urb);
 
   The calls manage urb-&gt;transfer_dma for you, and set URB_NO_TRANSFER_DMA_MAP
-  so that usbcore won't map or unmap the buffer.  The same goes for
-  urb-&gt;setup_dma and URB_NO_SETUP_DMA_MAP for control requests.
+  so that usbcore won't map or unmap the buffer.  They cannot be used for
+  setup_packet buffers in control requests.
 
 Note that several of those interfaces are currently commented out, since
 they don't have current users.  See the source code.  Other than the dmasync
diff --git a/drivers/staging/usbip/usbip_common.c b/drivers/staging/usbip/usbip_common.c
index e3fa4216c1cd..52408164036f 100644
--- a/drivers/staging/usbip/usbip_common.c
+++ b/drivers/staging/usbip/usbip_common.c
@@ -562,7 +562,7 @@ EXPORT_SYMBOL_GPL(sockfd_to_socket);
 /* there may be more cases to tweak the flags. */
 static unsigned int tweak_transfer_flags(unsigned int flags)
 {
-	flags &amp;= ~(URB_NO_TRANSFER_DMA_MAP|URB_NO_SETUP_DMA_MAP);
+	flags &amp;= ~URB_NO_TRANSFER_DMA_MAP;
 	return flags;
 }
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 3aaee2811f01..0abc5c537f39 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1316,8 +1316,7 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 	 * or uses the provided scatter gather list for bulk.
 	 */
 
-	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)) {
+	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)) {
 		if (hcd-&gt;self.uses_dma) {
 			urb-&gt;setup_dma = dma_map_single(
 					hcd-&gt;self.controller,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a748815ee629..1eb4762d9ea8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -953,7 +953,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
 					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
-#define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
@@ -1049,12 +1048,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @setup_packet: Only used for control transfers, this points to eight bytes
  *	of setup data.  Control transfers always start by sending this data
  *	to the device.  Then transfer_buffer is read or written, if needed.
- * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the
- *	device driver has provided this DMA address for the setup packet.
- *	The host controller driver should use this in preference to
- *	setup_packet, but the HCD may chose to ignore the address if it must
- *	copy the setup packet into internal structures.  Therefore, setup_packet
- *	must always point to a valid buffer.
+ * @setup_dma: DMA pointer for the setup packet.  The caller must not use
+ *	this field; setup_packet must point to a valid buffer.
  * @start_frame: Returns the initial frame for isochronous transfers.
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous
@@ -1086,13 +1081,14 @@ typedef void (*usb_complete_t)(struct urb *);
  * bounce buffer or talking to an IOMMU),
  * although they're cheap on commodity x86 and ppc hardware.
  *
- * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
- * which tell the host controller driver that no such mapping is needed since
+ * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
+ * which tells the host controller driver that no such mapping is needed for
+ * the transfer_buffer since
  * the device driver is DMA-aware.  For example, a device driver might
  * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().
- * When these transfer flags are provided, host controller drivers will
- * attempt to use the dma addresses found in the transfer_dma and/or
- * setup_dma fields rather than determining a dma address themselves.
+ * When this transfer flag is provided, host controller drivers will
+ * attempt to use the dma address found in the transfer_dma
+ * field rather than determining a dma address themselves.
  *
  * Note that transfer_buffer must still be set if the controller
  * does not support DMA (as indicated by bus.uses_dma) and when talking
@@ -1115,11 +1111,9 @@ typedef void (*usb_complete_t)(struct urb *);
  * should always terminate with a short packet, even if it means adding an
  * extra zero length packet.
  *
- * Control URBs must provide a setup_packet.  The setup_packet and
- * transfer_buffer may each be mapped for DMA or not, independently of
- * the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and
- * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
- * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.
+ * Control URBs must provide a valid pointer in the setup_packet field.
+ * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
+ * beforehand.
  *
  * Interrupt URBs must provide an interval, saying how often (in milliseconds
  * or, for highspeed devices, 125 microsecond units)</pre><hr><pre>commit 842f16905dfc6743c1dd80c3d29b49ba3ab7f7c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 12:44:46 2010 -0400

    USB: remove the usb_host_ss_ep_comp structure
    
    This patch (as1375) eliminates the usb_host_ss_ep_comp structure used
    for storing a dynamically-allocated copy of the SuperSpeed endpoint
    companion descriptor.  The SuperSpeed descriptor is placed directly in
    the usb_host_endpoint structure, alongside the standard endpoint
    descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index e4909c26becb..83126b03e7cf 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -21,32 +21,6 @@ static inline const char *plural(int n)
 	return (n == 1 ? "" : "s");
 }
 
-/* FIXME: this is a kludge */
-static int find_next_descriptor_more(unsigned char *buffer, int size,
-    int dt1, int dt2, int dt3, int *num_skipped)
-{
-	struct usb_descriptor_header *h;
-	int n = 0;
-	unsigned char *buffer0 = buffer;
-
-	/* Find the next descriptor of type dt1 or dt2 or dt3 */
-	while (size &gt; 0) {
-		h = (struct usb_descriptor_header *) buffer;
-		if (h-&gt;bDescriptorType == dt1 || h-&gt;bDescriptorType == dt2 ||
-				h-&gt;bDescriptorType == dt3)
-			break;
-		buffer += h-&gt;bLength;
-		size -= h-&gt;bLength;
-		++n;
-	}
-
-	/* Store the number of descriptors skipped and return the
-	 * number of bytes skipped */
-	if (num_skipped)
-		*num_skipped = n;
-	return buffer - buffer0;
-}
-
 static int find_next_descriptor(unsigned char *buffer, int size,
     int dt1, int dt2, int *num_skipped)
 {
@@ -71,47 +45,41 @@ static int find_next_descriptor(unsigned char *buffer, int size,
 	return buffer - buffer0;
 }
 
-static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
+static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 		int inum, int asnum, struct usb_host_endpoint *ep,
-		int num_ep, unsigned char *buffer, int size)
+		unsigned char *buffer, int size)
 {
-	unsigned char *buffer_start = buffer;
-	struct usb_ss_ep_comp_descriptor	*desc;
-	int retval;
-	int num_skipped;
+	struct usb_ss_ep_comp_descriptor *desc;
 	int max_tx;
-	int i;
 
+	/* The SuperSpeed endpoint companion descriptor is supposed to
+	 * be the first thing immediately following the endpoint descriptor.
+	 */
 	desc = (struct usb_ss_ep_comp_descriptor *) buffer;
-	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP) {
+	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||
+			size &lt; USB_DT_SS_EP_COMP_SIZE) {
 		dev_warn(ddev, "No SuperSpeed endpoint companion for config %d "
 				" interface %d altsetting %d ep %d: "
 				"using minimum values\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		/*
-		 * The next descriptor is for an Endpoint or Interface,
-		 * no extra descriptors to copy into the companion structure,
-		 * and we didn't eat up any of the buffer.
+
+		/* Fill in some default values.
+		 * Leave bmAttributes as zero, which will mean no streams for
+		 * bulk, and isoc won't support multiple bursts of packets.
+		 * With bursts of only one packet, and a Mult of 1, the max
+		 * amount of data moved per endpoint service interval is one
+		 * packet.
 		 */
-		return 0;
+		ep-&gt;ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;
+		ep-&gt;ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
+		if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) ||
+				usb_endpoint_xfer_int(&amp;ep-&gt;desc))
+			ep-&gt;ss_ep_comp.wBytesPerInterval =
+					ep-&gt;desc.wMaxPacketSize;
+		return;
 	}
-	memcpy(&amp;ep-&gt;ss_ep_comp-&gt;desc, desc, USB_DT_SS_EP_COMP_SIZE);
-	desc = &amp;ep-&gt;ss_ep_comp-&gt;desc;
-	buffer += desc-&gt;bLength;
-	size -= desc-&gt;bLength;
 
-	/* Eat up the other descriptors we don't care about */
-	ep-&gt;ss_ep_comp-&gt;extra = buffer;
-	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-			USB_DT_INTERFACE, &amp;num_skipped);
-	ep-&gt;ss_ep_comp-&gt;extralen = i;
-	buffer += i;
-	size -= i;
-	retval = buffer - buffer_start;
-	if (num_skipped &gt; 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
-				num_skipped, plural(num_skipped),
-				"SuperSpeed endpoint companion");
+	memcpy(&amp;ep-&gt;ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);
 
 	/* Check the various values */
 	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bMaxBurst != 0) {
@@ -119,47 +87,48 @@ static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bMaxBurst = 0;
-	}
-	if (desc-&gt;bMaxBurst &gt; 15) {
+		ep-&gt;ss_ep_comp.bMaxBurst = 0;
+	} else if (desc-&gt;bMaxBurst &gt; 15) {
 		dev_warn(ddev, "Endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 15\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bMaxBurst = 15;
+		ep-&gt;ss_ep_comp.bMaxBurst = 15;
 	}
-	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) || usb_endpoint_xfer_int(&amp;ep-&gt;desc))
-			&amp;&amp; desc-&gt;bmAttributes != 0) {
+
+	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) ||
+			usb_endpoint_xfer_int(&amp;ep-&gt;desc)) &amp;&amp;
+				desc-&gt;bmAttributes != 0) {
 		dev_warn(ddev, "%s endpoint with bmAttributes = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n",
 				usb_endpoint_xfer_control(&amp;ep-&gt;desc) ? "Control" : "Bulk",
 				desc-&gt;bmAttributes,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 0;
-	}
-	if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bmAttributes &gt; 16) {
+		ep-&gt;ss_ep_comp.bmAttributes = 0;
+	} else if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp;
+			desc-&gt;bmAttributes &gt; 16) {
 		dev_warn(ddev, "Bulk endpoint with more than 65536 streams in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to max\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 16;
-	}
-	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bmAttributes &gt; 2) {
+		ep-&gt;ss_ep_comp.bmAttributes = 16;
+	} else if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp;
+			desc-&gt;bmAttributes &gt; 2) {
 		dev_warn(ddev, "Isoc endpoint has Mult of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 3\n", desc-&gt;bmAttributes + 1,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 2;
+		ep-&gt;ss_ep_comp.bmAttributes = 2;
 	}
-	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc)) {
+
+	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 		max_tx = ep-&gt;desc.wMaxPacketSize * (desc-&gt;bMaxBurst + 1) *
 			(desc-&gt;bmAttributes + 1);
-	} else if (usb_endpoint_xfer_int(&amp;ep-&gt;desc)) {
+	else if (usb_endpoint_xfer_int(&amp;ep-&gt;desc))
 		max_tx = ep-&gt;desc.wMaxPacketSize * (desc-&gt;bMaxBurst + 1);
-	} else {
-		goto valid;
-	}
+	else
+		max_tx = 999999;
 	if (desc-&gt;wBytesPerInterval &gt; max_tx) {
 		dev_warn(ddev, "%s endpoint with wBytesPerInterval of %d in "
 				"config %d interface %d altsetting %d ep %d: "
@@ -168,10 +137,8 @@ static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 				desc-&gt;wBytesPerInterval,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress,
 				max_tx);
-		desc-&gt;wBytesPerInterval = max_tx;
+		ep-&gt;ss_ep_comp.wBytesPerInterval = max_tx;
 	}
-valid:
-	return retval;
 }
 
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
@@ -293,61 +260,19 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 				cfgno, inum, asnum, d-&gt;bEndpointAddress,
 				maxp);
 	}
-	/* Allocate room for and parse any SS endpoint companion descriptors */
-	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER) {
-		endpoint-&gt;extra = buffer;
-		i = find_next_descriptor_more(buffer, size, USB_DT_SS_ENDPOINT_COMP,
-				USB_DT_ENDPOINT, USB_DT_INTERFACE, &amp;n);
-		endpoint-&gt;extralen = i;
-		buffer += i;
-		size -= i;
-
-		/* Allocate space for the SS endpoint companion descriptor */
-		endpoint-&gt;ss_ep_comp = kzalloc(sizeof(struct usb_host_ss_ep_comp),
-				GFP_KERNEL);
-		if (!endpoint-&gt;ss_ep_comp)
-			return -ENOMEM;
 
-		/* Fill in some default values (may be overwritten later) */
-		endpoint-&gt;ss_ep_comp-&gt;desc.bLength = USB_DT_SS_EP_COMP_SIZE;
-		endpoint-&gt;ss_ep_comp-&gt;desc.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
-		endpoint-&gt;ss_ep_comp-&gt;desc.bMaxBurst = 0;
-		/*
-		 * Leave bmAttributes as zero, which will mean no streams for
-		 * bulk, and isoc won't support multiple bursts of packets.
-		 * With bursts of only one packet, and a Mult of 1, the max
-		 * amount of data moved per endpoint service interval is one
-		 * packet.
-		 */
-		if (usb_endpoint_xfer_isoc(&amp;endpoint-&gt;desc) ||
-				usb_endpoint_xfer_int(&amp;endpoint-&gt;desc))
-			endpoint-&gt;ss_ep_comp-&gt;desc.wBytesPerInterval =
-				endpoint-&gt;desc.wMaxPacketSize;
-
-		if (size &gt; 0) {
-			retval = usb_parse_ss_endpoint_companion(ddev, cfgno,
-					inum, asnum, endpoint, num_ep, buffer,
-					size);
-			if (retval &gt;= 0) {
-				buffer += retval;
-				retval = buffer - buffer0;
-			}
-		} else {
-			dev_warn(ddev, "config %d interface %d altsetting %d "
-				"endpoint 0x%X has no "
-				"SuperSpeed companion descriptor\n",
-				cfgno, inum, asnum, d-&gt;bEndpointAddress);
-			retval = buffer - buffer0;
-		}
-	} else {
-		/* Skip over any Class Specific or Vendor Specific descriptors;
-		 * find the next endpoint or interface descriptor */
-		endpoint-&gt;extra = buffer;
-		i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-				USB_DT_INTERFACE, &amp;n);
-		endpoint-&gt;extralen = i;
-		retval = buffer - buffer0 + i;
-	}
+	/* Parse a possible SuperSpeed endpoint companion descriptor */
+	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER)
+		usb_parse_ss_endpoint_companion(ddev, cfgno,
+				inum, asnum, endpoint, buffer, size);
+
+	/* Skip over any Class Specific or Vendor Specific descriptors;
+	 * find the next endpoint or interface descriptor */
+	endpoint-&gt;extra = buffer;
+	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
+			USB_DT_INTERFACE, &amp;n);
+	endpoint-&gt;extralen = i;
+	retval = buffer - buffer0 + i;
 	if (n &gt; 0)
 		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
 		    n, plural(n), "endpoint");
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 4df752cb0f78..fd9e03afd91c 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1010,9 +1010,9 @@ static inline unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
 static inline u32 xhci_get_endpoint_mult(struct usb_device *udev,
 		struct usb_host_endpoint *ep)
 {
-	if (udev-&gt;speed != USB_SPEED_SUPER || !ep-&gt;ss_ep_comp)
+	if (udev-&gt;speed != USB_SPEED_SUPER)
 		return 0;
-	return ep-&gt;ss_ep_comp-&gt;desc.bmAttributes;
+	return ep-&gt;ss_ep_comp.bmAttributes;
 }
 
 static inline u32 xhci_get_endpoint_type(struct usb_device *udev,
@@ -1061,13 +1061,8 @@ static inline u32 xhci_get_max_esit_payload(struct xhci_hcd *xhci,
 			usb_endpoint_xfer_bulk(&amp;ep-&gt;desc))
 		return 0;
 
-	if (udev-&gt;speed == USB_SPEED_SUPER) {
-		if (ep-&gt;ss_ep_comp)
-			return ep-&gt;ss_ep_comp-&gt;desc.wBytesPerInterval;
-		xhci_warn(xhci, "WARN no SS endpoint companion descriptor.\n");
-		/* Assume no bursts, no multiple opportunities to send. */
-		return ep-&gt;desc.wMaxPacketSize;
-	}
+	if (udev-&gt;speed == USB_SPEED_SUPER)
+		return ep-&gt;ss_ep_comp.wBytesPerInterval;
 
 	max_packet = ep-&gt;desc.wMaxPacketSize &amp; 0x3ff;
 	max_burst = (ep-&gt;desc.wMaxPacketSize &amp; 0x1800) &gt;&gt; 11;
@@ -1131,12 +1126,9 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 		max_packet = ep-&gt;desc.wMaxPacketSize;
 		ep_ctx-&gt;ep_info2 |= MAX_PACKET(max_packet);
 		/* dig out max burst from ep companion desc */
-		if (!ep-&gt;ss_ep_comp) {
-			xhci_warn(xhci, "WARN no SS endpoint companion descriptor.\n");
-			max_packet = 0;
-		} else {
-			max_packet = ep-&gt;ss_ep_comp-&gt;desc.bMaxBurst;
-		}
+		max_packet = ep-&gt;ss_ep_comp.bMaxBurst;
+		if (!max_packet)
+			xhci_warn(xhci, "WARN no SS endpoint bMaxBurst\n");
 		ep_ctx-&gt;ep_info2 |= MAX_BURST(max_packet);
 		break;
 	case USB_SPEED_HIGH:
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 3cac2ff8b50a..59f38a5f2fe6 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1476,13 +1476,7 @@ static int xhci_check_streams_endpoint(struct xhci_hcd *xhci,
 	ret = xhci_check_args(xhci_to_hcd(xhci), udev, ep, 1, __func__);
 	if (ret &lt;= 0)
 		return -EINVAL;
-	if (!ep-&gt;ss_ep_comp) {
-		xhci_warn(xhci, "WARN: No SuperSpeed Endpoint Companion"
-				" descriptor for ep 0x%x\n",
-				ep-&gt;desc.bEndpointAddress);
-		return -EINVAL;
-	}
-	if (ep-&gt;ss_ep_comp-&gt;desc.bmAttributes == 0) {
+	if (ep-&gt;ss_ep_comp.bmAttributes == 0) {
 		xhci_warn(xhci, "WARN: SuperSpeed Endpoint Companion"
 				" descriptor for ep 0x%x does not support streams\n",
 				ep-&gt;desc.bEndpointAddress);
@@ -1540,7 +1534,6 @@ static int xhci_calculate_streams_and_bitmask(struct xhci_hcd *xhci,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		unsigned int *num_streams, u32 *changed_ep_bitmask)
 {
-	struct usb_host_ss_ep_comp *ss_ep_comp;
 	unsigned int max_streams;
 	unsigned int endpoint_flag;
 	int i;
@@ -1552,8 +1545,8 @@ static int xhci_calculate_streams_and_bitmask(struct xhci_hcd *xhci,
 		if (ret &lt; 0)
 			return ret;
 
-		ss_ep_comp = eps[i]-&gt;ss_ep_comp;
-		max_streams = USB_SS_MAX_STREAMS(ss_ep_comp-&gt;desc.bmAttributes);
+		max_streams = USB_SS_MAX_STREAMS(
+				eps[i]-&gt;ss_ep_comp.bmAttributes);
 		if (max_streams &lt; (*num_streams - 1)) {
 			xhci_dbg(xhci, "Ep 0x%x only supports %u stream IDs.\n",
 					eps[i]-&gt;desc.bEndpointAddress,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1ea25377ca0d..a748815ee629 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -45,27 +45,14 @@ struct wusb_dev;
 
 struct ep_device;
 
-/* For SS devices */
-/**
- * struct usb_host_ss_ep_comp - Valid for SuperSpeed devices only
- * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
- * @extra: descriptors following this endpoint companion descriptor
- * @extralen: how many bytes of "extra" are valid
- */
-struct usb_host_ss_ep_comp {
-	struct usb_ss_ep_comp_descriptor	desc;
-	unsigned char				*extra;   /* Extra descriptors */
-	int					extralen;
-};
-
 /**
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
+ * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
- * @ss_ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -74,11 +61,11 @@ struct usb_host_ss_ep_comp {
  * descriptor within an active interface in a given USB configuration.
  */
 struct usb_host_endpoint {
-	struct usb_endpoint_descriptor	desc;
+	struct usb_endpoint_descriptor		desc;
+	struct usb_ss_ep_comp_descriptor	ss_ep_comp;
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
-	struct usb_host_ss_ep_comp	*ss_ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;</pre>
    <div class="pagination">
        <a href='2_65.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><span>[66]</span><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_67.html'>Next&gt;&gt;</a>
    <div>
</body>
