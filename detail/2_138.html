<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_137.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><span>[138]</span><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_139.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 391eca9d8892a940ff8dbfee2ca78942e05c2d37
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 15:34:16 2005 -0400

    [PATCH] USB: dummy_hcd: add suspend/resume support
    
    This patch adds support to dummy_hcd for suspending and resuming the root
    hub and the emulated platform devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c78c64ae87af..4d692670f288 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -65,7 +65,7 @@
 
 
 #define DRIVER_DESC	"USB Host+Gadget Emulator"
-#define DRIVER_VERSION	"17 Dec 2004"
+#define DRIVER_VERSION	"02 May 2005"
 
 static const char	driver_name [] = "dummy_hcd";
 static const char	driver_desc [] = "USB Host+Gadget Emulator";
@@ -150,6 +150,13 @@ struct urbp {
 	struct list_head	urbp_list;
 };
 
+
+enum dummy_rh_state {
+	DUMMY_RH_RESET,
+	DUMMY_RH_SUSPENDED,
+	DUMMY_RH_RUNNING
+};
+
 struct dummy {
 	spinlock_t			lock;
 
@@ -163,6 +170,7 @@ struct dummy {
 	struct dummy_request		fifo_req;
 	u8				fifo_buf [FIFO_SIZE];
 	u16				devstatus;
+	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 	unsigned			active:1;
 	unsigned			old_active:1;
@@ -170,6 +178,7 @@ struct dummy {
 	/*
 	 * MASTER/HOST side support
 	 */
+	enum dummy_rh_state		rh_state;
 	struct timer_list		timer;
 	u32				port_status;
 	u32				old_status;
@@ -262,7 +271,9 @@ set_link_state (struct dummy *dum)
 	dum-&gt;active = 0;
 	if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) == 0)
 		dum-&gt;port_status = 0;
-	else if (!dum-&gt;pullup) {
+
+	/* UDC suspend must cause a disconnect */
+	else if (!dum-&gt;pullup || dum-&gt;udc_suspended) {
 		dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION |
 					USB_PORT_STAT_ENABLE |
 					USB_PORT_STAT_LOW_SPEED |
@@ -276,7 +287,8 @@ set_link_state (struct dummy *dum)
 			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 		if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0)
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
-		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0)
+		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0 &amp;&amp;
+				dum-&gt;rh_state != DUMMY_RH_SUSPENDED)
 			dum-&gt;active = 1;
 	}
 
@@ -675,11 +687,16 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if (!(dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
-			|| !(dum-&gt;devstatus &amp;
-				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+	if (!(dum-&gt;devstatus &amp;	( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
 				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
 		return -EINVAL;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0)
+		return -ENOLINK;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0 &amp;&amp;
+			 dum-&gt;rh_state != DUMMY_RH_SUSPENDED)
+		return -EIO;
+
+	/* FIXME: What if the root hub is suspended but the port isn't? */
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
@@ -917,11 +934,50 @@ static int dummy_udc_remove (struct device *dev)
 	return 0;
 }
 
+static int dummy_udc_suspend (struct device *dev, pm_message_t state,
+		u32 level)
+{
+	struct dummy	*dum = dev_get_drvdata(dev);
+
+	if (level != SUSPEND_DISABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;udc_suspended = 1;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	dev-&gt;power.power_state = state;
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
+	return 0;
+}
+
+static int dummy_udc_resume (struct device *dev, u32 level)
+{
+	struct dummy	*dum = dev_get_drvdata(dev);
+
+	if (level != RESUME_ENABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;udc_suspended = 0;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	dev-&gt;power.power_state = PMSG_ON;
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
+	return 0;
+}
+
 static struct device_driver dummy_udc_driver = {
 	.name		= (char *) gadget_name,
 	.bus		= &amp;platform_bus_type,
 	.probe		= dummy_udc_probe,
 	.remove		= dummy_udc_remove,
+	.suspend	= dummy_udc_suspend,
+	.resume		= dummy_udc_resume,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -980,7 +1036,16 @@ static int dummy_urb_enqueue (
 
 static int dummy_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	/* giveback happens automatically in timer callback */
+	struct dummy	*dum;
+	unsigned long	flags;
+
+	/* giveback happens automatically in timer callback,
+	 * so make sure the callback happens */
+	dum = hcd_to_dummy (hcd);
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	if (dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp; !list_empty(&amp;dum-&gt;urbp_list))
+		mod_timer (&amp;dum-&gt;timer, jiffies);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 	return 0;
 }
 
@@ -1222,7 +1287,8 @@ static void dummy_timer (unsigned long _dum)
 		if (urb-&gt;status != -EINPROGRESS) {
 			/* likely it was just unlinked */
 			goto return_urb;
-		}
+		} else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
+			continue;
 		type = usb_pipetype (urb-&gt;pipe);
 
 		/* used up this frame's non-periodic bandwidth?
@@ -1486,12 +1552,12 @@ static void dummy_timer (unsigned long _dum)
 		goto restart;
 	}
 
-	/* want a 1 msec delay here */
-	if (!list_empty (&amp;dum-&gt;urbp_list))
-		mod_timer (&amp;dum-&gt;timer, jiffies + msecs_to_jiffies(1));
-	else {
+	if (list_empty (&amp;dum-&gt;urbp_list)) {
 		usb_put_dev (dum-&gt;udev);
 		dum-&gt;udev = NULL;
+	} else if (dum-&gt;rh_state == DUMMY_RH_RUNNING) {
+		/* want a 1 msec delay here */
+		mod_timer (&amp;dum-&gt;timer, jiffies + msecs_to_jiffies(1));
 	}
 
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
@@ -1510,11 +1576,13 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 {
 	struct dummy		*dum;
 	unsigned long		flags;
-	int			retval;
+	int			retval = 0;
 
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	if (hcd-&gt;state != HC_STATE_RUNNING)
+		goto done;
 
 	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
 		dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
@@ -1522,14 +1590,15 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 		set_link_state (dum);
 	}
 
-	if (!(dum-&gt;port_status &amp; PORT_C_MASK))
-		retval = 0;
-	else {
+	if ((dum-&gt;port_status &amp; PORT_C_MASK) != 0) {
 		*buf = (1 &lt;&lt; 1);
 		dev_dbg (dummy_dev(dum), "port status 0x%08x has changes\n",
-			dum-&gt;port_status);
+				dum-&gt;port_status);
 		retval = 1;
+		if (dum-&gt;rh_state == DUMMY_RH_SUSPENDED)
+			usb_hcd_resume_root_hub (hcd);
 	}
+done:
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 	return retval;
 }
@@ -1559,6 +1628,9 @@ static int dummy_hub_control (
 	int		retval = 0;
 	unsigned long	flags;
 
+	if (hcd-&gt;state != HC_STATE_RUNNING)
+		return -ETIMEDOUT;
+
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
 	switch (typeReq) {
@@ -1658,6 +1730,7 @@ static int dummy_hub_control (
 			dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
 					| USB_PORT_STAT_LOW_SPEED
 					| USB_PORT_STAT_HIGH_SPEED);
+			dum-&gt;devstatus = 0;
 			/* 50msec reset signaling */
 			dum-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
 			/* FALLS THROUGH */
@@ -1684,6 +1757,29 @@ static int dummy_hub_control (
 	return retval;
 }
 
+static int dummy_hub_suspend (struct usb_hcd *hcd)
+{
+	struct dummy *dum = hcd_to_dummy (hcd);
+
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;rh_state = DUMMY_RH_SUSPENDED;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+	return 0;
+}
+
+static int dummy_hub_resume (struct usb_hcd *hcd)
+{
+	struct dummy *dum = hcd_to_dummy (hcd);
+
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;rh_state = DUMMY_RH_RUNNING;
+	set_link_state (dum);
+	if (!list_empty(&amp;dum-&gt;urbp_list))
+		mod_timer (&amp;dum-&gt;timer, jiffies);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+	return 0;
+}
 
 /*-------------------------------------------------------------------------*/
 
@@ -1751,6 +1847,7 @@ static int dummy_start (struct usb_hcd *hcd)
 	init_timer (&amp;dum-&gt;timer);
 	dum-&gt;timer.function = dummy_timer;
 	dum-&gt;timer.data = (unsigned long) dum;
+	dum-&gt;rh_state = DUMMY_RH_RUNNING;
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
@@ -1803,6 +1900,8 @@ static const struct hc_driver dummy_hcd = {
 
 	.hub_status_data = 	dummy_hub_status,
 	.hub_control = 		dummy_hub_control,
+	.hub_suspend =		dummy_hub_suspend,
+	.hub_resume =		dummy_hub_resume,
 };
 
 static int dummy_hcd_probe (struct device *dev)
@@ -1836,11 +1935,57 @@ static int dummy_hcd_remove (struct device *dev)
 	return 0;
 }
 
+static int dummy_hcd_suspend (struct device *dev, pm_message_t state,
+		u32 level)
+{
+	struct usb_hcd		*hcd;
+
+	if (level != SUSPEND_DISABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	hcd = dev_get_drvdata (dev);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	usb_lock_device (hcd-&gt;self.root_hub);
+	dummy_hub_suspend (hcd);
+	usb_unlock_device (hcd-&gt;self.root_hub);
+#endif
+
+	hcd-&gt;state = HC_STATE_SUSPENDED;
+	return 0;
+}
+
+static int dummy_hcd_resume (struct device *dev, u32 level)
+{
+	struct usb_hcd		*hcd;
+
+	if (level != RESUME_ENABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	hcd = dev_get_drvdata (dev);
+	hcd-&gt;state = HC_STATE_RUNNING;
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	usb_lock_device (hcd-&gt;self.root_hub);
+	dummy_hub_resume (hcd);
+	usb_unlock_device (hcd-&gt;self.root_hub);
+#endif
+
+	usb_hcd_poll_rh_status (hcd);
+	return 0;
+}
+
 static struct device_driver dummy_hcd_driver = {
 	.name		= (char *) driver_name,
 	.bus		= &amp;platform_bus_type,
 	.probe		= dummy_hcd_probe,
 	.remove		= dummy_hcd_remove,
+	.suspend	= dummy_hcd_suspend,
+	.resume		= dummy_hcd_resume,
 };
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit cc095b0b5b653dca3e106710a72ba28b5bb7456b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 15:28:38 2005 -0400

    [PATCH] USB: dummy_hcd: sparse cleanups
    
    This patch fixes the byte-ordering issue for setup packets in the
    dummy_hcd driver and cleans up a few things that sparse -Wbitwise
    dislikes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index f9540adf2a4f..c78c64ae87af 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -734,7 +734,7 @@ show_function (struct device *dev, struct device_attribute *attr, char *buf)
 		return 0;
 	return scnprintf (buf, PAGE_SIZE, "%s\n", dum-&gt;driver-&gt;function);
 }
-DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
+static DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
 
 /*-------------------------------------------------------------------------*/
 
@@ -857,6 +857,9 @@ EXPORT_SYMBOL (usb_gadget_unregister_driver);
 
 #undef is_enabled
 
+/* just declare this in any driver that really need it */
+extern int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode);
+
 int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
 {
 	return -ENOSYS;
@@ -1122,7 +1125,6 @@ static int periodic_bytes (struct dummy *dum, struct dummy_ep *ep)
 
 		/* high bandwidth mode */
 		tmp = le16_to_cpu(ep-&gt;desc-&gt;wMaxPacketSize);
-		tmp = le16_to_cpu (tmp);
 		tmp = (tmp &gt;&gt; 11) &amp; 0x03;
 		tmp *= 8 /* applies to entire frame */;
 		limit += limit * tmp;
@@ -1265,9 +1267,14 @@ static void dummy_timer (unsigned long _dum)
 			struct usb_ctrlrequest		setup;
 			int				value = 1;
 			struct dummy_ep			*ep2;
+			unsigned			w_index;
+			unsigned			w_value;
 
 			setup = *(struct usb_ctrlrequest*) urb-&gt;setup_packet;
-			if (setup.wLength != urb-&gt;transfer_buffer_length) {
+			w_index = le16_to_cpu(setup.wIndex);
+			w_value = le16_to_cpu(setup.wValue);
+			if (le16_to_cpu(setup.wLength) !=
+					urb-&gt;transfer_buffer_length) {
 				maybe_set_status (urb, -EOVERFLOW);
 				goto return_urb;
 			}
@@ -1297,16 +1304,16 @@ static void dummy_timer (unsigned long _dum)
 			case USB_REQ_SET_ADDRESS:
 				if (setup.bRequestType != Dev_Request)
 					break;
-				dum-&gt;address = setup.wValue;
+				dum-&gt;address = w_value;
 				maybe_set_status (urb, 0);
 				dev_dbg (udc_dev(dum), "set_address = %d\n",
-						setup.wValue);
+						w_value);
 				value = 0;
 				break;
 			case USB_REQ_SET_FEATURE:
 				if (setup.bRequestType == Dev_Request) {
 					value = 0;
-					switch (setup.wValue) {
+					switch (w_value) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						break;
 					case USB_DEVICE_B_HNP_ENABLE:
@@ -1324,14 +1331,13 @@ static void dummy_timer (unsigned long _dum)
 					}
 					if (value == 0) {
 						dum-&gt;devstatus |=
-							(1 &lt;&lt; setup.wValue);
+							(1 &lt;&lt; w_value);
 						maybe_set_status (urb, 0);
 					}
 
 				} else if (setup.bRequestType == Ep_Request) {
 					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
+					ep2 = find_endpoint (dum, w_index);
 					if (!ep2) {
 						value = -EOPNOTSUPP;
 						break;
@@ -1343,7 +1349,7 @@ static void dummy_timer (unsigned long _dum)
 				break;
 			case USB_REQ_CLEAR_FEATURE:
 				if (setup.bRequestType == Dev_Request) {
-					switch (setup.wValue) {
+					switch (w_value) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						dum-&gt;devstatus &amp;= ~(1 &lt;&lt;
 							USB_DEVICE_REMOTE_WAKEUP);
@@ -1356,8 +1362,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 				} else if (setup.bRequestType == Ep_Request) {
 					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
+					ep2 = find_endpoint (dum, w_index);
 					if (!ep2) {
 						value = -EOPNOTSUPP;
 						break;
@@ -1383,7 +1388,7 @@ static void dummy_timer (unsigned long _dum)
 					if (urb-&gt;transfer_buffer_length &gt; 0) {
 						if (setup.bRequestType ==
 								Ep_InRequest) {
-	ep2 = find_endpoint (dum, setup.wIndex);
+	ep2 = find_endpoint (dum, w_index);
 	if (!ep2) {
 		value = -EOPNOTSUPP;
 		break;
@@ -1535,7 +1540,8 @@ hub_descriptor (struct usb_hub_descriptor *desc)
 	memset (desc, 0, sizeof *desc);
 	desc-&gt;bDescriptorType = 0x29;
 	desc-&gt;bDescLength = 9;
-	desc-&gt;wHubCharacteristics = __constant_cpu_to_le16 (0x0001);
+	desc-&gt;wHubCharacteristics = (__force __u16)
+			(__constant_cpu_to_le16 (0x0001));
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;bitmap [0] = 0xff;
 	desc-&gt;bitmap [1] = 0xff;
@@ -1581,7 +1587,7 @@ static int dummy_hub_control (
 		hub_descriptor ((struct usb_hub_descriptor *) buf);
 		break;
 	case GetHubStatus:
-		*(u32 *) buf = __constant_cpu_to_le32 (0);
+		*(__le32 *) buf = __constant_cpu_to_le32 (0);
 		break;
 	case GetPortStatus:
 		if (wIndex != 1)
@@ -1621,8 +1627,8 @@ static int dummy_hub_control (
 			}
 		}
 		set_link_state (dum);
-		((u16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
-		((u16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
+		((__le16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
+		((__le16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
 		break;
 	case SetHubFeature:
 		retval = -EPIPE;</pre><hr><pre>commit 685eb93f086eb15d9fb1e82c7400fd750f564640
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:27:26 2005 -0400

    [PATCH] USB dummy_hcd: Use root-hub interrupts instead of polling
    
    This patch makes the dummy_hcd driver use emulated root-hub interrupts
    instead of polling.  It's in the spirit of similar changes being made to
    the other HCDs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 2d6d22951326..73d2f24050ab 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -684,6 +684,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
 	dum-&gt;re_timeout = jiffies + msecs_to_jiffies(20);
+	mod_timer (&amp;dummy_to_hcd (dum)-&gt;rh_timer, dum-&gt;re_timeout);
 	return 0;
 }
 
@@ -709,6 +710,8 @@ static int dummy_pullup (struct usb_gadget *_gadget, int value)
 	dum-&gt;pullup = (value != 0);
 	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 
@@ -811,6 +814,8 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;pullup = 1;
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
@@ -845,6 +850,7 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_unregister_driver);
@@ -1669,6 +1675,9 @@ static int dummy_hub_control (
 		retval = -EPIPE;
 	}
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
+	if ((dum-&gt;port_status &amp; PORT_C_MASK) != 0)
+		usb_hcd_poll_rh_status (hcd);
 	return retval;
 }
 
@@ -1745,6 +1754,7 @@ static int dummy_start (struct usb_hcd *hcd)
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
+	hcd-&gt;uses_new_polling = 1;
 
 #ifdef CONFIG_USB_OTG
 	hcd-&gt;self.otg_port = 1;</pre><hr><pre>commit f1c39fad7d1bbea31744138cd3a532ff346cd4ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:24:04 2005 -0400

    [PATCH] USB dummy_hcd: Centralize link state computations
    
    This patch adds to the dummy_hcd driver a new routine for keeping track of
    all changes in the state of the emulated USB link.  The logic is now kept
    in one spot instead of spread around, and it's easier to verify and
    update the code.  The behavior of the port features has been corrected in
    a few respects as well (for instance, if the POWER feature is clear then
    none of the other features can be set).
    
    Also added is support for the (relatively new) _connect() and
    _disconnect() calls of the Gadget API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index dc0e3233b0e9..2d6d22951326 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -163,12 +163,16 @@ struct dummy {
 	struct dummy_request		fifo_req;
 	u8				fifo_buf [FIFO_SIZE];
 	u16				devstatus;
+	unsigned			pullup:1;
+	unsigned			active:1;
+	unsigned			old_active:1;
 
 	/*
 	 * MASTER/HOST side support
 	 */
 	struct timer_list		timer;
 	u32				port_status;
+	u32				old_status;
 	unsigned			resuming:1;
 	unsigned long			re_timeout;
 
@@ -215,6 +219,98 @@ static struct dummy			*the_controller;
 
 /*-------------------------------------------------------------------------*/
 
+/* SLAVE/GADGET SIDE UTILITY ROUTINES */
+
+/* called with spinlock held */
+static void nuke (struct dummy *dum, struct dummy_ep *ep)
+{
+	while (!list_empty (&amp;ep-&gt;queue)) {
+		struct dummy_request	*req;
+
+		req = list_entry (ep-&gt;queue.next, struct dummy_request, queue);
+		list_del_init (&amp;req-&gt;queue);
+		req-&gt;req.status = -ESHUTDOWN;
+
+		spin_unlock (&amp;dum-&gt;lock);
+		req-&gt;req.complete (&amp;ep-&gt;ep, &amp;req-&gt;req);
+		spin_lock (&amp;dum-&gt;lock);
+	}
+}
+
+/* caller must hold lock */
+static void
+stop_activity (struct dummy *dum)
+{
+	struct dummy_ep	*ep;
+
+	/* prevent any more requests */
+	dum-&gt;address = 0;
+
+	/* The timer is left running so that outstanding URBs can fail */
+
+	/* nuke any pending requests first, so driver i/o is quiesced */
+	list_for_each_entry (ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)
+		nuke (dum, ep);
+
+	/* driver now does any non-usb quiescing necessary */
+}
+
+/* caller must hold lock */
+static void
+set_link_state (struct dummy *dum)
+{
+	dum-&gt;active = 0;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) == 0)
+		dum-&gt;port_status = 0;
+	else if (!dum-&gt;pullup) {
+		dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION |
+					USB_PORT_STAT_ENABLE |
+					USB_PORT_STAT_LOW_SPEED |
+					USB_PORT_STAT_HIGH_SPEED |
+					USB_PORT_STAT_SUSPEND);
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0)
+			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	} else {
+		dum-&gt;port_status |= USB_PORT_STAT_CONNECTION;
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) == 0)
+			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0)
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
+		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0)
+			dum-&gt;active = 1;
+	}
+
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 || dum-&gt;active)
+		dum-&gt;resuming = 0;
+
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||
+			(dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0 &amp;&amp;
+				(dum-&gt;old_status &amp; USB_PORT_STAT_RESET) == 0 &amp;&amp;
+				dum-&gt;driver) {
+			stop_activity (dum);
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;disconnect (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		}
+	} else if (dum-&gt;active != dum-&gt;old_active) {
+		if (dum-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		} else if (!dum-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;resume) {
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;resume (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		}
+	}
+
+	dum-&gt;old_status = dum-&gt;port_status;
+	dum-&gt;old_active = dum-&gt;active;
+}
+
+/*-------------------------------------------------------------------------*/
+
 /* SLAVE/GADGET SIDE DRIVER
  *
  * This only tracks gadget state.  All the work is done when the host
@@ -339,22 +435,6 @@ dummy_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	return retval;
 }
 
-/* called with spinlock held */
-static void nuke (struct dummy *dum, struct dummy_ep *ep)
-{
-	while (!list_empty (&amp;ep-&gt;queue)) {
-		struct dummy_request	*req;
-
-		req = list_entry (ep-&gt;queue.next, struct dummy_request, queue);
-		list_del_init (&amp;req-&gt;queue);
-		req-&gt;req.status = -ESHUTDOWN;
-
-		spin_unlock (&amp;dum-&gt;lock);
-		req-&gt;req.complete (&amp;ep-&gt;ep, &amp;req-&gt;req);
-		spin_lock (&amp;dum-&gt;lock);
-	}
-}
-
 static int dummy_disable (struct usb_ep *_ep)
 {
 	struct dummy_ep		*ep;
@@ -603,7 +683,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
-	dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+	dum-&gt;re_timeout = jiffies + msecs_to_jiffies(20);
 	return 0;
 }
 
@@ -619,10 +699,24 @@ static int dummy_set_selfpowered (struct usb_gadget *_gadget, int value)
 	return 0;
 }
 
+static int dummy_pullup (struct usb_gadget *_gadget, int value)
+{
+	struct dummy	*dum;
+	unsigned long	flags;
+
+	dum = gadget_to_dummy (_gadget);
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	dum-&gt;pullup = (value != 0);
+	set_link_state (dum);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+	return 0;
+}
+
 static const struct usb_gadget_ops dummy_ops = {
 	.get_frame	= dummy_g_get_frame,
 	.wakeup		= dummy_wakeup,
 	.set_selfpowered = dummy_set_selfpowered,
+	.pullup		= dummy_pullup,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -675,7 +769,6 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	 */
 
 	dum-&gt;devstatus = 0;
-	dum-&gt;resuming = 0;
 
 	INIT_LIST_HEAD (&amp;dum-&gt;gadget.ep_list);
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
@@ -714,35 +807,14 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	device_bind_driver (&amp;dum-&gt;gadget.dev);
 
 	/* khubd will enumerate this in a while */
-	dum-&gt;port_status |= USB_PORT_STAT_CONNECTION
-		| (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;pullup = 1;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
 
-/* caller must hold lock */
-static void
-stop_activity (struct dummy *dum, struct usb_gadget_driver *driver)
-{
-	struct dummy_ep	*ep;
-
-	/* prevent any more requests */
-	dum-&gt;address = 0;
-
-	/* The timer is left running so that outstanding URBs can fail */
-
-	/* nuke any pending requests first, so driver i/o is quiesced */
-	list_for_each_entry (ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)
-		nuke (dum, ep);
-
-	/* driver now does any non-usb quiescing necessary */
-	if (driver) {
-		spin_unlock (&amp;dum-&gt;lock);
-		driver-&gt;disconnect (&amp;dum-&gt;gadget);
-		spin_lock (&amp;dum-&gt;lock);
-	}
-}
-
 int
 usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 {
@@ -758,10 +830,8 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 			driver-&gt;driver.name);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	stop_activity (dum, driver);
-	dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE |
-			USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
-	dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	driver-&gt;unbind (&amp;dum-&gt;gadget);
@@ -770,6 +840,11 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	device_release_driver (&amp;dum-&gt;gadget.dev);
 	driver_unregister (&amp;driver-&gt;driver);
 
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_unregister_driver);
@@ -1432,6 +1507,13 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+
+	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
+		dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+		dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
+		set_link_state (dum);
+	}
+
 	if (!(dum-&gt;port_status &amp; PORT_C_MASK))
 		retval = 0;
 	else {
@@ -1480,16 +1562,16 @@ static int dummy_hub_control (
 				/* 20msec resume signaling */
 				dum-&gt;resuming = 1;
 				dum-&gt;re_timeout = jiffies +
-							msecs_to_jiffies(20);
+						msecs_to_jiffies(20);
 			}
 			break;
 		case USB_PORT_FEAT_POWER:
-			dum-&gt;port_status = 0;
-			dum-&gt;resuming = 0;
-			stop_activity(dum, dum-&gt;driver);
-			break;
+			if (dum-&gt;port_status &amp; USB_PORT_STAT_POWER)
+				dev_dbg (dummy_dev(dum), "power-off\n");
+			/* FALLS THROUGH */
 		default:
 			dum-&gt;port_status &amp;= ~(1 &lt;&lt; wValue);
+			set_link_state (dum);
 		}
 		break;
 	case GetHubDescriptor:
@@ -1505,23 +1587,16 @@ static int dummy_hub_control (
 		/* whoever resets or resumes must GetPortStatus to
 		 * complete it!!
 		 */
-		if (dum-&gt;resuming &amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
+		if (dum-&gt;resuming &amp;&amp;
+				time_after_eq (jiffies, dum-&gt;re_timeout)) {
 			dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
-			dum-&gt;resuming = 0;
-			dum-&gt;re_timeout = 0;
-			if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;resume) {
-				spin_unlock (&amp;dum-&gt;lock);
-				dum-&gt;driver-&gt;resume (&amp;dum-&gt;gadget);
-				spin_lock (&amp;dum-&gt;lock);
-			}
 		}
-		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0
-				&amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0 &amp;&amp;
+				time_after_eq (jiffies, dum-&gt;re_timeout)) {
 			dum-&gt;port_status |= (USB_PORT_STAT_C_RESET &lt;&lt; 16);
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_RESET;
-			dum-&gt;re_timeout = 0;
-			if (dum-&gt;driver) {
+			if (dum-&gt;pullup) {
 				dum-&gt;port_status |= USB_PORT_STAT_ENABLE;
 				/* give it the best speed we agree on */
 				dum-&gt;gadget.speed = dum-&gt;driver-&gt;speed;
@@ -1542,6 +1617,7 @@ static int dummy_hub_control (
 				}
 			}
 		}
+		set_link_state (dum);
 		((u16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
 		((u16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
 		break;
@@ -1551,42 +1627,36 @@ static int dummy_hub_control (
 	case SetPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
-					== 0) {
+			if (dum-&gt;active) {
 				dum-&gt;port_status |= USB_PORT_STAT_SUSPEND;
-				if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;suspend) {
-					spin_unlock (&amp;dum-&gt;lock);
-					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
-					spin_lock (&amp;dum-&gt;lock);
-					/* HNP would happen here; for now we
-					 * assume b_bus_req is always true.
-					 */
-					if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
-							&amp; dum-&gt;devstatus) != 0)
-						dev_dbg (dummy_dev(dum),
+
+				/* HNP would happen here; for now we
+				 * assume b_bus_req is always true.
+				 */
+				set_link_state (dum);
+				if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+						&amp; dum-&gt;devstatus) != 0)
+					dev_dbg (dummy_dev(dum),
 							"no HNP yet!\n");
-				}
 			}
 			break;
+		case USB_PORT_FEAT_POWER:
+			dum-&gt;port_status |= USB_PORT_STAT_POWER;
+			set_link_state (dum);
+			break;
 		case USB_PORT_FEAT_RESET:
-			/* if it's already running, disconnect first */
-			if (dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) {
-				dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
-						| USB_PORT_STAT_LOW_SPEED
-						| USB_PORT_STAT_HIGH_SPEED);
-				if (dum-&gt;driver) {
-					dev_dbg (udc_dev(dum),
-							"disconnect\n");
-					stop_activity (dum, dum-&gt;driver);
-				}
-
-				/* FIXME test that code path! */
-			}
+			/* if it's already enabled, disable */
+			dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
+					| USB_PORT_STAT_LOW_SPEED
+					| USB_PORT_STAT_HIGH_SPEED);
 			/* 50msec reset signaling */
 			dum-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
-			/* FALLTHROUGH */
+			/* FALLS THROUGH */
 		default:
-			dum-&gt;port_status |= (1 &lt;&lt; wValue);
+			if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) != 0) {
+				dum-&gt;port_status |= (1 &lt;&lt; wValue);
+				set_link_state (dum);
+			}
 		}
 		break;
 </pre><hr><pre>commit d9b762510c186584a6be0d3ece03e8a4b2ac13a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:15:43 2005 -0400

    [PATCH] USB dummy_hcd: Use separate pdevs for HC and UDC
    
    This patch makes the dummy_hcd driver create separate platform devices for
    the emulated host controller and emulated device controller.  This gives a
    more accurate simulation and will permit testing of situations where only
    one of the two devices is suspended.
    
    This also changes the name of the host controller platform device to match
    the name of the driver.  That way the normal platform bus probe mechanism
    will handle binding the driver to the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index ffedf4d1b747..dc0e3233b0e9 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -141,6 +141,8 @@ static const char *const ep_name [] = {
 };
 #define DUMMY_ENDPOINTS	(sizeof(ep_name)/sizeof(char *))
 
+/*-------------------------------------------------------------------------*/
+
 #define FIFO_SIZE		64
 
 struct urbp {
@@ -189,6 +191,11 @@ static inline struct device *dummy_dev (struct dummy *dum)
 	return dummy_to_hcd(dum)-&gt;self.controller;
 }
 
+static inline struct device *udc_dev (struct dummy *dum)
+{
+	return dum-&gt;gadget.dev.parent;
+}
+
 static inline struct dummy *ep_to_dummy (struct dummy_ep *ep)
 {
 	return container_of (ep-&gt;gadget, struct dummy, gadget);
@@ -208,19 +215,6 @@ static struct dummy			*the_controller;
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * This "hardware" may look a bit odd in diagnostics since it's got both
- * host and device sides; and it binds different drivers to each side.
- */
-static struct platform_device		the_pdev;
-
-static struct device_driver dummy_driver = {
-	.name		= (char *) driver_name,
-	.bus		= &amp;platform_bus_type,
-};
-
-/*-------------------------------------------------------------------------*/
-
 /* SLAVE/GADGET SIDE DRIVER
  *
  * This only tracks gadget state.  All the work is done when the host
@@ -324,7 +318,7 @@ dummy_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	_ep-&gt;maxpacket = max;
 	ep-&gt;desc = desc;
 
-	dev_dbg (dummy_dev(dum), "enabled %s (ep%d%s-%s) maxpacket %d\n",
+	dev_dbg (udc_dev(dum), "enabled %s (ep%d%s-%s) maxpacket %d\n",
 		_ep-&gt;name,
 		desc-&gt;bEndpointAddress &amp; 0x0f,
 		(desc-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
@@ -379,7 +373,7 @@ static int dummy_disable (struct usb_ep *_ep)
 	nuke (dum, ep);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
-	dev_dbg (dummy_dev(dum), "disabled %s\n", _ep-&gt;name);
+	dev_dbg (udc_dev(dum), "disabled %s\n", _ep-&gt;name);
 	return retval;
 }
 
@@ -474,7 +468,7 @@ dummy_queue (struct usb_ep *_ep, struct usb_request *_req, int mem_flags)
 		return -ESHUTDOWN;
 
 #if 0
-	dev_dbg (dummy_dev(dum), "ep %p queue req %p to %s, len %d buf %p\n",
+	dev_dbg (udc_dev(dum), "ep %p queue req %p to %s, len %d buf %p\n",
 			ep, _req, _ep-&gt;name, _req-&gt;length, _req-&gt;buf);
 #endif
 
@@ -537,7 +531,7 @@ static int dummy_dequeue (struct usb_ep *_ep, struct usb_request *_req)
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	if (retval == 0) {
-		dev_dbg (dummy_dev(dum),
+		dev_dbg (udc_dev(dum),
 				"dequeued req %p from %s, len %d buf %p\n",
 				req, _ep-&gt;name, _req-&gt;length, _req-&gt;buf);
 		_req-&gt;complete (_ep, _req);
@@ -661,38 +655,6 @@ DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
  * for each driver that registers:  just add to a big root hub.
  */
 
-/* This doesn't need to do anything because the udc device structure is
- * stored inside the hcd and will be deallocated along with it. */
-static void
-dummy_udc_release (struct device *dev) {}
-
-/* This doesn't need to do anything because the pdev structure is
- * statically allocated. */
-static void
-dummy_pdev_release (struct device *dev) {}
-
-static int
-dummy_register_udc (struct dummy *dum)
-{
-	int		rc;
-
-	strcpy (dum-&gt;gadget.dev.bus_id, "udc");
-	dum-&gt;gadget.dev.parent = dummy_dev(dum);
-	dum-&gt;gadget.dev.release = dummy_udc_release;
-
-	rc = device_register (&amp;dum-&gt;gadget.dev);
-	if (rc == 0)
-		device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
-	return rc;
-}
-
-static void
-dummy_unregister_udc (struct dummy *dum)
-{
-	device_remove_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
-	device_unregister (&amp;dum-&gt;gadget.dev);
-}
-
 int
 usb_gadget_register_driver (struct usb_gadget_driver *driver)
 {
@@ -711,12 +673,6 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	 * SLAVE side init ... the layer above hardware, which
 	 * can't enumerate without help from the driver we're binding.
 	 */
-	dum-&gt;gadget.name = gadget_name;
-	dum-&gt;gadget.ops = &amp;dummy_ops;
-	dum-&gt;gadget.is_dualspeed = 1;
-
-	/* maybe claim OTG support, though we won't complete HNP */
-	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
 
 	dum-&gt;devstatus = 0;
 	dum-&gt;resuming = 0;
@@ -745,7 +701,7 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 
 	dum-&gt;driver = driver;
 	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
-	dev_dbg (dummy_dev(dum), "binding gadget driver '%s'\n",
+	dev_dbg (udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
 	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0) {
 		dum-&gt;driver = NULL;
@@ -798,7 +754,7 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	if (!driver || driver != dum-&gt;driver)
 		return -EINVAL;
 
-	dev_dbg (dummy_dev(dum), "unregister gadget driver '%s'\n",
+	dev_dbg (udc_dev(dum), "unregister gadget driver '%s'\n",
 			driver-&gt;driver.name);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
@@ -826,6 +782,64 @@ int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
 }
 EXPORT_SYMBOL (net2280_set_fifo_mode);
 
+
+/* The gadget structure is stored inside the hcd structure and will be
+ * released along with it. */
+static void
+dummy_gadget_release (struct device *dev)
+{
+#if 0		/* usb_bus_put isn't EXPORTed! */
+	struct dummy	*dum = gadget_dev_to_dummy (dev);
+
+	usb_bus_put (&amp;dummy_to_hcd (dum)-&gt;self);
+#endif
+}
+
+static int dummy_udc_probe (struct device *dev)
+{
+	struct dummy	*dum = the_controller;
+	int		rc;
+
+	dum-&gt;gadget.name = gadget_name;
+	dum-&gt;gadget.ops = &amp;dummy_ops;
+	dum-&gt;gadget.is_dualspeed = 1;
+
+	/* maybe claim OTG support, though we won't complete HNP */
+	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
+
+	strcpy (dum-&gt;gadget.dev.bus_id, "gadget");
+	dum-&gt;gadget.dev.parent = dev;
+	dum-&gt;gadget.dev.release = dummy_gadget_release;
+	rc = device_register (&amp;dum-&gt;gadget.dev);
+	if (rc &lt; 0)
+		return rc;
+
+#if 0		/* usb_bus_get isn't EXPORTed! */
+	usb_bus_get (&amp;dummy_to_hcd (dum)-&gt;self);
+#endif
+
+	dev_set_drvdata (dev, dum);
+	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	return rc;
+}
+
+static int dummy_udc_remove (struct device *dev)
+{
+	struct dummy	*dum = dev_get_drvdata (dev);
+
+	dev_set_drvdata (dev, NULL);
+	device_remove_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	device_unregister (&amp;dum-&gt;gadget.dev);
+	return 0;
+}
+
+static struct device_driver dummy_udc_driver = {
+	.name		= (char *) gadget_name,
+	.bus		= &amp;platform_bus_type,
+	.probe		= dummy_udc_probe,
+	.remove		= dummy_udc_remove,
+};
+
 /*-------------------------------------------------------------------------*/
 
 /* MASTER/HOST SIDE DRIVER
@@ -1184,7 +1198,7 @@ static void dummy_timer (unsigned long _dum)
 			list_for_each_entry (req, &amp;ep-&gt;queue, queue) {
 				list_del_init (&amp;req-&gt;queue);
 				req-&gt;req.status = -EOVERFLOW;
-				dev_dbg (dummy_dev(dum), "stale req = %p\n",
+				dev_dbg (udc_dev(dum), "stale req = %p\n",
 						req);
 
 				spin_unlock (&amp;dum-&gt;lock);
@@ -1207,7 +1221,7 @@ static void dummy_timer (unsigned long _dum)
 					break;
 				dum-&gt;address = setup.wValue;
 				maybe_set_status (urb, 0);
-				dev_dbg (dummy_dev(dum), "set_address = %d\n",
+				dev_dbg (udc_dev(dum), "set_address = %d\n",
 						setup.wValue);
 				value = 0;
 				break;
@@ -1333,7 +1347,7 @@ static void dummy_timer (unsigned long _dum)
 
 			if (value &lt; 0) {
 				if (value != -EOPNOTSUPP)
-					dev_dbg (dummy_dev(dum),
+					dev_dbg (udc_dev(dum),
 						"setup --&gt; %d\n",
 						value);
 				maybe_set_status (urb, -EPIPE);
@@ -1561,7 +1575,7 @@ static int dummy_hub_control (
 						| USB_PORT_STAT_LOW_SPEED
 						| USB_PORT_STAT_HIGH_SPEED);
 				if (dum-&gt;driver) {
-					dev_dbg (dummy_dev(dum),
+					dev_dbg (udc_dev(dum),
 							"disconnect\n");
 					stop_activity (dum, dum-&gt;driver);
 				}
@@ -1643,7 +1657,6 @@ static DEVICE_ATTR (urbs, S_IRUGO, show_urbs, NULL);
 static int dummy_start (struct usb_hcd *hcd)
 {
 	struct dummy		*dum;
-	int			retval;
 
 	dum = hcd_to_dummy (hcd);
 
@@ -1659,9 +1672,6 @@ static int dummy_start (struct usb_hcd *hcd)
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
-	if ((retval = dummy_register_udc (dum)) != 0)
-		return retval;
-
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
@@ -1682,10 +1692,7 @@ static void dummy_stop (struct usb_hcd *hcd)
 	dum = hcd_to_dummy (hcd);
 
 	device_remove_file (dummy_dev(dum), &amp;dev_attr_urbs);
-
 	usb_gadget_unregister_driver (dum-&gt;driver);
-	dummy_unregister_udc (dum);
-
 	dev_info (dummy_dev(dum), "stopped\n");
 }
 
@@ -1715,7 +1722,7 @@ static const struct hc_driver dummy_hcd = {
 	.hub_control = 		dummy_hub_control,
 };
 
-static int dummy_probe (struct device *dev)
+static int dummy_hcd_probe (struct device *dev)
 {
 	struct usb_hcd		*hcd;
 	int			retval;
@@ -1735,7 +1742,7 @@ static int dummy_probe (struct device *dev)
 	return retval;
 }
 
-static void dummy_remove (struct device *dev)
+static int dummy_hcd_remove (struct device *dev)
 {
 	struct usb_hcd		*hcd;
 
@@ -1743,35 +1750,41 @@ static void dummy_remove (struct device *dev)
 	usb_remove_hcd (hcd);
 	usb_put_hcd (hcd);
 	the_controller = NULL;
+	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
-static int dummy_pdev_detect (void)
-{
-	int			retval;
-
-	retval = driver_register (&amp;dummy_driver);
-	if (retval &lt; 0)
-		return retval;
+static struct device_driver dummy_hcd_driver = {
+	.name		= (char *) driver_name,
+	.bus		= &amp;platform_bus_type,
+	.probe		= dummy_hcd_probe,
+	.remove		= dummy_hcd_remove,
+};
 
-	the_pdev.name = "hc";
-	the_pdev.dev.driver = &amp;dummy_driver;
-	the_pdev.dev.release = dummy_pdev_release;
+/*-------------------------------------------------------------------------*/
 
-	retval = platform_device_register (&amp;the_pdev);
-	if (retval &lt; 0)
-		driver_unregister (&amp;dummy_driver);
-	return retval;
-}
+/* These don't need to do anything because the pdev structures are
+ * statically allocated. */
+static void
+dummy_udc_release (struct device *dev) {}
 
-static void dummy_pdev_remove (void)
-{
-	platform_device_unregister (&amp;the_pdev);
-	driver_unregister (&amp;dummy_driver);
-}
+static void
+dummy_hcd_release (struct device *dev) {}
+
+static struct platform_device		the_udc_pdev = {
+	.name		= (char *) gadget_name,
+	.id		= -1,
+	.dev		= {
+		.release	= dummy_udc_release,
+	},
+};
 
-/*-------------------------------------------------------------------------*/
+static struct platform_device		the_hcd_pdev = {
+	.name		= (char *) driver_name,
+	.id		= -1,
+	.dev		= {
+		.release	= dummy_hcd_release,
+	},
+};
 
 static int __init init (void)
 {
@@ -1779,17 +1792,39 @@ static int __init init (void)
 
 	if (usb_disabled ())
 		return -ENODEV;
-	if ((retval = dummy_pdev_detect ()) != 0)
+
+	retval = driver_register (&amp;dummy_hcd_driver);
+	if (retval &lt; 0)
 		return retval;
-	if ((retval = dummy_probe (&amp;the_pdev.dev)) != 0)
-		dummy_pdev_remove ();
+
+	retval = driver_register (&amp;dummy_udc_driver);
+	if (retval &lt; 0)
+		goto err_register_udc_driver;
+
+	retval = platform_device_register (&amp;the_hcd_pdev);
+	if (retval &lt; 0)
+		goto err_register_hcd;
+
+	retval = platform_device_register (&amp;the_udc_pdev);
+	if (retval &lt; 0)
+		goto err_register_udc;
+	return retval;
+
+err_register_udc:
+	platform_device_unregister (&amp;the_hcd_pdev);
+err_register_hcd:
+	driver_unregister (&amp;dummy_udc_driver);
+err_register_udc_driver:
+	driver_unregister (&amp;dummy_hcd_driver);
 	return retval;
 }
 module_init (init);
 
 static void __exit cleanup (void)
 {
-	dummy_remove (&amp;the_pdev.dev);
-	dummy_pdev_remove ();
+	platform_device_unregister (&amp;the_udc_pdev);
+	platform_device_unregister (&amp;the_hcd_pdev);
+	driver_unregister (&amp;dummy_udc_driver);
+	driver_unregister (&amp;dummy_hcd_driver);
 }
 module_exit (cleanup);</pre><hr><pre>commit c2db8b5e5692a6f35913a829607ee6efde3c7cbd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 29 16:30:48 2005 -0400

    [PATCH] USB: dummy_hcd: USB_PORT_FEAT changed to USB_PORT_STAT
    
    This patch makes some cosmetic changes to dummy_hcd:
    
            Minor alterations of comments and whitespace.
    
            Replace USB_PORT_FEAT_xxx with USB_PORT_STAT_xxx.  This is
            appropriate as the values are stored in a status variable
            and they aren't feature indices.  Also it allows the
            elimination of a bunch of awkward bit shift operations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index e9b95df5b23d..ffedf4d1b747 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -601,7 +601,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if (!(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+	if (!(dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
 			|| !(dum-&gt;devstatus &amp;
 				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
 				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
@@ -609,7 +609,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
-	dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND);
+	dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
 	return 0;
 }
 
@@ -661,15 +661,15 @@ DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
  * for each driver that registers:  just add to a big root hub.
  */
 
+/* This doesn't need to do anything because the udc device structure is
+ * stored inside the hcd and will be deallocated along with it. */
 static void
-dummy_udc_release (struct device *dev)
-{
-}
+dummy_udc_release (struct device *dev) {}
 
+/* This doesn't need to do anything because the pdev structure is
+ * statically allocated. */
 static void
-dummy_pdev_release (struct device *dev)
-{
-}
+dummy_pdev_release (struct device *dev) {}
 
 static int
 dummy_register_udc (struct dummy *dum)
@@ -753,15 +753,13 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 		return retval;
 	}
 
-	// FIXME: Check these calls for errors and re-order
 	driver-&gt;driver.bus = dum-&gt;gadget.dev.parent-&gt;bus;
 	driver_register (&amp;driver-&gt;driver);
-
 	device_bind_driver (&amp;dum-&gt;gadget.dev);
 
 	/* khubd will enumerate this in a while */
 	dum-&gt;port_status |= USB_PORT_STAT_CONNECTION
-		| (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+		| (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
@@ -807,14 +805,13 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	stop_activity (dum, driver);
 	dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE |
 			USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
-	dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+	dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	driver-&gt;unbind (&amp;dum-&gt;gadget);
 	dum-&gt;driver = NULL;
 
 	device_release_driver (&amp;dum-&gt;gadget.dev);
-
 	driver_unregister (&amp;driver-&gt;driver);
 
 	return 0;
@@ -1406,11 +1403,11 @@ static void dummy_timer (unsigned long _dum)
 /*-------------------------------------------------------------------------*/
 
 #define PORT_C_MASK \
-	 ((1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_ENABLE) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_RESET))
+	((USB_PORT_STAT_C_CONNECTION \
+	| USB_PORT_STAT_C_ENABLE \
+	| USB_PORT_STAT_C_SUSPEND \
+	| USB_PORT_STAT_C_OVERCURRENT \
+	| USB_PORT_STAT_C_RESET) &lt;&lt; 16)
 
 static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 {
@@ -1465,7 +1462,7 @@ static int dummy_hub_control (
 	case ClearPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if (dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)) {
+			if (dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) {
 				/* 20msec resume signaling */
 				dum-&gt;resuming = 1;
 				dum-&gt;re_timeout = jiffies +
@@ -1495,8 +1492,8 @@ static int dummy_hub_control (
 		 * complete it!!
 		 */
 		if (dum-&gt;resuming &amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
-			dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND);
-			dum-&gt;port_status &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
+			dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
 			dum-&gt;resuming = 0;
 			dum-&gt;re_timeout = 0;
 			if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;resume) {
@@ -1505,10 +1502,10 @@ static int dummy_hub_control (
 				spin_lock (&amp;dum-&gt;lock);
 			}
 		}
-		if ((dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_RESET)) != 0
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0
 				&amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
-			dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_RESET);
-			dum-&gt;port_status &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_RESET);
+			dum-&gt;port_status |= (USB_PORT_STAT_C_RESET &lt;&lt; 16);
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_RESET;
 			dum-&gt;re_timeout = 0;
 			if (dum-&gt;driver) {
 				dum-&gt;port_status |= USB_PORT_STAT_ENABLE;
@@ -1540,10 +1537,9 @@ static int dummy_hub_control (
 	case SetPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if ((dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+			if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
 					== 0) {
-				dum-&gt;port_status |=
-						(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
+				dum-&gt;port_status |= USB_PORT_STAT_SUSPEND;
 				if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;suspend) {
 					spin_unlock (&amp;dum-&gt;lock);
 					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);</pre><hr><pre>commit 5742b0c95026c817d9c266174ca39a909e8d38ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 2 11:25:17 2005 -0400

    [PATCH] USB dummy_hcd: Partial OTG emulation
    
    Partial OTG support for dummy_hcd, mostly as a framework for further work.
    It emulates the new OTG flags in the host and peripheral frameworks, if
    that option is configured.  But it's incomplete:
    
      - Resetting the peripheral needs to clear the OTG state bits;
        a second enumeration won't work correctly.
    
      - This stops modeling HNP right when roles should switch the first time.
        It should probably disconnect, then set the usb_bus.is_b_host and
        usb_gadget.is_a_peripheral flags; then it'd enumerate almost normally,
        except for the role reversal.  Roles could then switch a second time,
        back to "normal" (with those flags cleared).
    
      - SRP should be modeled as "resume from port-unpowered", which is
        a state that usbcore doesn't yet use.
    
    HNP can be triggered by enabling the OTG whitelist and configuring a
    gadget driver that's not in that list; or by configuring Gadget Zero
    to identify itself as the HNP test device.
    
    Sent-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 1918d10f7569..e9b95df5b23d 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -601,8 +601,10 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if ((dum-&gt;devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) == 0
-			|| !(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)))
+	if (!(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+			|| !(dum-&gt;devstatus &amp;
+				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
 		return -EINVAL;
 
 	/* hub notices our request, issues downstream resume, etc */
@@ -713,6 +715,9 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;gadget.ops = &amp;dummy_ops;
 	dum-&gt;gadget.is_dualspeed = 1;
 
+	/* maybe claim OTG support, though we won't complete HNP */
+	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
+
 	dum-&gt;devstatus = 0;
 	dum-&gt;resuming = 0;
 
@@ -1215,6 +1220,16 @@ static void dummy_timer (unsigned long _dum)
 					switch (setup.wValue) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						break;
+					case USB_DEVICE_B_HNP_ENABLE:
+						dum-&gt;gadget.b_hnp_enable = 1;
+						break;
+					case USB_DEVICE_A_HNP_SUPPORT:
+						dum-&gt;gadget.a_hnp_support = 1;
+						break;
+					case USB_DEVICE_A_ALT_HNP_SUPPORT:
+						dum-&gt;gadget.a_alt_hnp_support
+							= 1;
+						break;
 					default:
 						value = -EOPNOTSUPP;
 					}
@@ -1533,6 +1548,13 @@ static int dummy_hub_control (
 					spin_unlock (&amp;dum-&gt;lock);
 					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
 					spin_lock (&amp;dum-&gt;lock);
+					/* HNP would happen here; for now we
+					 * assume b_bus_req is always true.
+					 */
+					if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+							&amp; dum-&gt;devstatus) != 0)
+						dev_dbg (dummy_dev(dum),
+							"no HNP yet!\n");
 				}
 			}
 			break;
@@ -1648,6 +1670,10 @@ static int dummy_start (struct usb_hcd *hcd)
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
+#ifdef CONFIG_USB_OTG
+	hcd-&gt;self.otg_port = 1;
+#endif
+
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
 	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 	return 0;</pre><hr><pre>commit 247f3105636caa9d1d8a4c3dfb755de42633bc80
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:28:04 2005 -0400

    [PATCH] USB HCDs: no longer need to register root hub
    
    This patch changes the host controller drivers; they no longer need to
    register their root hubs because usbcore will take care of it for them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 9d37fc771b27..1918d10f7569 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1625,7 +1625,6 @@ static DEVICE_ATTR (urbs, S_IRUGO, show_urbs, NULL);
 static int dummy_start (struct usb_hcd *hcd)
 {
 	struct dummy		*dum;
-	struct usb_device	*root;
 	int			retval;
 
 	dum = hcd_to_dummy (hcd);
@@ -1642,35 +1641,16 @@ static int dummy_start (struct usb_hcd *hcd)
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
-	root = usb_alloc_dev (NULL, &amp;hcd-&gt;self, 0);
-	if (!root)
-		return -ENOMEM;
+	if ((retval = dummy_register_udc (dum)) != 0)
+		return retval;
 
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
-
-	/* root hub enters addressed state... */
 	hcd-&gt;state = HC_STATE_RUNNING;
-	root-&gt;speed = USB_SPEED_HIGH;
-
-	/* ...then configured, so khubd sees us. */
-	if ((retval = usb_hcd_register_root_hub (root, hcd)) != 0) {
-		goto err1;
-	}
-
-	if ((retval = dummy_register_udc (dum)) != 0)
-		goto err2;
 
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
 	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 	return 0;
-
- err2:
-	usb_disconnect (&amp;hcd-&gt;self.root_hub);
- err1:
-	usb_put_dev (root);
-	hcd-&gt;state = HC_STATE_QUIESCING;
-	return retval;
 }
 
 static void dummy_stop (struct usb_hcd *hcd)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bc69bd7acebe..527abc693b17 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -492,8 +492,6 @@ static int ehci_start (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
-	struct usb_device	*udev;
-	struct usb_bus		*bus;
 	int			retval;
 	u32			hcc_params;
 	u8                      sbrn = 0;
@@ -631,17 +629,6 @@ static int ehci_start (struct usb_hcd *hcd)
 
 	/* set async sleep time = 10 us ... ? */
 
-	/* wire up the root hub */
-	bus = hcd_to_bus (hcd);
-	udev = first ? usb_alloc_dev (NULL, bus, 0) : bus-&gt;root_hub;
-	if (!udev) {
-done2:
-		ehci_mem_cleanup (ehci);
-		return -ENOMEM;
-	}
-	udev-&gt;speed = USB_SPEED_HIGH;
-	udev-&gt;state = first ? USB_STATE_ATTACHED : USB_STATE_CONFIGURED;
-
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
 	 * are explicitly handed to companion controller(s), so no TT is
@@ -664,24 +651,6 @@ static int ehci_start (struct usb_hcd *hcd)
 		first ? "initialized" : "restarted",
 		temp &gt;&gt; 8, temp &amp; 0xff, DRIVER_VERSION);
 
-	/*
-	 * From here on, khubd concurrently accesses the root
-	 * hub; drivers will be talking to enumerated devices.
-	 * (On restart paths, khubd already knows about the root
-	 * hub and could find work as soon as we wrote FLAG_CF.)
-	 *
-	 * Before this point the HC was idle/ready.  After, khubd
-	 * and device drivers may start it running.
-	 */
-	if (first &amp;&amp; usb_hcd_register_root_hub (udev, hcd) != 0) {
-		if (hcd-&gt;state == HC_STATE_RUNNING)
-			ehci_quiesce (ehci);
-		ehci_reset (ehci);
-		usb_put_dev (udev); 
-		retval = -ENODEV;
-		goto done2;
-	}
-
 	writel (INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable); /* Turn On Interrupts */
 
 	if (first)
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 1183988fdf54..ff0a168e8eed 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1547,7 +1547,6 @@ static int isp116x_start(struct usb_hcd *hcd)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	struct isp116x_platform_data *board = isp116x-&gt;board;
-	struct usb_device *udev;
 	u32 val;
 	unsigned long flags;
 
@@ -1609,24 +1608,9 @@ static int isp116x_start(struct usb_hcd *hcd)
 	isp116x-&gt;rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);
 
 	isp116x_write_reg32(isp116x, HCFMINTVL, 0x27782edf);
-	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev) {
-		isp116x_stop(hcd);
-		return -ENOMEM;
-	}
 
-	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		isp116x_stop(hcd);
-		usb_put_dev(udev);
-		return -ENODEV;
-	}
-
-	spin_lock_irqsave(&amp;isp116x-&gt;lock, flags);
 	/* Set up interrupts */
 	isp116x-&gt;intenb = HCINT_MIE | HCINT_RHSC | HCINT_UE;
 	if (board-&gt;remote_wakeup_enable)
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 0da996191251..13cd2177b557 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -505,13 +505,10 @@ static int ohci_init (struct ohci_hcd *ohci)
 /* Start an OHCI controller, set the BUS operational
  * resets USB and controller
  * enable interrupts 
- * connect the virtual root hub
  */
 static int ohci_run (struct ohci_hcd *ohci)
 {
   	u32			mask, temp;
-  	struct usb_device	*udev;
-  	struct usb_bus		*bus;
 	int			first = ohci-&gt;fminterval == 0;
 
 	disable (ohci);
@@ -672,36 +669,13 @@ static int ohci_run (struct ohci_hcd *ohci)
 
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((temp &gt;&gt; 23) &amp; 0x1fe);
-	bus = &amp;ohci_to_hcd(ohci)-&gt;self;
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_RUNNING;
 
 	ohci_dump (ohci, 1);
 
-	udev = bus-&gt;root_hub;
-	if (udev) {
-		return 0;
-	}
- 
-	/* connect the virtual root hub */
-	udev = usb_alloc_dev (NULL, bus, 0);
-	if (!udev) {
-		disable (ohci);
-		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_HCFS;
-		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
-		return -ENOMEM;
-	}
-
-	udev-&gt;speed = USB_SPEED_FULL;
-	if (usb_hcd_register_root_hub (udev, ohci_to_hcd(ohci)) != 0) {
-		usb_put_dev (udev);
-		disable (ohci);
-		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_HCFS;
-		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
-		return -ENODEV;
-	}
+	if (ohci_to_hcd(ohci)-&gt;self.root_hub == NULL)
+		create_debug_files (ohci);
 
-	register_reboot_notifier (&amp;ohci-&gt;reboot_notifier);
-	create_debug_files (ohci);
 	return 0;
 }
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 1f2d00fe983a..6c3f910bc307 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1563,15 +1563,8 @@ static int
 sl811h_start(struct usb_hcd *hcd)
 {
 	struct sl811		*sl811 = hcd_to_sl811(hcd);
-	struct usb_device	*udev;
 
 	/* chip has been reset, VBUS power is off */
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev)
-		return -ENOMEM;
-
-	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	if (sl811-&gt;board) {
@@ -1579,12 +1572,6 @@ sl811h_start(struct usb_hcd *hcd)
 		hcd-&gt;power_budget = sl811-&gt;board-&gt;power * 2;
 	}
 
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		usb_put_dev(udev);
-		sl811h_stop(hcd);
-		return -ENODEV;
-	}
-
 	/* enable power and interupts */
 	port_power(sl811, 1);
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 6b87bd74b046..fdf54295da73 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -562,7 +562,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	int retval = -EBUSY;
 	int i;
 	dma_addr_t dma_handle;
-	struct usb_device *udev;
 	struct dentry *dentry;
 
 	hcd-&gt;uses_new_polling = 1;
@@ -626,14 +625,6 @@ static int uhci_start(struct usb_hcd *hcd)
 		goto err_create_qh_pool;
 	}
 
-	/* Initialize the root hub */
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev) {
-		dev_err(uhci_dev(uhci), "unable to allocate root hub\n");
-		goto err_alloc_root_hub;
-	}
-
 	uhci-&gt;term_td = uhci_alloc_td(uhci);
 	if (!uhci-&gt;term_td) {
 		dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
@@ -713,24 +704,11 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	configure_hc(uhci);
 	start_rh(uhci);
-
-	udev-&gt;speed = USB_SPEED_FULL;
-
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		dev_err(uhci_dev(uhci), "unable to start root hub\n");
-		retval = -ENOMEM;
-		goto err_start_root_hub;
-	}
-
 	return 0;
 
 /*
  * error exits:
  */
-err_start_root_hub:
-	reset_hc(uhci);
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
-
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
 		if (uhci-&gt;skelqh[i]) {
@@ -742,9 +720,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	uhci-&gt;term_td = NULL;
 
 err_alloc_term_td:
-	usb_put_dev(udev);
-
-err_alloc_root_hub:
 	dma_pool_destroy(uhci-&gt;qh_pool);
 	uhci-&gt;qh_pool = NULL;
 </pre><hr><pre>commit 8ec8d20b21f00a36343ca0ebd6c6be9421724a1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:25:17 2005 -0400

    [PATCH] usbcore: register root hub in usb_add_hcd
    
    This patch makes usbcore automatically allocate and register the root hub
    device for a new host controller when the controller is registered.  This
    way the HCDs don't all have to include the same boilerplate code.  As a
    pleasant side benefit, the register_root_hub routine can now be made
    static and not EXPORTed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 1180c157b717..83e732a0d64a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -832,30 +832,22 @@ static void usb_deregister_bus (struct usb_bus *bus)
 }
 
 /**
- * usb_hcd_register_root_hub - called by HCD to register its root hub 
+ * register_root_hub - called by usb_add_hcd() to register a root hub
  * @usb_dev: the usb root hub device to be registered.
  * @hcd: host controller for this root hub
  *
- * The USB host controller calls this function to register the root hub
- * properly with the USB subsystem.  It sets up the device properly in
- * the device tree and stores the root_hub pointer in the bus structure,
- * then calls usb_new_device() to register the usb device.  It also
- * assigns the root hub's USB address (always 1).
+ * This function registers the root hub with the USB subsystem.  It sets up
+ * the device properly in the device tree and stores the root_hub pointer
+ * in the bus structure, then calls usb_new_device() to register the usb
+ * device.  It also assigns the root hub's USB address (always 1).
  */
-int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
+static int register_root_hub (struct usb_device *usb_dev,
+		struct usb_hcd *hcd)
 {
 	struct device *parent_dev = hcd-&gt;self.controller;
 	const int devnum = 1;
 	int retval;
 
-	/* hcd-&gt;driver-&gt;start() reported can_wakeup, probably with
-	 * assistance from board's boot firmware.
-	 * NOTE:  normal devices won't enable wakeup by default.
-	 */
-	if (hcd-&gt;can_wakeup)
-		dev_dbg (parent_dev, "supports USB remote wakeup\n");
-	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
-
 	usb_dev-&gt;devnum = devnum;
 	usb_dev-&gt;bus-&gt;devnum_next = devnum + 1;
 	memset (&amp;usb_dev-&gt;bus-&gt;devmap.devicemap, 0,
@@ -898,7 +890,6 @@ int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
 
 	return retval;
 }
-EXPORT_SYMBOL_GPL(usb_hcd_register_root_hub);
 
 void usb_enable_root_hub_irq (struct usb_bus *bus)
 {
@@ -1724,7 +1715,8 @@ EXPORT_SYMBOL (usb_put_hcd);
 int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags)
 {
-	int	retval;
+	int retval;
+	struct usb_device *rhdev;
 
 	dev_info(hcd-&gt;self.controller, "%s\n", hcd-&gt;product_desc);
 
@@ -1740,7 +1732,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	}
 
 	if ((retval = usb_register_bus(&amp;hcd-&gt;self)) &lt; 0)
-		goto err1;
+		goto err_register_bus;
 
 	if (hcd-&gt;driver-&gt;irq) {
 		char	buf[8], *bufp = buf;
@@ -1757,7 +1749,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 				hcd-&gt;irq_descr, hcd)) != 0) {
 			dev_err(hcd-&gt;self.controller,
 					"request interrupt %s failed\n", bufp);
-			goto err2;
+			goto err_request_irq;
 		}
 		hcd-&gt;irq = irqnum;
 		dev_info(hcd-&gt;self.controller, "irq %s, %s 0x%08llx\n", bufp,
@@ -1773,21 +1765,55 @@ int usb_add_hcd(struct usb_hcd *hcd,
 					(unsigned long long)hcd-&gt;rsrc_start);
 	}
 
+	/* Allocate the root hub before calling hcd-&gt;driver-&gt;start(),
+	 * but don't register it until afterward so that the hardware
+	 * is running.
+	 */
+	if ((rhdev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0)) == NULL) {
+		dev_err(hcd-&gt;self.controller, "unable to allocate root hub\n");
+		retval = -ENOMEM;
+		goto err_allocate_root_hub;
+	}
+	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
+			USB_SPEED_FULL;
+
+	/* Although in principle hcd-&gt;driver-&gt;start() might need to use rhdev,
+	 * none of the current drivers do.
+	 */
 	if ((retval = hcd-&gt;driver-&gt;start(hcd)) &lt; 0) {
 		dev_err(hcd-&gt;self.controller, "startup error %d\n", retval);
-		goto err3;
+		goto err_hcd_driver_start;
 	}
 
+	/* hcd-&gt;driver-&gt;start() reported can_wakeup, probably with
+	 * assistance from board's boot firmware.
+	 * NOTE:  normal devices won't enable wakeup by default.
+	 */
+	if (hcd-&gt;can_wakeup)
+		dev_dbg(hcd-&gt;self.controller, "supports USB remote wakeup\n");
+	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
+
+	if ((retval = register_root_hub(rhdev, hcd)) != 0)
+		goto err_register_root_hub;
+
 	if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
 		usb_hcd_poll_rh_status(hcd);
 	return retval;
 
- err3:
+ err_register_root_hub:
+	hcd-&gt;driver-&gt;stop(hcd);
+
+ err_hcd_driver_start:
+	usb_put_dev(rhdev);
+
+ err_allocate_root_hub:
 	if (hcd-&gt;irq &gt;= 0)
 		free_irq(irqnum, hcd);
- err2:
+
+ err_request_irq:
 	usb_deregister_bus(&amp;hcd-&gt;self);
- err1:
+
+ err_register_bus:
 	hcd_buffer_destroy(hcd);
 	return retval;
 } 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 3837f68bb7b3..8dc13cde2f73 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -353,9 +353,6 @@ extern long usb_calc_bus_time (int speed, int is_input,
 
 extern struct usb_bus *usb_alloc_bus (struct usb_operations *);
 
-extern int usb_hcd_register_root_hub (struct usb_device *usb_dev,
-		struct usb_hcd *hcd);
-
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 
 extern void usb_set_device_state(struct usb_device *udev,</pre><hr><pre>commit bc96c0ad1ed0c938fefc0423aa99f086c5a2a1ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:21:31 2005 -0400

    [PATCH] ohci-omap, sl811, dummy: remove hub_set_power_budget
    
    This patch changes the HCDs that used the old hub_set_power_budget call,
    making them use the new hcd-&gt;power_budget field instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c039d2fbe7ab..9d37fc771b27 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1646,6 +1646,9 @@ static int dummy_start (struct usb_hcd *hcd)
 	if (!root)
 		return -ENOMEM;
 
+	/* only show a low-power port: just 8mA */
+	hcd-&gt;power_budget = 8;
+
 	/* root hub enters addressed state... */
 	hcd-&gt;state = HC_STATE_RUNNING;
 	root-&gt;speed = USB_SPEED_HIGH;
@@ -1655,9 +1658,6 @@ static int dummy_start (struct usb_hcd *hcd)
 		goto err1;
 	}
 
-	/* only show a low-power port: just 8mA */
-	hub_set_power_budget (root, 8);
-
 	if ((retval = dummy_register_udc (dum)) != 0)
 		goto err2;
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 32120042ab65..0da996191251 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -699,8 +699,6 @@ static int ohci_run (struct ohci_hcd *ohci)
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		return -ENODEV;
 	}
-	if (ohci-&gt;power_budget)
-		hub_set_power_budget(udev, ohci-&gt;power_budget);
 
 	register_reboot_notifier (&amp;ohci-&gt;reboot_notifier);
 	create_debug_files (ohci);
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 8aab5907afe9..b62d69937694 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -181,7 +181,7 @@ static int omap_start_hc(struct ohci_hcd *ohci, struct platform_device *pdev)
 	if (config-&gt;otg) {
 		ohci_to_hcd(ohci)-&gt;self.otg_port = config-&gt;otg;
 		/* default/minimum OTG power budget:  8 mA */
-		ohci-&gt;power_budget = 8;
+		ohci_to_hcd(ohci)-&gt;power_budget = 8;
 	}
 
 	/* boards can use OTG transceivers in non-OTG modes */
@@ -230,7 +230,7 @@ static int omap_start_hc(struct ohci_hcd *ohci, struct platform_device *pdev)
 
 		/* TPS2045 switch for internal transceiver (port 1) */
 		if (machine_is_omap_osk()) {
-			ohci-&gt;power_budget = 250;
+			ohci_to_hcd(ohci)-&gt;power_budget = 250;
 
 			rh &amp;= ~RH_A_NOCP;
 
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 3dbc7c0eed43..71cdd2262860 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -371,7 +371,6 @@ struct ohci_hcd {
 	 * other external transceivers should be software-transparent 
 	 */
 	struct otg_transceiver	*transceiver;
-	unsigned		power_budget;
 
 	/*
 	 * memory management for queue data structures
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 99d43f758ad0..1f2d00fe983a 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1574,8 +1574,10 @@ sl811h_start(struct usb_hcd *hcd)
 	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
-	if (sl811-&gt;board)
+	if (sl811-&gt;board) {
 		hcd-&gt;can_wakeup = sl811-&gt;board-&gt;can_wakeup;
+		hcd-&gt;power_budget = sl811-&gt;board-&gt;power * 2;
+	}
 
 	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
 		usb_put_dev(udev);
@@ -1583,9 +1585,6 @@ sl811h_start(struct usb_hcd *hcd)
 		return -ENODEV;
 	}
 
-	if (sl811-&gt;board &amp;&amp; sl811-&gt;board-&gt;power)
-		hub_set_power_budget(udev, sl811-&gt;board-&gt;power * 2);
-
 	/* enable power and interupts */
 	port_power(sl811, 1);
 </pre>
    <div class="pagination">
        <a href='2_137.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><span>[138]</span><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_139.html'>Next&gt;&gt;</a>
    <div>
</body>
