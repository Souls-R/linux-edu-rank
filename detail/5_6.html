<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_5.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><span>[6]</span><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2d63673b4d469cf2ddba309a916090b54e31cc35
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Oct 11 17:55:11 2011 -0500

    [SCSI] iscsi class: fix vlan configuration
    
    Userspace was sending the priority/id part of the vlan tag
    and sysfs was displaying the id in the vlan file. This
    renames the vlan sysfs file to vlan_id to reflect that it
    was showing the id and to match the vlan_priority file.
    This also adds a ISCSI_NET_PARAM_VLAN_TAG iscsi nl command
    to relfect that we are sending down the vlan/priority
    part of the tag.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index ce20dab75369..ba6a8f3ee6fa 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -718,7 +718,7 @@ static void qla4xxx_set_ipv6(struct scsi_qla_host *ha,
 			qla4xxx_destroy_ipv6_iface(ha);
 		}
 		break;
-	case ISCSI_NET_PARAM_VLAN_ID:
+	case ISCSI_NET_PARAM_VLAN_TAG:
 		if (iface_param-&gt;len != sizeof(init_fw_cb-&gt;ipv6_vlan_tag))
 			break;
 		init_fw_cb-&gt;ipv6_vlan_tag =
@@ -790,7 +790,7 @@ static void qla4xxx_set_ipv4(struct scsi_qla_host *ha,
 			qla4xxx_destroy_ipv4_iface(ha);
 		}
 		break;
-	case ISCSI_NET_PARAM_VLAN_ID:
+	case ISCSI_NET_PARAM_VLAN_TAG:
 		if (iface_param-&gt;len != sizeof(init_fw_cb-&gt;ipv4_vlan_tag))
 			break;
 		init_fw_cb-&gt;ipv4_vlan_tag =
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 142a09a3afbf..1bcd65a509e6 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -322,7 +322,7 @@ iscsi_iface_net_attr(ipv6_iface, link_local_autocfg,
 
 /* common read only iface attribute */
 iscsi_iface_net_attr(iface, enabled, ISCSI_NET_PARAM_IFACE_ENABLE);
-iscsi_iface_net_attr(iface, vlan, ISCSI_NET_PARAM_VLAN_ID);
+iscsi_iface_net_attr(iface, vlan_id, ISCSI_NET_PARAM_VLAN_ID);
 iscsi_iface_net_attr(iface, vlan_priority, ISCSI_NET_PARAM_VLAN_PRIORITY);
 iscsi_iface_net_attr(iface, vlan_enabled, ISCSI_NET_PARAM_VLAN_ENABLED);
 iscsi_iface_net_attr(iface, mtu, ISCSI_NET_PARAM_MTU);
@@ -338,7 +338,7 @@ static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 
 	if (attr == &amp;dev_attr_iface_enabled.attr)
 		param = ISCSI_NET_PARAM_IFACE_ENABLE;
-	else if (attr == &amp;dev_attr_iface_vlan.attr)
+	else if (attr == &amp;dev_attr_iface_vlan_id.attr)
 		param = ISCSI_NET_PARAM_VLAN_ID;
 	else if (attr == &amp;dev_attr_iface_vlan_priority.attr)
 		param = ISCSI_NET_PARAM_VLAN_PRIORITY;
@@ -382,7 +382,7 @@ static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 
 static struct attribute *iscsi_iface_attrs[] = {
 	&amp;dev_attr_iface_enabled.attr,
-	&amp;dev_attr_iface_vlan.attr,
+	&amp;dev_attr_iface_vlan_id.attr,
 	&amp;dev_attr_iface_vlan_priority.attr,
 	&amp;dev_attr_iface_vlan_enabled.attr,
 	&amp;dev_attr_ipv4_iface_ipaddress.attr,
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 706a1bb1c59b..2703e3bedbf5 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -311,10 +311,11 @@ enum iscsi_net_param {
 	ISCSI_NET_PARAM_VLAN_ID			= 13,
 	ISCSI_NET_PARAM_VLAN_PRIORITY		= 14,
 	ISCSI_NET_PARAM_VLAN_ENABLED		= 15,
-	ISCSI_NET_PARAM_IFACE_TYPE		= 16,
-	ISCSI_NET_PARAM_IFACE_NAME		= 17,
-	ISCSI_NET_PARAM_MTU			= 18,
-	ISCSI_NET_PARAM_PORT			= 19,
+	ISCSI_NET_PARAM_VLAN_TAG		= 16,
+	ISCSI_NET_PARAM_IFACE_TYPE		= 17,
+	ISCSI_NET_PARAM_IFACE_NAME		= 18,
+	ISCSI_NET_PARAM_MTU			= 19,
+	ISCSI_NET_PARAM_PORT			= 20,
 };
 
 enum iscsi_conn_state {</pre><hr><pre>commit 00c31889f7513e9ffa6b2b4de8ad6d7f59a61c80
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Oct 6 03:56:59 2011 -0500

    [SCSI] qla4xxx: fix data alignment and use nl helpers
    
    This has the driver use helpers for a common operation and fixes
    a issue where if multiple iscsi params are sent they could be
    sent at offsets that cause unaligned accesses. The nla helpers
    account for the padding needed to align properly for the driver.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index d39205c816d8..ce20dab75369 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -78,8 +78,8 @@ static int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,
 				  enum iscsi_param param, char *buf);
 static int qla4xxx_host_get_param(struct Scsi_Host *shost,
 				  enum iscsi_host_param param, char *buf);
-static int qla4xxx_iface_set_param(struct Scsi_Host *shost, char *data,
-				   int count);
+static int qla4xxx_iface_set_param(struct Scsi_Host *shost, void *data,
+				   uint32_t len);
 static int qla4xxx_get_iface_param(struct iscsi_iface *iface,
 				   enum iscsi_param_type param_type,
 				   int param, char *buf);
@@ -842,7 +842,7 @@ qla4xxx_initcb_to_acb(struct addr_ctrl_blk *init_fw_cb)
 }
 
 static int
-qla4xxx_iface_set_param(struct Scsi_Host *shost, char *data, int count)
+qla4xxx_iface_set_param(struct Scsi_Host *shost, void *data, uint32_t len)
 {
 	struct scsi_qla_host *ha = to_qla_host(shost);
 	int rval = 0;
@@ -851,8 +851,8 @@ qla4xxx_iface_set_param(struct Scsi_Host *shost, char *data, int count)
 	dma_addr_t init_fw_cb_dma;
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
-	uint32_t total_param_count;
-	uint32_t length;
+	uint32_t rem = len;
+	struct nlattr *attr;
 
 	init_fw_cb = dma_alloc_coherent(&amp;ha-&gt;pdev-&gt;dev,
 					sizeof(struct addr_ctrl_blk),
@@ -873,11 +873,8 @@ qla4xxx_iface_set_param(struct Scsi_Host *shost, char *data, int count)
 		goto exit_init_fw_cb;
 	}
 
-	total_param_count = count;
-	iface_param = (struct iscsi_iface_param_info *)data;
-
-	for ( ; total_param_count != 0; total_param_count--) {
-		length = iface_param-&gt;len;
+	nla_for_each_attr(attr, data, len, rem) {
+		iface_param = nla_data(attr);
 
 		if (iface_param-&gt;param_type != ISCSI_NET_PARAM)
 			continue;
@@ -914,10 +911,6 @@ qla4xxx_iface_set_param(struct Scsi_Host *shost, char *data, int count)
 			ql4_printk(KERN_ERR, ha, "Invalid iface type\n");
 			break;
 		}
-
-		iface_param = (struct iscsi_iface_param_info *)
-						((uint8_t *)iface_param +
-			    sizeof(struct iscsi_iface_param_info) + length);
 	}
 
 	init_fw_cb-&gt;cookie = cpu_to_le32(0x11BEAD5A);
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 522423bdcb56..142a09a3afbf 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -1890,7 +1890,7 @@ iscsi_set_path(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 
 static int
 iscsi_set_iface_params(struct iscsi_transport *transport,
-		       struct iscsi_uevent *ev)
+		       struct iscsi_uevent *ev, uint32_t len)
 {
 	char *data = (char *)ev + sizeof(*ev);
 	struct Scsi_Host *shost;
@@ -1906,8 +1906,7 @@ iscsi_set_iface_params(struct iscsi_transport *transport,
 		return -ENODEV;
 	}
 
-	err = transport-&gt;set_iface_param(shost, data,
-					 ev-&gt;u.set_iface_params.count);
+	err = transport-&gt;set_iface_param(shost, data, len);
 	scsi_host_put(shost);
 	return err;
 }
@@ -2052,7 +2051,8 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)
 		err = iscsi_set_path(transport, ev);
 		break;
 	case ISCSI_UEVENT_SET_IFACE_PARAMS:
-		err = iscsi_set_iface_params(transport, ev);
+		err = iscsi_set_iface_params(transport, ev,
+					     nlmsg_attrlen(nlh, sizeof(*ev)));
 		break;
 	default:
 		err = -ENOSYS;
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index a498ccecf6b1..5994bcc1b017 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -137,7 +137,8 @@ struct iscsi_transport {
 	int (*tgt_dscvr) (struct Scsi_Host *shost, enum iscsi_tgt_dscvr type,
 			  uint32_t enable, struct sockaddr *dst_addr);
 	int (*set_path) (struct Scsi_Host *shost, struct iscsi_path *params);
-	int (*set_iface_param) (struct Scsi_Host *shost, char *data, int count);
+	int (*set_iface_param) (struct Scsi_Host *shost, void *data,
+				uint32_t len);
 	int (*get_iface_param) (struct iscsi_iface *iface,
 				enum iscsi_param_type param_type,
 				int param, char *buf);</pre><hr><pre>commit 88f4f5170fe74ae28443f304fcd226ddcf84f592
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Oct 6 03:56:58 2011 -0500

    [SCSI] iscsi class: fix link local mispelling
    
    Use the same format for link local variables. Instead
    of linklocal do link_local.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index d746c351588f..522423bdcb56 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -317,7 +317,7 @@ iscsi_iface_net_attr(ipv6_iface, link_local_addr, ISCSI_NET_PARAM_IPV6_LINKLOCAL
 iscsi_iface_net_attr(ipv6_iface, router_addr, ISCSI_NET_PARAM_IPV6_ROUTER);
 iscsi_iface_net_attr(ipv6_iface, ipaddr_autocfg,
 		     ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG);
-iscsi_iface_net_attr(ipv6_iface, linklocal_autocfg,
+iscsi_iface_net_attr(ipv6_iface, link_local_autocfg,
 		     ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG);
 
 /* common read only iface attribute */
@@ -368,7 +368,7 @@ static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 			param = ISCSI_NET_PARAM_IPV6_ROUTER;
 		else if (attr == &amp;dev_attr_ipv6_iface_ipaddr_autocfg.attr)
 			param = ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG;
-		else if (attr == &amp;dev_attr_ipv6_iface_linklocal_autocfg.attr)
+		else if (attr == &amp;dev_attr_ipv6_iface_link_local_autocfg.attr)
 			param = ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG;
 		else
 			return 0;
@@ -393,7 +393,7 @@ static struct attribute *iscsi_iface_attrs[] = {
 	&amp;dev_attr_ipv6_iface_link_local_addr.attr,
 	&amp;dev_attr_ipv6_iface_router_addr.attr,
 	&amp;dev_attr_ipv6_iface_ipaddr_autocfg.attr,
-	&amp;dev_attr_ipv6_iface_linklocal_autocfg.attr,
+	&amp;dev_attr_ipv6_iface_link_local_autocfg.attr,
 	&amp;dev_attr_iface_mtu.attr,
 	&amp;dev_attr_iface_port.attr,
 	NULL,</pre><hr><pre>commit 8d4a690cd4f574bcb70c2cb89c227ba89a51351f
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Oct 6 03:56:57 2011 -0500

    [SCSI] iscsi class: Replace iscsi_get_next_target_id with IDA
    
     Replaced the iscsi_get_next_target_id with IDA to make
     target-id allocation efficient for iscsi offload drivers
    
     This patch should be applied after Jonathen Cameron Patch
     "ida : simplified functions for id allocation"
    
    Signed-off-by: John Soni Jose &lt;jose0here@gmail.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index c58f6766f4c7..d746c351588f 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -24,6 +24,7 @@
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/bsg-lib.h&gt;
+#include &lt;linux/idr.h&gt;
 #include &lt;net/tcp.h&gt;
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
@@ -81,6 +82,7 @@ struct iscsi_internal {
 static atomic_t iscsi_session_nr; /* sysfs session id for next new session */
 static struct workqueue_struct *iscsi_eh_timer_workq;
 
+static DEFINE_IDA(iscsi_sess_ida);
 /*
  * list of registered transports and lock that must
  * be held while accessing list. The iscsi_transport_lock must
@@ -990,6 +992,7 @@ static void __iscsi_unbind_session(struct work_struct *work)
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
 	unsigned long flags;
+	unsigned int target_id;
 
 	ISCSI_DBG_TRANS_SESSION(session, "Unbinding session\n");
 
@@ -1001,10 +1004,15 @@ static void __iscsi_unbind_session(struct work_struct *work)
 		mutex_unlock(&amp;ihost-&gt;mutex);
 		return;
 	}
+
+	target_id = session-&gt;target_id;
 	session-&gt;target_id = ISCSI_MAX_TARGET;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	mutex_unlock(&amp;ihost-&gt;mutex);
 
+	if (session-&gt;ida_used)
+		ida_simple_remove(&amp;iscsi_sess_ida, target_id);
+
 	scsi_remove_target(&amp;session-&gt;dev);
 	iscsi_session_event(session, ISCSI_KEVENT_UNBIND_SESSION);
 	ISCSI_DBG_TRANS_SESSION(session, "Completed target removal\n");
@@ -1045,59 +1053,36 @@ iscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,
 }
 EXPORT_SYMBOL_GPL(iscsi_alloc_session);
 
-static int iscsi_get_next_target_id(struct device *dev, void *data)
-{
-	struct iscsi_cls_session *session;
-	unsigned long flags;
-	int err = 0;
-
-	if (!iscsi_is_session_dev(dev))
-		return 0;
-
-	session = iscsi_dev_to_session(dev);
-	spin_lock_irqsave(&amp;session-&gt;lock, flags);
-	if (*((unsigned int *) data) == session-&gt;target_id)
-		err = -EEXIST;
-	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
-	return err;
-}
-
 int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 {
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_cls_host *ihost;
 	unsigned long flags;
-	unsigned int id = target_id;
+	int id = 0;
 	int err;
 
 	ihost = shost-&gt;shost_data;
 	session-&gt;sid = atomic_add_return(1, &amp;iscsi_session_nr);
 
-	if (id == ISCSI_MAX_TARGET) {
-		for (id = 0; id &lt; ISCSI_MAX_TARGET; id++) {
-			err = device_for_each_child(&amp;shost-&gt;shost_gendev, &amp;id,
-						    iscsi_get_next_target_id);
-			if (!err)
-				break;
-		}
+	if (target_id == ISCSI_MAX_TARGET) {
+		id = ida_simple_get(&amp;iscsi_sess_ida, 0, 0, GFP_KERNEL);
 
-		if (id == ISCSI_MAX_TARGET) {
+		if (id &lt; 0) {
 			iscsi_cls_session_printk(KERN_ERR, session,
-						 "Too many iscsi targets. Max "
-						 "number of targets is %d.\n",
-						 ISCSI_MAX_TARGET - 1);
-			err = -EOVERFLOW;
-			goto release_host;
+					"Failure in Target ID Allocation\n");
+			return id;
 		}
-	}
-	session-&gt;target_id = id;
+		session-&gt;target_id = (unsigned int)id;
+		session-&gt;ida_used = true;
+	} else
+		session-&gt;target_id = target_id;
 
 	dev_set_name(&amp;session-&gt;dev, "session%u", session-&gt;sid);
 	err = device_add(&amp;session-&gt;dev);
 	if (err) {
 		iscsi_cls_session_printk(KERN_ERR, session,
 					 "could not register session's dev\n");
-		goto release_host;
+		goto release_ida;
 	}
 	transport_register_device(&amp;session-&gt;dev);
 
@@ -1109,8 +1094,10 @@ int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 	ISCSI_DBG_TRANS_SESSION(session, "Completed session adding\n");
 	return 0;
 
-release_host:
-	scsi_host_put(shost);
+release_ida:
+	if (session-&gt;ida_used)
+		ida_simple_remove(&amp;iscsi_sess_ida, session-&gt;target_id);
+
 	return err;
 }
 EXPORT_SYMBOL_GPL(iscsi_add_session);
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 3389cd5ea94c..a498ccecf6b1 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -208,6 +208,7 @@ struct iscsi_cls_session {
 	struct delayed_work recovery_work;
 
 	unsigned int target_id;
+	bool ida_used;
 
 	int state;
 	int sid;				/* session id */</pre><hr><pre>commit 9c224ac21506d29f5a6ff4df0c4cc9f97484fa25
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Aug 31 21:53:40 2011 -0500

    [SCSI] qla4xxx: select iscsi boot sysfs attrs
    
    qla4xxx now uses iscsi_boot_sysfs to export the targets used
    for boot to sysfs. It needs to select that config option
    to make sure that module is also built.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/qla4xxx/Kconfig b/drivers/scsi/qla4xxx/Kconfig
index 2c33ce6eac1e..5b1aed4f0754 100644
--- a/drivers/scsi/qla4xxx/Kconfig
+++ b/drivers/scsi/qla4xxx/Kconfig
@@ -2,6 +2,7 @@ config SCSI_QLA_ISCSI
 	tristate "QLogic ISP4XXX and ISP82XX host adapter family support"
 	depends on PCI &amp;&amp; SCSI
 	select SCSI_ISCSI_ATTRS
+	select ISCSI_BOOT_SYSFS
 	---help---
 	This driver supports the QLogic 40xx (ISP4XXX) and 8022 (ISP82XX)
 	iSCSI host adapter family.</pre><hr><pre>commit 76e4e12ff2b3ef86773989fd897b194eb38016e6
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 25 00:36:38 2011 -0500

    [SCSI] scsi scan: don't fail scans when host is in recovery
    
    The problem is that if we are doing a scsi scan then the device goes
    into recovery then we will wait for the recovery to complete. It waits
    because scsi-ml will send inquiries or report luns and the queueing code
    will have been blocked due to the host not being ready. However, if we
    are in recovery and then a scan is started the scan will silently fail
    and some devices will not be added.
    
    It is easy to hit the problem where devices do not show up with
    FC where we are doing tests that disrupt the target controllers.
    When the controller is disruprted (reboot, or setting firmware, etc),
    and we cause the dev loss tmo to fire then devices will be removed
    Then when the problem has been fixed, the rport will be scanned and
    devices should be added back. But if we cause another disruption before
    scanning has started then devices will not get added back. If the problem
    is not started until the scan is started then the devices will be added
    back.
    
    This patch fixes that problem by not failing scans when the host
    is in recovery. We will let scsi-ml send the IO and let the queueing
    and scsi error handling deal with it like is done if we went into
    recovery while scanning.
    
    For recovery cases where the host is being torn down then with the
    patch we will still fail the scan since there is not point in scanning.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index fc22ad9dba77..50266c9405fc 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -804,7 +804,8 @@ static inline struct device *scsi_get_device(struct Scsi_Host *shost)
  **/
 static inline int scsi_host_scan_allowed(struct Scsi_Host *shost)
 {
-	return shost-&gt;shost_state == SHOST_RUNNING;
+	return shost-&gt;shost_state == SHOST_RUNNING ||
+	       shost-&gt;shost_state == SHOST_RECOVERY;
 }
 
 extern void scsi_unblock_requests(struct Scsi_Host *);</pre><hr><pre>commit de37920b87a78e5e4a5e40e65548f1bf1cfb2f5c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sun Aug 14 20:42:56 2011 -0500

    [SCSI] qla4xxx: export iface name
    
    Export the name of iface session is attached to. This is needed
    so tools like iscsiadm/iscsistart can match the sessions to
    userspace ifaces when rebuilding iscsid's state during boot.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 456cd6f23f0f..ce391d5511e3 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -213,6 +213,7 @@ static mode_t ql4_attr_is_visible(int param_type, int param)
 		case ISCSI_PARAM_FIRST_BURST:
 		case ISCSI_PARAM_MAX_RECV_DLENGTH:
 		case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		case ISCSI_PARAM_IFACE_NAME:
 			return S_IRUGO;
 		default:
 			return 0;</pre><hr><pre>commit 90eeb01a038e5fec0efdea4df008f3c18f67b82c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jul 25 13:48:50 2011 -0500

    [SCSI] iscsi class: add bsg support to iscsi class
    
    This patch adds bsg support to the iscsi class. There is only
    1 request, the host vendor one, supported. It is expected that
    this would be used for things like flash updates.
    
    This patch is made over this one
    http://marc.info/?l=linux-scsi&amp;m=131149780020992&amp;w=2
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 8d9dae89f065..4a79b9d86156 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -309,6 +309,7 @@ config SCSI_FC_TGT_ATTRS
 config SCSI_ISCSI_ATTRS
 	tristate "iSCSI Transport Attributes"
 	depends on SCSI &amp;&amp; NET
+	select BLK_DEV_BSGLIB
 	help
 	  If you wish to export transport-specific information about
 	  each attached iSCSI device to sysfs, say Y.
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 13f90515ff6e..cde679f1b01d 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -23,6 +23,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/bsg-lib.h&gt;
 #include &lt;net/tcp.h&gt;
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
@@ -31,6 +32,7 @@
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
+#include &lt;scsi/scsi_bsg_iscsi.h&gt;
 
 #define ISCSI_TRANSPORT_VERSION "2.0-870"
 
@@ -447,6 +449,99 @@ void iscsi_destroy_iface(struct iscsi_iface *iface)
 }
 EXPORT_SYMBOL_GPL(iscsi_destroy_iface);
 
+/*
+ * BSG support
+ */
+/**
+ * iscsi_bsg_host_dispatch - Dispatch command to LLD.
+ * @job: bsg job to be processed
+ */
+static int iscsi_bsg_host_dispatch(struct bsg_job *job)
+{
+	struct Scsi_Host *shost = iscsi_job_to_shost(job);
+	struct iscsi_bsg_request *req = job-&gt;request;
+	struct iscsi_bsg_reply *reply = job-&gt;reply;
+	struct iscsi_internal *i = to_iscsi_internal(shost-&gt;transportt);
+	int cmdlen = sizeof(uint32_t);	/* start with length of msgcode */
+	int ret;
+
+	/* check if we have the msgcode value at least */
+	if (job-&gt;request_len &lt; sizeof(uint32_t)) {
+		ret = -ENOMSG;
+		goto fail_host_msg;
+	}
+
+	/* Validate the host command */
+	switch (req-&gt;msgcode) {
+	case ISCSI_BSG_HST_VENDOR:
+		cmdlen += sizeof(struct iscsi_bsg_host_vendor);
+		if ((shost-&gt;hostt-&gt;vendor_id == 0L) ||
+		    (req-&gt;rqst_data.h_vendor.vendor_id !=
+			shost-&gt;hostt-&gt;vendor_id)) {
+			ret = -ESRCH;
+			goto fail_host_msg;
+		}
+		break;
+	default:
+		ret = -EBADR;
+		goto fail_host_msg;
+	}
+
+	/* check if we really have all the request data needed */
+	if (job-&gt;request_len &lt; cmdlen) {
+		ret = -ENOMSG;
+		goto fail_host_msg;
+	}
+
+	ret = i-&gt;iscsi_transport-&gt;bsg_request(job);
+	if (!ret)
+		return 0;
+
+fail_host_msg:
+	/* return the errno failure code as the only status */
+	BUG_ON(job-&gt;reply_len &lt; sizeof(uint32_t));
+	reply-&gt;reply_payload_rcv_len = 0;
+	reply-&gt;result = ret;
+	job-&gt;reply_len = sizeof(uint32_t);
+	bsg_job_done(job, ret, 0);
+	return 0;
+}
+
+/**
+ * iscsi_bsg_host_add - Create and add the bsg hooks to receive requests
+ * @shost: shost for iscsi_host
+ * @cls_host: iscsi_cls_host adding the structures to
+ */
+static int
+iscsi_bsg_host_add(struct Scsi_Host *shost, struct iscsi_cls_host *ihost)
+{
+	struct device *dev = &amp;shost-&gt;shost_gendev;
+	struct iscsi_internal *i = to_iscsi_internal(shost-&gt;transportt);
+	struct request_queue *q;
+	char bsg_name[20];
+	int ret;
+
+	if (!i-&gt;iscsi_transport-&gt;bsg_request)
+		return -ENOTSUPP;
+
+	snprintf(bsg_name, sizeof(bsg_name), "iscsi_host%d", shost-&gt;host_no);
+
+	q = __scsi_alloc_queue(shost, bsg_request_fn);
+	if (!q)
+		return -ENOMEM;
+
+	ret = bsg_setup_queue(dev, q, bsg_name, iscsi_bsg_host_dispatch, 0);
+	if (ret) {
+		shost_printk(KERN_ERR, shost, "bsg interface failed to "
+			     "initialize - no request queue\n");
+		blk_cleanup_queue(q);
+		return ret;
+	}
+
+	ihost-&gt;bsg_q = q;
+	return 0;
+}
+
 static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 			    struct device *cdev)
 {
@@ -456,13 +551,30 @@ static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 	memset(ihost, 0, sizeof(*ihost));
 	atomic_set(&amp;ihost-&gt;nr_scans, 0);
 	mutex_init(&amp;ihost-&gt;mutex);
+
+	iscsi_bsg_host_add(shost, ihost);
+	/* ignore any bsg add error - we just can't do sgio */
+
+	return 0;
+}
+
+static int iscsi_remove_host(struct transport_container *tc,
+			     struct device *dev, struct device *cdev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
+
+	if (ihost-&gt;bsg_q) {
+		bsg_remove_queue(ihost-&gt;bsg_q);
+		blk_cleanup_queue(ihost-&gt;bsg_q);
+	}
 	return 0;
 }
 
 static DECLARE_TRANSPORT_CLASS(iscsi_host_class,
 			       "iscsi_host",
 			       iscsi_setup_host,
-			       NULL,
+			       iscsi_remove_host,
 			       NULL);
 
 static DECLARE_TRANSPORT_CLASS(iscsi_session_class,
diff --git a/include/scsi/scsi_bsg_iscsi.h b/include/scsi/scsi_bsg_iscsi.h
new file mode 100644
index 000000000000..fd5689d4c052
--- /dev/null
+++ b/include/scsi/scsi_bsg_iscsi.h
@@ -0,0 +1,110 @@
+/*
+ *  iSCSI Transport BSG Interface
+ *
+ *  Copyright (C) 2009   James Smart, Emulex Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef SCSI_BSG_ISCSI_H
+#define SCSI_BSG_ISCSI_H
+
+/*
+ * This file intended to be included by both kernel and user space
+ */
+
+#include &lt;scsi/scsi.h&gt;
+
+/*
+ * iSCSI Transport SGIO v4 BSG Message Support
+ */
+
+/* Default BSG request timeout (in seconds) */
+#define ISCSI_DEFAULT_BSG_TIMEOUT      (10 * HZ)
+
+
+/*
+ * Request Message Codes supported by the iSCSI Transport
+ */
+
+/* define the class masks for the message codes */
+#define ISCSI_BSG_CLS_MASK     0xF0000000      /* find object class */
+#define ISCSI_BSG_HST_MASK     0x80000000      /* iscsi host class */
+
+/* iscsi host Message Codes */
+#define ISCSI_BSG_HST_VENDOR           (ISCSI_BSG_HST_MASK | 0x000000FF)
+
+
+/*
+ * iSCSI Host Messages
+ */
+
+/* ISCSI_BSG_HST_VENDOR : */
+
+/* Request:
+ * Note: When specifying vendor_id, be sure to read the Vendor Type and ID
+ *   formatting requirements specified in scsi_netlink.h
+ */
+struct iscsi_bsg_host_vendor {
+	/*
+	 * Identifies the vendor that the message is formatted for. This
+	 * should be the recipient of the message.
+	 */
+	uint64_t vendor_id;
+
+	/* start of vendor command area */
+	uint32_t vendor_cmd[0];
+};
+
+/* Response:
+ */
+struct iscsi_bsg_host_vendor_reply {
+	/* start of vendor response area */
+	uint32_t vendor_rsp[0];
+};
+
+
+/* request (CDB) structure of the sg_io_v4 */
+struct iscsi_bsg_request {
+	uint32_t msgcode;
+	union {
+		struct iscsi_bsg_host_vendor    h_vendor;
+	} rqst_data;
+} __attribute__((packed));
+
+
+/* response (request sense data) structure of the sg_io_v4 */
+struct iscsi_bsg_reply {
+	/*
+	 * The completion result. Result exists in two forms:
+	 * if negative, it is an -Exxx system errno value. There will
+	 * be no further reply information supplied.
+	 * else, it's the 4-byte scsi error result, with driver, host,
+	 * msg and status fields. The per-msgcode reply structure
+	 * will contain valid data.
+	 */
+	uint32_t result;
+
+	/* If there was reply_payload, how much was recevied ? */
+	uint32_t reply_payload_rcv_len;
+
+	union {
+		struct iscsi_bsg_host_vendor_reply      vendor_reply;
+	} reply_data;
+};
+
+
+#endif /* SCSI_BSG_ISCSI_H */
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 77e6dd60fb4b..4a3edeeae8f6 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -38,6 +38,7 @@ struct iscsi_conn;
 struct iscsi_task;
 struct sockaddr;
 struct iscsi_iface;
+struct bsg_job;
 
 /**
  * struct iscsi_transport - iSCSI Transport template
@@ -141,9 +142,9 @@ struct iscsi_transport {
 				enum iscsi_param_type param_type,
 				int param, char *buf);
 	mode_t (*attr_is_visible)(int param_type, int param);
+	int (*bsg_request)(struct bsg_job *job);
 };
 
-
 /*
  * transport registration upcalls
  */
@@ -227,8 +228,12 @@ struct iscsi_cls_session {
 struct iscsi_cls_host {
 	atomic_t nr_scans;
 	struct mutex mutex;
+	struct request_queue *bsg_q;
 };
 
+#define iscsi_job_to_shost(_job) \
+        dev_to_shost(_job-&gt;dev)
+
 extern void iscsi_host_for_each_session(struct Scsi_Host *shost,
 				void (*fn)(struct iscsi_cls_session *));
 </pre><hr><pre>commit 5431ae267ab20464cea3e1c1d1bc34d259f3973c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jul 25 13:48:48 2011 -0500

    [SCSI] libiscsi: don't bugon when if user sets markers
    
    libiscsi does not support markers and if someone tries
    to set them the driver does a BUG(). There is not need
    to be that extreme. Just return -ENOSYS.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 256a999d010b..d7c76f2eb636 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -3163,7 +3163,6 @@ int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
-	uint32_t value;
 
 	switch(param) {
 	case ISCSI_PARAM_FAST_ABORT:
@@ -3220,14 +3219,6 @@ int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
 	case ISCSI_PARAM_ERL:
 		sscanf(buf, "%d", &amp;session-&gt;erl);
 		break;
-	case ISCSI_PARAM_IFMARKER_EN:
-		sscanf(buf, "%d", &amp;value);
-		BUG_ON(value);
-		break;
-	case ISCSI_PARAM_OFMARKER_EN:
-		sscanf(buf, "%d", &amp;value);
-		BUG_ON(value);
-		break;
 	case ISCSI_PARAM_EXP_STATSN:
 		sscanf(buf, "%u", &amp;conn-&gt;exp_statsn);
 		break;</pre><hr><pre>commit 4223b9e919761ba1405a8505bda0b4efa17e8f0e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jul 25 13:48:47 2011 -0500

    [SCSI] iscsi class: expand vlan support
    
    Add support to set vlan priority and enable/disble a vlan.
    
    Patch based on code from Vikas Chaudhary.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 2e9b68215593..13f90515ff6e 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -319,6 +319,8 @@ iscsi_iface_net_attr(ipv6_iface, linklocal_autocfg,
 /* common read only iface attribute */
 iscsi_iface_net_attr(iface, enabled, ISCSI_NET_PARAM_IFACE_ENABLE);
 iscsi_iface_net_attr(iface, vlan, ISCSI_NET_PARAM_VLAN_ID);
+iscsi_iface_net_attr(iface, vlan_priority, ISCSI_NET_PARAM_VLAN_PRIORITY);
+iscsi_iface_net_attr(iface, vlan_enabled, ISCSI_NET_PARAM_VLAN_ENABLED);
 
 static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 					  struct attribute *attr, int i)
@@ -332,6 +334,10 @@ static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 		param = ISCSI_NET_PARAM_IFACE_ENABLE;
 	else if (attr == &amp;dev_attr_iface_vlan.attr)
 		param = ISCSI_NET_PARAM_VLAN_ID;
+	else if (attr == &amp;dev_attr_iface_vlan_priority.attr)
+		param = ISCSI_NET_PARAM_VLAN_PRIORITY;
+	else if (attr == &amp;dev_attr_iface_vlan_enabled.attr)
+		param = ISCSI_NET_PARAM_VLAN_ENABLED;
 	else if (iface-&gt;iface_type == ISCSI_IFACE_TYPE_IPV4) {
 		if (attr == &amp;dev_attr_ipv4_iface_ipaddress.attr)
 			param = ISCSI_NET_PARAM_IPV4_ADDR;
@@ -367,6 +373,8 @@ static mode_t iscsi_iface_attr_is_visible(struct kobject *kobj,
 static struct attribute *iscsi_iface_attrs[] = {
 	&amp;dev_attr_iface_enabled.attr,
 	&amp;dev_attr_iface_vlan.attr,
+	&amp;dev_attr_iface_vlan_priority.attr,
+	&amp;dev_attr_iface_vlan_enabled.attr,
 	&amp;dev_attr_ipv4_iface_ipaddress.attr,
 	&amp;dev_attr_ipv4_iface_gateway.attr,
 	&amp;dev_attr_ipv4_iface_subnet.attr,
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 3753f7e36386..d3f256a232f8 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -281,6 +281,13 @@ struct iscsi_path {
 #define ISCSI_IFACE_TYPE_IPV4		0x01
 #define ISCSI_IFACE_TYPE_IPV6		0x02
 
+#define ISCSI_MAX_VLAN_ID		4095
+#define ISCSI_MAX_VLAN_PRIORITY		7
+
+/* iscsi vlan enable/disabled setting */
+#define ISCSI_VLAN_DISABLE	0x01
+#define ISCSI_VLAN_ENABLE	0x02
+
 /* iSCSI network params */
 enum iscsi_net_param {
 	ISCSI_NET_PARAM_IPV4_ADDR		= 1,
@@ -296,8 +303,10 @@ enum iscsi_net_param {
 	ISCSI_NET_PARAM_IPV6_ROUTER_AUTOCFG	= 11,
 	ISCSI_NET_PARAM_IFACE_ENABLE		= 12,
 	ISCSI_NET_PARAM_VLAN_ID			= 13,
-	ISCSI_NET_PARAM_IFACE_TYPE		= 14,
-	ISCSI_NET_PARAM_IFACE_NAME		= 15,
+	ISCSI_NET_PARAM_VLAN_PRIORITY		= 14,
+	ISCSI_NET_PARAM_VLAN_ENABLED		= 15,
+	ISCSI_NET_PARAM_IFACE_TYPE		= 16,
+	ISCSI_NET_PARAM_IFACE_NAME		= 17,
 };
 
 /*</pre>
    <div class="pagination">
        <a href='5_5.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><span>[6]</span><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_7.html'>Next&gt;&gt;</a>
    <div>
</body>
