<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_4.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><span>[5]</span><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_6.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2191c00855b03aa59c20e698be713d952d51fc18
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 21 11:07:10 2022 -0400

    USB: gadget: Fix use-after-free Read in usb_udc_uevent()
    
    The syzbot fuzzer found a race between uevent callbacks and gadget
    driver unregistration that can cause a use-after-free bug:
    
    ---------------------------------------------------------------
    BUG: KASAN: use-after-free in usb_udc_uevent+0x11f/0x130
    drivers/usb/gadget/udc/core.c:1732
    Read of size 8 at addr ffff888078ce2050 by task udevd/2968
    
    CPU: 1 PID: 2968 Comm: udevd Not tainted 5.19.0-rc4-next-20220628-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    06/29/2022
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:317 [inline]
     print_report.cold+0x2ba/0x719 mm/kasan/report.c:433
     kasan_report+0xbe/0x1f0 mm/kasan/report.c:495
     usb_udc_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732
     dev_uevent+0x290/0x770 drivers/base/core.c:2424
    ---------------------------------------------------------------
    
    The bug occurs because usb_udc_uevent() dereferences udc-&gt;driver but
    does so without acquiring the udc_lock mutex, which protects this
    field.  If the gadget driver is unbound from the udc concurrently with
    uevent processing, the driver structure may be accessed after it has
    been deallocated.
    
    To prevent the race, we make sure that the routine holds the mutex
    around the racing accesses.
    
    Link: &lt;https://lore.kernel.org/all/0000000000004de90405a719c951@google.com&gt;
    CC: stable@vger.kernel.org # fc274c1e9973
    Reported-and-tested-by: syzbot+b0de012ceb1e2a97891b@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YtlrnhHyrHsSky9m@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 7886497253cc..cafcf260394c 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1728,13 +1728,14 @@ static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return ret;
 	}
 
-	if (udc-&gt;driver) {
+	mutex_lock(&amp;udc_lock);
+	if (udc-&gt;driver)
 		ret = add_uevent_var(env, "USB_UDC_DRIVER=%s",
 				udc-&gt;driver-&gt;function);
-		if (ret) {
-			dev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");
-			return ret;
-		}
+	mutex_unlock(&amp;udc_lock);
+	if (ret) {
+		dev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");
+		return ret;
 	}
 
 	return 0;</pre><hr><pre>commit 90bc2af24638659da56397ff835f3c95a948f991
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 22 10:46:31 2022 -0400

    USB: gadget: Fix double-free bug in raw_gadget driver
    
    Re-reading a recently merged fix to the raw_gadget driver showed that
    it inadvertently introduced a double-free bug in a failure pathway.
    If raw_ioctl_init() encounters an error after the driver ID number has
    been allocated, it deallocates the ID number before returning.  But
    when dev_free() runs later on, it will then try to deallocate the ID
    number a second time.
    
    Closely related to this issue is another error in the recent fix: The
    ID number is stored in the raw_dev structure before the code checks to
    see whether the structure has already been initialized, in which case
    the new ID number would overwrite the earlier value.
    
    The solution to both bugs is to keep the new ID number in a local
    variable, and store it in the raw_dev structure only after the check
    for prior initialization.  No errors can occur after that point, so
    the double-free will never happen.
    
    Fixes: f2d8c2606825 ("usb: gadget: Fix non-unique driver names in raw-gadget driver")
    CC: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YrMrRw5AyIZghN0v@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 5c8481cef35f..2acece16b890 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -430,6 +430,7 @@ static int raw_release(struct inode *inode, struct file *fd)
 static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 {
 	int ret = 0;
+	int driver_id_number;
 	struct usb_raw_init arg;
 	char *udc_driver_name;
 	char *udc_device_name;
@@ -452,10 +453,9 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		return -EINVAL;
 	}
 
-	ret = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
-	if (ret &lt; 0)
-		return ret;
-	dev-&gt;driver_id_number = ret;
+	driver_id_number = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
+	if (driver_id_number &lt; 0)
+		return driver_id_number;
 
 	driver_driver_name = kmalloc(DRIVER_DRIVER_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!driver_driver_name) {
@@ -463,7 +463,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		goto out_free_driver_id_number;
 	}
 	snprintf(driver_driver_name, DRIVER_DRIVER_NAME_LENGTH_MAX,
-				DRIVER_NAME ".%d", dev-&gt;driver_id_number);
+				DRIVER_NAME ".%d", driver_id_number);
 
 	udc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!udc_driver_name) {
@@ -507,6 +507,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	dev-&gt;driver.driver.name = driver_driver_name;
 	dev-&gt;driver.udc_name = udc_device_name;
 	dev-&gt;driver.match_existing_only = 1;
+	dev-&gt;driver_id_number = driver_id_number;
 
 	dev-&gt;state = STATE_DEV_INITIALIZED;
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
@@ -521,7 +522,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 out_free_driver_driver_name:
 	kfree(driver_driver_name);
 out_free_driver_id_number:
-	ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
+	ida_free(&amp;driver_id_numbers, driver_id_number);
 	return ret;
 }
 </pre><hr><pre>commit f2d8c2606825317b77db1f9ba0fc26ef26160b30
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 13 10:17:03 2022 -0400

    usb: gadget: Fix non-unique driver names in raw-gadget driver
    
    In a report for a separate bug (which has already been fixed by commit
    5f0b5f4d50fa "usb: gadget: fix race when gadget driver register via
    ioctl") in the raw-gadget driver, the syzbot console log included
    error messages caused by attempted registration of a new driver with
    the same name as an existing driver:
    
    &gt; kobject_add_internal failed for raw-gadget with -EEXIST, don't try to register things with the same name in the same directory.
    &gt; UDC core: USB Raw Gadget: driver registration failed: -17
    &gt; misc raw-gadget: fail, usb_gadget_register_driver returned -17
    
    These errors arise because raw_gadget.c registers a separate UDC
    driver for each of the UDC instances it creates, but these drivers all
    have the same name: "raw-gadget".  Until recently this wasn't a
    problem, but when the "gadget" bus was added and UDC drivers were
    registered on this bus, it became possible for name conflicts to cause
    the registrations to fail.  The reason is simply that the bus code in
    the driver core uses the driver name as a sysfs directory name (e.g.,
    /sys/bus/gadget/drivers/raw-gadget/), and you can't create two
    directories with the same pathname.
    
    To fix this problem, the driver names used by raw-gadget are made
    distinct by appending a unique ID number: "raw-gadget.N", with a
    different value of N for each driver instance.  And to avoid the
    proliferation of error handling code in the raw_ioctl_init() routine,
    the error return paths are refactored into the common pattern (goto
    statements leading to cleanup code at the end of the routine).
    
    Link: https://lore.kernel.org/all/0000000000008c664105dffae2eb@google.com/
    Fixes: fc274c1e9973 "USB: gadget: Add a new bus for gadgets"
    CC: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+02b16343704b3af1667e@syzkaller.appspotmail.com
    Reviewed-by: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    Acked-by: Hillf Danton &lt;hdanton@sina.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YqdG32w+3h8c1s7z@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 241740024c50..5c8481cef35f 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -11,6 +11,7 @@
 #include &lt;linux/ctype.h&gt;
 #include &lt;linux/debugfs.h&gt;
 #include &lt;linux/delay.h&gt;
+#include &lt;linux/idr.h&gt;
 #include &lt;linux/kref.h&gt;
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/module.h&gt;
@@ -36,6 +37,9 @@ MODULE_LICENSE("GPL");
 
 /*----------------------------------------------------------------------*/
 
+static DEFINE_IDA(driver_id_numbers);
+#define DRIVER_DRIVER_NAME_LENGTH_MAX	32
+
 #define RAW_EVENT_QUEUE_SIZE	16
 
 struct raw_event_queue {
@@ -161,6 +165,9 @@ struct raw_dev {
 	/* Reference to misc device: */
 	struct device			*dev;
 
+	/* Make driver names unique */
+	int				driver_id_number;
+
 	/* Protected by lock: */
 	enum dev_state			state;
 	bool				gadget_registered;
@@ -189,6 +196,7 @@ static struct raw_dev *dev_new(void)
 	spin_lock_init(&amp;dev-&gt;lock);
 	init_completion(&amp;dev-&gt;ep0_done);
 	raw_event_queue_init(&amp;dev-&gt;queue);
+	dev-&gt;driver_id_number = -1;
 	return dev;
 }
 
@@ -199,6 +207,9 @@ static void dev_free(struct kref *kref)
 
 	kfree(dev-&gt;udc_name);
 	kfree(dev-&gt;driver.udc_name);
+	kfree(dev-&gt;driver.driver.name);
+	if (dev-&gt;driver_id_number &gt;= 0)
+		ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
 	if (dev-&gt;req) {
 		if (dev-&gt;ep0_urb_queued)
 			usb_ep_dequeue(dev-&gt;gadget-&gt;ep0, dev-&gt;req);
@@ -422,6 +433,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	struct usb_raw_init arg;
 	char *udc_driver_name;
 	char *udc_device_name;
+	char *driver_driver_name;
 	unsigned long flags;
 
 	if (copy_from_user(&amp;arg, (void __user *)value, sizeof(arg)))
@@ -440,36 +452,44 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		return -EINVAL;
 	}
 
+	ret = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
+	if (ret &lt; 0)
+		return ret;
+	dev-&gt;driver_id_number = ret;
+
+	driver_driver_name = kmalloc(DRIVER_DRIVER_NAME_LENGTH_MAX, GFP_KERNEL);
+	if (!driver_driver_name) {
+		ret = -ENOMEM;
+		goto out_free_driver_id_number;
+	}
+	snprintf(driver_driver_name, DRIVER_DRIVER_NAME_LENGTH_MAX,
+				DRIVER_NAME ".%d", dev-&gt;driver_id_number);
+
 	udc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
-	if (!udc_driver_name)
-		return -ENOMEM;
+	if (!udc_driver_name) {
+		ret = -ENOMEM;
+		goto out_free_driver_driver_name;
+	}
 	ret = strscpy(udc_driver_name, &amp;arg.driver_name[0],
 				UDC_NAME_LENGTH_MAX);
-	if (ret &lt; 0) {
-		kfree(udc_driver_name);
-		return ret;
-	}
+	if (ret &lt; 0)
+		goto out_free_udc_driver_name;
 	ret = 0;
 
 	udc_device_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!udc_device_name) {
-		kfree(udc_driver_name);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out_free_udc_driver_name;
 	}
 	ret = strscpy(udc_device_name, &amp;arg.device_name[0],
 				UDC_NAME_LENGTH_MAX);
-	if (ret &lt; 0) {
-		kfree(udc_driver_name);
-		kfree(udc_device_name);
-		return ret;
-	}
+	if (ret &lt; 0)
+		goto out_free_udc_device_name;
 	ret = 0;
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	if (dev-&gt;state != STATE_DEV_OPENED) {
 		dev_dbg(dev-&gt;dev, "fail, device is not opened\n");
-		kfree(udc_driver_name);
-		kfree(udc_device_name);
 		ret = -EINVAL;
 		goto out_unlock;
 	}
@@ -484,14 +504,24 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	dev-&gt;driver.suspend = gadget_suspend;
 	dev-&gt;driver.resume = gadget_resume;
 	dev-&gt;driver.reset = gadget_reset;
-	dev-&gt;driver.driver.name = DRIVER_NAME;
+	dev-&gt;driver.driver.name = driver_driver_name;
 	dev-&gt;driver.udc_name = udc_device_name;
 	dev-&gt;driver.match_existing_only = 1;
 
 	dev-&gt;state = STATE_DEV_INITIALIZED;
+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
+	return ret;
 
 out_unlock:
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
+out_free_udc_device_name:
+	kfree(udc_device_name);
+out_free_udc_driver_name:
+	kfree(udc_driver_name);
+out_free_driver_driver_name:
+	kfree(driver_driver_name);
+out_free_driver_id_number:
+	ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
 	return ret;
 }
 </pre><hr><pre>commit f9d76d15072caf1ec5558fa7cc6d93c7b9d33488
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 11:51:29 2022 -0400

    USB: gadget: Add ID numbers to gadget names
    
    Putting USB gadgets on a new bus of their own encounters a problem
    when multiple gadgets are present: They all have the same name!  The
    driver core fails with a "sys: cannot create duplicate filename" error
    when creating any of the /sys/bus/gadget/devices/&lt;gadget-name&gt;
    symbolic links after the first.
    
    This patch fixes the problem by adding a ".N" suffix to each gadget's
    name when the gadget is registered (where N is a unique ID number),
    thus making the names distinct.
    
    Reported-and-tested-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;
    Fixes: fc274c1e9973 ("USB: gadget: Add a new bus for gadgets")
    Link: https://lore.kernel.org/r/YnqKAXKyp9Vq/pbn@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 3281d8a3dae7..7886497253cc 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -12,6 +12,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/idr.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
 #include &lt;linux/sched/task_stack.h&gt;
@@ -23,6 +24,8 @@
 
 #include "trace.h"
 
+static DEFINE_IDA(gadget_id_numbers);
+
 static struct bus_type gadget_bus_type;
 
 /**
@@ -1248,7 +1251,6 @@ static void usb_udc_nop_release(struct device *dev)
 void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
 {
-	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
 
@@ -1304,12 +1306,21 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 	udc-&gt;vbus = true;
 
+	ret = ida_alloc(&amp;gadget_id_numbers, GFP_KERNEL);
+	if (ret &lt; 0)
+		goto err_del_udc;
+	gadget-&gt;id_number = ret;
+	dev_set_name(&amp;gadget-&gt;dev, "gadget.%d", ret);
+
 	ret = device_add(&amp;gadget-&gt;dev);
 	if (ret)
-		goto err_del_udc;
+		goto err_free_id;
 
 	return 0;
 
+ err_free_id:
+	ida_free(&amp;gadget_id_numbers, gadget-&gt;id_number);
+
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
@@ -1417,6 +1428,7 @@ void usb_del_gadget(struct usb_gadget *gadget)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;gadget-&gt;dev);
+	ida_free(&amp;gadget_id_numbers, gadget-&gt;id_number);
 	device_unregister(&amp;udc-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index cf7af8a0a6e9..3ad58b7a0824 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -386,6 +386,7 @@ struct usb_gadget_ops {
  * @lpm_capable: If the gadget max_speed is FULL or HIGH, this flag
  *	indicates that it supports LPM as per the LPM ECN &amp; errata.
  * @irq: the interrupt number for device controller.
+ * @id_number: a unique ID number for ensuring that gadget names are distinct
  *
  * Gadgets have a mostly-portable "gadget driver" implementing device
  * functions, handling all usb configurations and interfaces.  Gadget
@@ -446,6 +447,7 @@ struct usb_gadget {
 	unsigned			connected:1;
 	unsigned			lpm_capable:1;
 	int				irq;
+	int				id_number;
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 </pre><hr><pre>commit fc274c1e997314bf47f6a62c79b5d7e554ed59c4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:35:51 2022 -0400

    USB: gadget: Add a new bus for gadgets
    
    This patch adds a "gadget" bus and uses it for registering gadgets and
    their drivers.  From now on, bindings will be managed by the driver
    core rather than through ad-hoc manipulations in the UDC core.
    
    As part of this change, the driver_pending_list is removed.  The UDC
    core won't need to keep track of unbound drivers for later binding,
    because the driver core handles all of that for us.
    
    However, we do need one new feature: a way to prevent gadget drivers
    from being bound to more than one gadget at a time.  The existing code
    does this automatically, but the driver core doesn't -- it's perfectly
    happy to bind a single driver to all the matching devices on the bus.
    The patch adds a new bitflag to the usb_gadget_driver structure for
    this purpose.
    
    A nice side effect of this change is a reduction in the total lines of
    code, since now the driver core will do part of the work that the UDC
    used to do.
    
    A possible future patch could add udc devices to the gadget bus, say
    as a separate device type.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSpdxaDNeC2BBOf@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index a878e7afacdd..61790592b2c8 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -23,6 +23,8 @@
 
 #include "trace.h"
 
+static struct bus_type gadget_bus_type;
+
 /**
  * struct usb_udc - describes one usb device controller
  * @driver: the gadget driver pointer. For use by the class code
@@ -47,11 +49,9 @@ struct usb_udc {
 
 static struct class *udc_class;
 static LIST_HEAD(udc_list);
-static LIST_HEAD(gadget_driver_pending_list);
-static DEFINE_MUTEX(udc_lock);
 
-static int udc_bind_to_driver(struct usb_udc *udc,
-		struct usb_gadget_driver *driver);
+/* Protects udc_list, udc-&gt;driver, driver-&gt;is_bound, and related calls */
+static DEFINE_MUTEX(udc_lock);
 
 /* ------------------------------------------------------------------------- */
 
@@ -1238,24 +1238,6 @@ static void usb_udc_nop_release(struct device *dev)
 	dev_vdbg(dev, "%s\n", __func__);
 }
 
-/* should be called with udc_lock held */
-static int check_pending_gadget_drivers(struct usb_udc *udc)
-{
-	struct usb_gadget_driver *driver;
-	int ret = 0;
-
-	list_for_each_entry(driver, &amp;gadget_driver_pending_list, pending)
-		if (!driver-&gt;udc_name || strcmp(driver-&gt;udc_name,
-						dev_name(&amp;udc-&gt;dev)) == 0) {
-			ret = udc_bind_to_driver(udc, driver);
-			if (ret != -EPROBE_DEFER)
-				list_del_init(&amp;driver-&gt;pending);
-			break;
-		}
-
-	return ret;
-}
-
 /**
  * usb_initialize_gadget - initialize a gadget and its embedded struct device
  * @parent: the parent device to this udc. Usually the controller driver's
@@ -1276,6 +1258,7 @@ void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
 	device_initialize(&amp;gadget-&gt;dev);
+	gadget-&gt;dev.bus = &amp;gadget_bus_type;
 }
 EXPORT_SYMBOL_GPL(usb_initialize_gadget);
 
@@ -1312,6 +1295,7 @@ int usb_add_gadget(struct usb_gadget *gadget)
 
 	mutex_lock(&amp;udc_lock);
 	list_add_tail(&amp;udc-&gt;list, &amp;udc_list);
+	mutex_unlock(&amp;udc_lock);
 
 	ret = device_add(&amp;udc-&gt;dev);
 	if (ret)
@@ -1324,23 +1308,14 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	if (ret)
 		goto err_del_udc;
 
-	/* pick up one of pending gadget drivers */
-	ret = check_pending_gadget_drivers(udc);
-	if (ret)
-		goto err_del_gadget;
-
-	mutex_unlock(&amp;udc_lock);
-
 	return 0;
 
- err_del_gadget:
-	device_del(&amp;gadget-&gt;dev);
-
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
 
  err_unlist_udc:
+	mutex_lock(&amp;udc_lock);
 	list_del(&amp;udc-&gt;list);
 	mutex_unlock(&amp;udc_lock);
 
@@ -1419,24 +1394,6 @@ int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc);
 
-static void usb_gadget_remove_driver(struct usb_udc *udc)
-{
-	dev_dbg(&amp;udc-&gt;dev, "unregistering UDC driver [%s]\n",
-			udc-&gt;driver-&gt;function);
-
-	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
-
-	usb_gadget_disconnect(udc-&gt;gadget);
-	usb_gadget_disable_async_callbacks(udc);
-	if (udc-&gt;gadget-&gt;irq)
-		synchronize_irq(udc-&gt;gadget-&gt;irq);
-	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
-	usb_gadget_udc_stop(udc);
-
-	udc-&gt;driver = NULL;
-	udc-&gt;gadget-&gt;dev.driver = NULL;
-}
-
 /**
  * usb_del_gadget - deletes a gadget and unregisters its udc
  * @gadget: the gadget to be deleted.
@@ -1455,13 +1412,6 @@ void usb_del_gadget(struct usb_gadget *gadget)
 
 	mutex_lock(&amp;udc_lock);
 	list_del(&amp;udc-&gt;list);
-
-	if (udc-&gt;driver) {
-		struct usb_gadget_driver *driver = udc-&gt;driver;
-
-		usb_gadget_remove_driver(udc);
-		list_add(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);
-	}
 	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
@@ -1486,123 +1436,147 @@ EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
 /* ------------------------------------------------------------------------- */
 
-static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
+static int gadget_match_driver(struct device *dev, struct device_driver *drv)
 {
-	int ret;
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = container_of(drv,
+			struct usb_gadget_driver, driver);
+
+	/* If the driver specifies a udc_name, it must match the UDC's name */
+	if (driver-&gt;udc_name &amp;&amp;
+			strcmp(driver-&gt;udc_name, dev_name(&amp;udc-&gt;dev)) != 0)
+		return 0;
+
+	/* If the driver is already bound to a gadget, it doesn't match */
+	if (driver-&gt;is_bound)
+		return 0;
+
+	/* Otherwise any gadget driver matches any UDC */
+	return 1;
+}
 
-	dev_dbg(&amp;udc-&gt;dev, "registering UDC driver [%s]\n",
-			driver-&gt;function);
+static int gadget_bind_driver(struct device *dev)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = container_of(dev-&gt;driver,
+			struct usb_gadget_driver, driver);
+	int ret = 0;
 
+	mutex_lock(&amp;udc_lock);
+	if (driver-&gt;is_bound) {
+		mutex_unlock(&amp;udc_lock);
+		return -ENXIO;		/* Driver binds to only one gadget */
+	}
+	driver-&gt;is_bound = true;
 	udc-&gt;driver = driver;
-	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;
+	mutex_unlock(&amp;udc_lock);
+
+	dev_dbg(&amp;udc-&gt;dev, "binding gadget driver [%s]\n", driver-&gt;function);
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
 
+	mutex_lock(&amp;udc_lock);
 	ret = driver-&gt;bind(udc-&gt;gadget, driver);
 	if (ret)
-		goto err1;
+		goto err_bind;
+
 	ret = usb_gadget_udc_start(udc);
-	if (ret) {
-		driver-&gt;unbind(udc-&gt;gadget);
-		goto err1;
-	}
+	if (ret)
+		goto err_start;
 	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
+	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 	return 0;
-err1:
+
+ err_start:
+	driver-&gt;unbind(udc-&gt;gadget);
+
+ err_bind:
 	if (ret != -EISNAM)
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
-			udc-&gt;driver-&gt;function, ret);
+			driver-&gt;function, ret);
+
 	udc-&gt;driver = NULL;
-	udc-&gt;gadget-&gt;dev.driver = NULL;
+	driver-&gt;is_bound = false;
+	mutex_unlock(&amp;udc_lock);
+
 	return ret;
 }
 
-int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+static void gadget_unbind_driver(struct device *dev)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = udc-&gt;driver;
+
+	dev_dbg(&amp;udc-&gt;dev, "unbinding gadget driver [%s]\n", driver-&gt;function);
+
+	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
+
+	mutex_lock(&amp;udc_lock);
+	usb_gadget_disconnect(gadget);
+	usb_gadget_disable_async_callbacks(udc);
+	if (gadget-&gt;irq)
+		synchronize_irq(gadget-&gt;irq);
+	udc-&gt;driver-&gt;unbind(gadget);
+	usb_gadget_udc_stop(udc);
+
+	driver-&gt;is_bound = false;
+	udc-&gt;driver = NULL;
+	mutex_unlock(&amp;udc_lock);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,
+		struct module *owner, const char *mod_name)
 {
-	struct usb_udc		*udc = NULL, *iter;
-	int			ret = -ENODEV;
+	int ret;
 
 	if (!driver || !driver-&gt;bind || !driver-&gt;setup)
 		return -EINVAL;
 
+	driver-&gt;driver.bus = &amp;gadget_bus_type;
+	driver-&gt;driver.owner = owner;
+	driver-&gt;driver.mod_name = mod_name;
+	ret = driver_register(&amp;driver-&gt;driver);
+	if (ret) {
+		pr_warn("%s: driver registration failed: %d\n",
+				driver-&gt;function, ret);
+		return ret;
+	}
+
 	mutex_lock(&amp;udc_lock);
-	if (driver-&gt;udc_name) {
-		list_for_each_entry(iter, &amp;udc_list, list) {
-			ret = strcmp(driver-&gt;udc_name, dev_name(&amp;iter-&gt;dev));
-			if (ret)
-				continue;
-			udc = iter;
-			break;
-		}
-		if (ret)
-			ret = -ENODEV;
-		else if (udc-&gt;driver)
+	if (!driver-&gt;is_bound) {
+		if (driver-&gt;match_existing_only) {
+			pr_warn("%s: couldn't find an available UDC or it's busy\n",
+					driver-&gt;function);
 			ret = -EBUSY;
-		else
-			goto found;
-	} else {
-		list_for_each_entry(iter, &amp;udc_list, list) {
-			/* For now we take the first one */
-			if (iter-&gt;driver)
-				continue;
-			udc = iter;
-			goto found;
+		} else {
+			pr_info("%s: couldn't find an available UDC\n",
+					driver-&gt;function);
 		}
-	}
-
-	if (!driver-&gt;match_existing_only) {
-		list_add_tail(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);
-		pr_info("couldn't find an available UDC - added [%s] to list of pending drivers\n",
-			driver-&gt;function);
 		ret = 0;
 	}
-
 	mutex_unlock(&amp;udc_lock);
+
 	if (ret)
-		pr_warn("couldn't find an available UDC or it's busy: %d\n", ret);
-	return ret;
-found:
-	ret = udc_bind_to_driver(udc, driver);
-	mutex_unlock(&amp;udc_lock);
+		driver_unregister(&amp;driver-&gt;driver);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(usb_gadget_register_driver);
+EXPORT_SYMBOL_GPL(usb_gadget_register_driver_owner);
 
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
-	struct usb_udc		*udc = NULL;
-	int			ret = -ENODEV;
-
 	if (!driver || !driver-&gt;unbind)
 		return -EINVAL;
 
-	mutex_lock(&amp;udc_lock);
-	list_for_each_entry(udc, &amp;udc_list, list) {
-		if (udc-&gt;driver == driver) {
-			usb_gadget_remove_driver(udc);
-			usb_gadget_set_state(udc-&gt;gadget,
-					     USB_STATE_NOTATTACHED);
-
-			/* Maybe there is someone waiting for this UDC? */
-			check_pending_gadget_drivers(udc);
-			/*
-			 * For now we ignore bind errors as probably it's
-			 * not a valid reason to fail other's gadget unbind
-			 */
-			ret = 0;
-			break;
-		}
-	}
-
-	if (ret) {
-		list_del(&amp;driver-&gt;pending);
-		ret = 0;
-	}
-	mutex_unlock(&amp;udc_lock);
-	return ret;
+	driver_unregister(&amp;driver-&gt;driver);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_gadget_unregister_driver);
 
@@ -1754,8 +1728,17 @@ static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static struct bus_type gadget_bus_type = {
+	.name = "gadget",
+	.probe = gadget_bind_driver,
+	.remove = gadget_unbind_driver,
+	.match = gadget_match_driver,
+};
+
 static int __init usb_udc_init(void)
 {
+	int rc;
+
 	udc_class = class_create(THIS_MODULE, "udc");
 	if (IS_ERR(udc_class)) {
 		pr_err("failed to create udc class --&gt; %ld\n",
@@ -1764,12 +1747,17 @@ static int __init usb_udc_init(void)
 	}
 
 	udc_class-&gt;dev_uevent = usb_udc_uevent;
-	return 0;
+
+	rc = bus_register(&amp;gadget_bus_type);
+	if (rc)
+		class_destroy(udc_class);
+	return rc;
 }
 subsys_initcall(usb_udc_init);
 
 static void __exit usb_udc_exit(void)
 {
+	bus_unregister(&amp;gadget_bus_type);
 	class_destroy(udc_class);
 }
 module_exit(usb_udc_exit);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 5830b8a903da..cf7af8a0a6e9 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -664,9 +664,9 @@ static inline int usb_gadget_check_config(struct usb_gadget *gadget)
  * @driver: Driver model state for this driver.
  * @udc_name: A name of UDC this driver should be bound to. If udc_name is NULL,
  *	this driver will be bound to any available UDC.
- * @pending: UDC core private data used for deferred probe of this driver.
- * @match_existing_only: If udc is not found, return an error and don't add this
- *      gadget driver to list of pending driver
+ * @match_existing_only: If udc is not found, return an error and fail
+ *	the driver registration
+ * @is_bound: Allow a driver to be bound to only one gadget
  *
  * Devices are disabled till a gadget driver successfully bind()s, which
  * means the driver will handle setup() requests needed to enumerate (and
@@ -729,8 +729,8 @@ struct usb_gadget_driver {
 	struct device_driver	driver;
 
 	char			*udc_name;
-	struct list_head	pending;
 	unsigned                match_existing_only:1;
+	bool			is_bound:1;
 };
 
 
@@ -740,22 +740,30 @@ struct usb_gadget_driver {
 /* driver modules register and unregister, as usual.
  * these calls must be made in a context that can sleep.
  *
- * these will usually be implemented directly by the hardware-dependent
- * usb bus interface driver, which will only support a single driver.
+ * A gadget driver can be bound to only one gadget at a time.
  */
 
 /**
- * usb_gadget_register_driver - register a gadget driver
+ * usb_gadget_register_driver_owner - register a gadget driver
  * @driver: the driver being registered
+ * @owner: the driver module
+ * @mod_name: the driver module's build name
  * Context: can sleep
  *
  * Call this in your gadget driver's module initialization function,
- * to tell the underlying usb controller driver about your driver.
+ * to tell the underlying UDC controller driver about your driver.
  * The @bind() function will be called to bind it to a gadget before this
  * registration call returns.  It's expected that the @bind() function will
  * be in init sections.
+ *
+ * Use the macro defined below instead of calling this directly.
  */
-int usb_gadget_register_driver(struct usb_gadget_driver *driver);
+int usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,
+		struct module *owner, const char *mod_name);
+
+/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */
+#define usb_gadget_register_driver(driver) \
+	usb_gadget_register_driver_owner(driver, THIS_MODULE, KBUILD_MODNAME)
 
 /**
  * usb_gadget_unregister_driver - unregister a gadget driver</pre><hr><pre>commit d59f6d958596b54b722605657c3b56a79843695a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:34:34 2022 -0400

    USB: gadget: Fix mistakes in UDC core kerneldoc
    
    This patch fixes some minor mistakes in the UDC core's kerneldoc.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSpKpnWR8WWEk/p@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 014daa07eb8c..a878e7afacdd 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1262,9 +1262,6 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
  * device.
  * @gadget: the gadget to be initialized.
  * @release: a gadget release function.
- *
- * Returns zero on success, negative errno otherwise.
- * Calls the gadget release function in the latter case.
  */
 void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
@@ -1441,11 +1438,10 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 }
 
 /**
- * usb_del_gadget - deletes @udc from udc_list
- * @gadget: the gadget to be removed.
+ * usb_del_gadget - deletes a gadget and unregisters its udc
+ * @gadget: the gadget to be deleted.
  *
- * This will call usb_gadget_unregister_driver() if
- * the @udc is still busy.
+ * This will unbind @gadget, if it is bound.
  * It will not do a final usb_put_gadget().
  */
 void usb_del_gadget(struct usb_gadget *gadget)
@@ -1476,8 +1472,8 @@ void usb_del_gadget(struct usb_gadget *gadget)
 EXPORT_SYMBOL_GPL(usb_del_gadget);
 
 /**
- * usb_del_gadget_udc - deletes @udc from udc_list
- * @gadget: the gadget to be removed.
+ * usb_del_gadget_udc - unregisters a gadget
+ * @gadget: the gadget to be unregistered.
  *
  * Calls usb_del_gadget() and does a final usb_put_gadget().
  */</pre><hr><pre>commit 6ebb449f9f25e0da804d1247b4ffcc361321494d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:33:29 2022 -0400

    USB: gadget: Register udc before gadget
    
    In preparation for adding a "gadget" bus, this patch reverses the
    order of registration of udc and gadget devices in usb_add_gadget().
    
    The current code adds the gadget device first, probably because that
    was more convenient at the time and the order didn't really matter.
    But with the upcoming change, adding the gadget will cause driver
    probing to occur.  Unwinding that on the error pathway will become
    much more obtrusive, not to mention the fact that a gadget driver
    might not work properly before the udc is registered.  It's better to
    register the udc device first, particularly since that doesn't involve
    a bus or driver binding and therefore is simpler to unwind.
    
    For symmetry, the order of unregistration in usb_del_gadget() is
    likewise reversed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSo6fU1FlNq8cOZ@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index f0cce482b74a..014daa07eb8c 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1308,10 +1308,6 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	if (ret)
 		goto err_put_udc;
 
-	ret = device_add(&amp;gadget-&gt;dev);
-	if (ret)
-		goto err_put_udc;
-
 	udc-&gt;gadget = gadget;
 	gadget-&gt;udc = udc;
 
@@ -1327,15 +1323,22 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 	udc-&gt;vbus = true;
 
+	ret = device_add(&amp;gadget-&gt;dev);
+	if (ret)
+		goto err_del_udc;
+
 	/* pick up one of pending gadget drivers */
 	ret = check_pending_gadget_drivers(udc);
 	if (ret)
-		goto err_del_udc;
+		goto err_del_gadget;
 
 	mutex_unlock(&amp;udc_lock);
 
 	return 0;
 
+ err_del_gadget:
+	device_del(&amp;gadget-&gt;dev);
+
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
@@ -1344,8 +1347,6 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	list_del(&amp;udc-&gt;list);
 	mutex_unlock(&amp;udc_lock);
 
-	device_del(&amp;gadget-&gt;dev);
-
  err_put_udc:
 	put_device(&amp;udc-&gt;dev);
 
@@ -1469,8 +1470,8 @@ void usb_del_gadget(struct usb_gadget *gadget)
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
-	device_unregister(&amp;udc-&gt;dev);
 	device_del(&amp;gadget-&gt;dev);
+	device_unregister(&amp;udc-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget);
 </pre><hr><pre>commit af1969a2d734d6272c0640b50c3ed31e59e203a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 20:42:03 2022 -0400

    USB: gadget: Rename usb_gadget_probe_driver()
    
    In preparation for adding a "gadget" bus, this patch renames
    usb_gadget_probe_driver() to usb_gadget_register_driver().  The new
    name will be more accurate, since gadget drivers will be registered on
    the gadget bus and the probing will be done by the driver core, not
    the UDC core.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSc29YZvxgT5fEJ@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2eaeaae96759..403563c06477 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2505,7 +2505,7 @@ int usb_composite_probe(struct usb_composite_driver *driver)
 	gadget_driver-&gt;driver.name = driver-&gt;name;
 	gadget_driver-&gt;max_speed = driver-&gt;max_speed;
 
-	return usb_gadget_probe_driver(gadget_driver);
+	return usb_gadget_register_driver(gadget_driver);
 }
 EXPORT_SYMBOL_GPL(usb_composite_probe);
 
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index 1fb837d9271e..4141206bb0ed 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -284,7 +284,7 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 			goto err;
 		}
 		gi-&gt;composite.gadget_driver.udc_name = name;
-		ret = usb_gadget_probe_driver(&amp;gi-&gt;composite.gadget_driver);
+		ret = usb_gadget_register_driver(&amp;gi-&gt;composite.gadget_driver);
 		if (ret) {
 			gi-&gt;composite.gadget_driver.udc_name = NULL;
 			goto err;
diff --git a/drivers/usb/gadget/legacy/dbgp.c b/drivers/usb/gadget/legacy/dbgp.c
index 6bcbad382580..b62e45235e8e 100644
--- a/drivers/usb/gadget/legacy/dbgp.c
+++ b/drivers/usb/gadget/legacy/dbgp.c
@@ -422,7 +422,7 @@ static struct usb_gadget_driver dbgp_driver = {
 
 static int __init dbgp_init(void)
 {
-	return usb_gadget_probe_driver(&amp;dbgp_driver);
+	return usb_gadget_register_driver(&amp;dbgp_driver);
 }
 
 static void __exit dbgp_exit(void)
diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 0c01e749f9ea..79990597c39f 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1873,7 +1873,7 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	else
 		gadgetfs_driver.max_speed = USB_SPEED_FULL;
 
-	value = usb_gadget_probe_driver(&amp;gadgetfs_driver);
+	value = usb_gadget_register_driver(&amp;gadgetfs_driver);
 	if (value != 0) {
 		spin_lock_irq(&amp;dev-&gt;lock);
 		goto fail;
diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 8d40a1f2ec57..b3be8db1ff63 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -510,12 +510,12 @@ static int raw_ioctl_run(struct raw_dev *dev, unsigned long value)
 	}
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
-	ret = usb_gadget_probe_driver(&amp;dev-&gt;driver);
+	ret = usb_gadget_register_driver(&amp;dev-&gt;driver);
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	if (ret) {
 		dev_err(dev-&gt;dev,
-			"fail, usb_gadget_probe_driver returned %d\n", ret);
+			"fail, usb_gadget_register_driver returned %d\n", ret);
 		dev-&gt;state = STATE_DEV_FAILED;
 		goto out_unlock;
 	}
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 85b194011a16..f0cce482b74a 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1523,7 +1523,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 	return ret;
 }
 
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	struct usb_udc		*udc = NULL, *iter;
 	int			ret = -ENODEV;
@@ -1572,7 +1572,7 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
 	mutex_unlock(&amp;udc_lock);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(usb_gadget_probe_driver);
+EXPORT_SYMBOL_GPL(usb_gadget_register_driver);
 
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 10fe57cf40be..5830b8a903da 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -745,7 +745,7 @@ struct usb_gadget_driver {
  */
 
 /**
- * usb_gadget_probe_driver - probe a gadget driver
+ * usb_gadget_register_driver - register a gadget driver
  * @driver: the driver being registered
  * Context: can sleep
  *
@@ -755,7 +755,7 @@ struct usb_gadget_driver {
  * registration call returns.  It's expected that the @bind() function will
  * be in init sections.
  */
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver);
+int usb_gadget_register_driver(struct usb_gadget_driver *driver);
 
 /**
  * usb_gadget_unregister_driver - unregister a gadget driver</pre><hr><pre>commit 1892bf90677abcad7f06e897e308f5c3e3618dd4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 17 16:39:10 2022 -0400

    USB: usb-storage: Fix use of bitfields for hardware data in ene_ub6250.c
    
    The kernel test robot found a problem with the ene_ub6250 subdriver in
    usb-storage: It uses structures containing bitfields to represent
    hardware bits in its SD_STATUS, MS_STATUS, and SM_STATUS bytes.  This
    is not safe; it presumes a particular bit ordering and it assumes the
    compiler will not insert padding, neither of which is guaranteed.
    
    This patch fixes the problem by changing the structures to simple u8
    values, with the bitfields replaced by bitmask constants.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YjOcbuU106UpJ/V8@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 5f7d678502be..6012603f3630 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -237,36 +237,33 @@ static struct us_unusual_dev ene_ub6250_unusual_dev_list[] = {
 #define memstick_logaddr(logadr1, logadr0) ((((u16)(logadr1)) &lt;&lt; 8) | (logadr0))
 
 
-struct SD_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    IsMMC:1;
-	u8    HiCapacity:1;
-	u8    HiSpeed:1;
-	u8    WtP:1;
-	u8    Reserved:1;
-};
-
-struct MS_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    IsMSPro:1;
-	u8    IsMSPHG:1;
-	u8    Reserved1:1;
-	u8    WtP:1;
-	u8    Reserved2:1;
-};
-
-struct SM_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    Reserved:3;
-	u8    WtP:1;
-	u8    IsMS:1;
-};
+/* SD_STATUS bits */
+#define SD_Insert	BIT(0)
+#define SD_Ready	BIT(1)
+#define SD_MediaChange	BIT(2)
+#define SD_IsMMC	BIT(3)
+#define SD_HiCapacity	BIT(4)
+#define SD_HiSpeed	BIT(5)
+#define SD_WtP		BIT(6)
+			/* Bit 7 reserved */
+
+/* MS_STATUS bits */
+#define MS_Insert	BIT(0)
+#define MS_Ready	BIT(1)
+#define MS_MediaChange	BIT(2)
+#define MS_IsMSPro	BIT(3)
+#define MS_IsMSPHG	BIT(4)
+			/* Bit 5 reserved */
+#define MS_WtP		BIT(6)
+			/* Bit 7 reserved */
+
+/* SM_STATUS bits */
+#define SM_Insert	BIT(0)
+#define SM_Ready	BIT(1)
+#define SM_MediaChange	BIT(2)
+			/* Bits 3-5 reserved */
+#define SM_WtP		BIT(6)
+#define SM_IsMS		BIT(7)
 
 struct ms_bootblock_cis {
 	u8 bCistplDEVICE[6];    /* 0 */
@@ -437,9 +434,9 @@ struct ene_ub6250_info {
 	u8		*bbuf;
 
 	/* for 6250 code */
-	struct SD_STATUS	SD_Status;
-	struct MS_STATUS	MS_Status;
-	struct SM_STATUS	SM_Status;
+	u8		SD_Status;
+	u8		MS_Status;
+	u8		SM_Status;
 
 	/* ----- SD Control Data ---------------- */
 	/*SD_REGISTER SD_Regs; */
@@ -602,7 +599,7 @@ static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 
-	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready)
+	if ((info-&gt;SD_Status &amp; SD_Insert) &amp;&amp; (info-&gt;SD_Status &amp; SD_Ready))
 		return USB_STOR_TRANSPORT_GOOD;
 	else {
 		ene_sd_init(us);
@@ -622,7 +619,7 @@ static int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 		0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,
 		0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };
 
-	if (info-&gt;SD_Status.WtP)
+	if (info-&gt;SD_Status &amp; SD_WtP)
 		usb_stor_set_xfer_buf(mediaWP, 12, srb);
 	else
 		usb_stor_set_xfer_buf(mediaNoWP, 12, srb);
@@ -641,9 +638,9 @@ static int sd_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 
 	usb_stor_dbg(us, "sd_scsi_read_capacity\n");
-	if (info-&gt;SD_Status.HiCapacity) {
+	if (info-&gt;SD_Status &amp; SD_HiCapacity) {
 		bl_len = 0x200;
-		if (info-&gt;SD_Status.IsMMC)
+		if (info-&gt;SD_Status &amp; SD_IsMMC)
 			bl_num = info-&gt;HC_C_SIZE-1;
 		else
 			bl_num = (info-&gt;HC_C_SIZE + 1) * 1024 - 1;
@@ -693,7 +690,7 @@ static int sd_scsi_read(struct us_data *us, struct scsi_cmnd *srb)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	if (info-&gt;SD_Status.HiCapacity)
+	if (info-&gt;SD_Status &amp; SD_HiCapacity)
 		bnByte = bn;
 
 	/* set up the command wrapper */
@@ -733,7 +730,7 @@ static int sd_scsi_write(struct us_data *us, struct scsi_cmnd *srb)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	if (info-&gt;SD_Status.HiCapacity)
+	if (info-&gt;SD_Status &amp; SD_HiCapacity)
 		bnByte = bn;
 
 	/* set up the command wrapper */
@@ -1456,7 +1453,7 @@ static int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
 	/* pr_info("MS_SCSI_Test_Unit_Ready\n"); */
-	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
+	if ((info-&gt;MS_Status &amp; MS_Insert) &amp;&amp; (info-&gt;MS_Status &amp; MS_Ready)) {
 		return USB_STOR_TRANSPORT_GOOD;
 	} else {
 		ene_ms_init(us);
@@ -1476,7 +1473,7 @@ static int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 		0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,
 		0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };
 
-	if (info-&gt;MS_Status.WtP)
+	if (info-&gt;MS_Status &amp; MS_WtP)
 		usb_stor_set_xfer_buf(mediaWP, 12, srb);
 	else
 		usb_stor_set_xfer_buf(mediaNoWP, 12, srb);
@@ -1495,7 +1492,7 @@ static int ms_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)
 
 	usb_stor_dbg(us, "ms_scsi_read_capacity\n");
 	bl_len = 0x200;
-	if (info-&gt;MS_Status.IsMSPro)
+	if (info-&gt;MS_Status &amp; MS_IsMSPro)
 		bl_num = info-&gt;MSP_TotalBlock - 1;
 	else
 		bl_num = info-&gt;MS_Lib.NumberOfLogBlock * info-&gt;MS_Lib.blockSize * 2 - 1;
@@ -1650,7 +1647,7 @@ static int ms_scsi_read(struct us_data *us, struct scsi_cmnd *srb)
 	if (bn &gt; info-&gt;bl_num)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	if (info-&gt;MS_Status.IsMSPro) {
+	if (info-&gt;MS_Status &amp; MS_IsMSPro) {
 		result = ene_load_bincode(us, MSP_RW_PATTERN);
 		if (result != USB_STOR_XFER_GOOD) {
 			usb_stor_dbg(us, "Load MPS RW pattern Fail !!\n");
@@ -1751,7 +1748,7 @@ static int ms_scsi_write(struct us_data *us, struct scsi_cmnd *srb)
 	if (bn &gt; info-&gt;bl_num)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	if (info-&gt;MS_Status.IsMSPro) {
+	if (info-&gt;MS_Status &amp; MS_IsMSPro) {
 		result = ene_load_bincode(us, MSP_RW_PATTERN);
 		if (result != USB_STOR_XFER_GOOD) {
 			pr_info("Load MSP RW pattern Fail !!\n");
@@ -1859,12 +1856,12 @@ static int ene_get_card_status(struct us_data *us, u8 *buf)
 
 	tmpreg = (u16) reg4b;
 	reg4b = *(u32 *)(&amp;buf[0x14]);
-	if (info-&gt;SD_Status.HiCapacity &amp;&amp; !info-&gt;SD_Status.IsMMC)
+	if ((info-&gt;SD_Status &amp; SD_HiCapacity) &amp;&amp; !(info-&gt;SD_Status &amp; SD_IsMMC))
 		info-&gt;HC_C_SIZE = (reg4b &gt;&gt; 8) &amp; 0x3fffff;
 
 	info-&gt;SD_C_SIZE = ((tmpreg &amp; 0x03) &lt;&lt; 10) | (u16)(reg4b &gt;&gt; 22);
 	info-&gt;SD_C_SIZE_MULT = (u8)(reg4b &gt;&gt; 7)  &amp; 0x07;
-	if (info-&gt;SD_Status.HiCapacity &amp;&amp; info-&gt;SD_Status.IsMMC)
+	if ((info-&gt;SD_Status &amp; SD_HiCapacity) &amp;&amp; (info-&gt;SD_Status &amp; SD_IsMMC))
 		info-&gt;HC_C_SIZE = *(u32 *)(&amp;buf[0x100]);
 
 	if (info-&gt;SD_READ_BL_LEN &gt; SD_BLOCK_LEN) {
@@ -2076,6 +2073,7 @@ static int ene_ms_init(struct us_data *us)
 	u16 MSP_BlockSize, MSP_UserAreaBlocks;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 	u8 *bbuf = info-&gt;bbuf;
+	unsigned int s;
 
 	printk(KERN_INFO "transport --- ENE_MSInit\n");
 
@@ -2100,15 +2098,16 @@ static int ene_ms_init(struct us_data *us)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	/* the same part to test ENE */
-	info-&gt;MS_Status = *(struct MS_STATUS *) bbuf;
-
-	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
-		printk(KERN_INFO "Insert     = %x\n", info-&gt;MS_Status.Insert);
-		printk(KERN_INFO "Ready      = %x\n", info-&gt;MS_Status.Ready);
-		printk(KERN_INFO "IsMSPro    = %x\n", info-&gt;MS_Status.IsMSPro);
-		printk(KERN_INFO "IsMSPHG    = %x\n", info-&gt;MS_Status.IsMSPHG);
-		printk(KERN_INFO "WtP= %x\n", info-&gt;MS_Status.WtP);
-		if (info-&gt;MS_Status.IsMSPro) {
+	info-&gt;MS_Status = bbuf[0];
+
+	s = info-&gt;MS_Status;
+	if ((s &amp; MS_Insert) &amp;&amp; (s &amp; MS_Ready)) {
+		printk(KERN_INFO "Insert     = %x\n", !!(s &amp; MS_Insert));
+		printk(KERN_INFO "Ready      = %x\n", !!(s &amp; MS_Ready));
+		printk(KERN_INFO "IsMSPro    = %x\n", !!(s &amp; MS_IsMSPro));
+		printk(KERN_INFO "IsMSPHG    = %x\n", !!(s &amp; MS_IsMSPHG));
+		printk(KERN_INFO "WtP= %x\n", !!(s &amp; MS_WtP));
+		if (s &amp; MS_IsMSPro) {
 			MSP_BlockSize      = (bbuf[6] &lt;&lt; 8) | bbuf[7];
 			MSP_UserAreaBlocks = (bbuf[10] &lt;&lt; 8) | bbuf[11];
 			info-&gt;MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;
@@ -2169,17 +2168,17 @@ static int ene_sd_init(struct us_data *us)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	info-&gt;SD_Status =  *(struct SD_STATUS *) bbuf;
-	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready) {
-		struct SD_STATUS *s = &amp;info-&gt;SD_Status;
+	info-&gt;SD_Status = bbuf[0];
+	if ((info-&gt;SD_Status &amp; SD_Insert) &amp;&amp; (info-&gt;SD_Status &amp; SD_Ready)) {
+		unsigned int s = info-&gt;SD_Status;
 
 		ene_get_card_status(us, bbuf);
-		usb_stor_dbg(us, "Insert     = %x\n", s-&gt;Insert);
-		usb_stor_dbg(us, "Ready      = %x\n", s-&gt;Ready);
-		usb_stor_dbg(us, "IsMMC      = %x\n", s-&gt;IsMMC);
-		usb_stor_dbg(us, "HiCapacity = %x\n", s-&gt;HiCapacity);
-		usb_stor_dbg(us, "HiSpeed    = %x\n", s-&gt;HiSpeed);
-		usb_stor_dbg(us, "WtP        = %x\n", s-&gt;WtP);
+		usb_stor_dbg(us, "Insert     = %x\n", !!(s &amp; SD_Insert));
+		usb_stor_dbg(us, "Ready      = %x\n", !!(s &amp; SD_Ready));
+		usb_stor_dbg(us, "IsMMC      = %x\n", !!(s &amp; SD_IsMMC));
+		usb_stor_dbg(us, "HiCapacity = %x\n", !!(s &amp; SD_HiCapacity));
+		usb_stor_dbg(us, "HiSpeed    = %x\n", !!(s &amp; SD_HiSpeed));
+		usb_stor_dbg(us, "WtP        = %x\n", !!(s &amp; SD_WtP));
 	} else {
 		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
@@ -2201,14 +2200,14 @@ static int ene_init(struct us_data *us)
 
 	misc_reg03 = bbuf[0];
 	if (misc_reg03 &amp; 0x01) {
-		if (!info-&gt;SD_Status.Ready) {
+		if (!(info-&gt;SD_Status &amp; SD_Ready)) {
 			result = ene_sd_init(us);
 			if (result != USB_STOR_XFER_GOOD)
 				return USB_STOR_TRANSPORT_ERROR;
 		}
 	}
 	if (misc_reg03 &amp; 0x02) {
-		if (!info-&gt;MS_Status.Ready) {
+		if (!(info-&gt;MS_Status &amp; MS_Ready)) {
 			result = ene_ms_init(us);
 			if (result != USB_STOR_XFER_GOOD)
 				return USB_STOR_TRANSPORT_ERROR;
@@ -2307,14 +2306,14 @@ static int ene_transport(struct scsi_cmnd *srb, struct us_data *us)
 
 	/*US_DEBUG(usb_stor_show_command(us, srb)); */
 	scsi_set_resid(srb, 0);
-	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready)))
+	if (unlikely(!(info-&gt;SD_Status &amp; SD_Ready) || (info-&gt;MS_Status &amp; MS_Ready)))
 		result = ene_init(us);
 	if (result == USB_STOR_XFER_GOOD) {
 		result = USB_STOR_TRANSPORT_ERROR;
-		if (info-&gt;SD_Status.Ready)
+		if (info-&gt;SD_Status &amp; SD_Ready)
 			result = sd_scsi_irp(us, srb);
 
-		if (info-&gt;MS_Status.Ready)
+		if (info-&gt;MS_Status &amp; MS_Ready)
 			result = ms_scsi_irp(us, srb);
 	}
 	return result;
@@ -2378,7 +2377,6 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 
 static int ene_ub6250_resume(struct usb_interface *iface)
 {
-	u8 tmp = 0;
 	struct us_data *us = usb_get_intfdata(iface);
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
@@ -2390,17 +2388,16 @@ static int ene_ub6250_resume(struct usb_interface *iface)
 	mutex_unlock(&amp;us-&gt;dev_mutex);
 
 	info-&gt;Power_IsResum = true;
-	/*info-&gt;SD_Status.Ready = 0; */
-	info-&gt;SD_Status = *(struct SD_STATUS *)&amp;tmp;
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;tmp;
-	info-&gt;SM_Status = *(struct SM_STATUS *)&amp;tmp;
+	/* info-&gt;SD_Status &amp;= ~SD_Ready; */
+	info-&gt;SD_Status = 0;
+	info-&gt;MS_Status = 0;
+	info-&gt;SM_Status = 0;
 
 	return 0;
 }
 
 static int ene_ub6250_reset_resume(struct usb_interface *iface)
 {
-	u8 tmp = 0;
 	struct us_data *us = usb_get_intfdata(iface);
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
@@ -2412,10 +2409,10 @@ static int ene_ub6250_reset_resume(struct usb_interface *iface)
 	 * the device
 	 */
 	info-&gt;Power_IsResum = true;
-	/*info-&gt;SD_Status.Ready = 0; */
-	info-&gt;SD_Status = *(struct SD_STATUS *)&amp;tmp;
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;tmp;
-	info-&gt;SM_Status = *(struct SM_STATUS *)&amp;tmp;
+	/* info-&gt;SD_Status &amp;= ~SD_Ready; */
+	info-&gt;SD_Status = 0;
+	info-&gt;MS_Status = 0;
+	info-&gt;SM_Status = 0;
 
 	return 0;
 }</pre><hr><pre>commit 16b1941eac2bd499f065a6739a40ce0011a3d740
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Mar 5 21:47:22 2022 -0500

    usb: gadget: Fix use-after-free bug by not setting udc-&gt;dev.driver
    
    The syzbot fuzzer found a use-after-free bug:
    
    BUG: KASAN: use-after-free in dev_uevent+0x712/0x780 drivers/base/core.c:2320
    Read of size 8 at addr ffff88802b934098 by task udevd/3689
    
    CPU: 2 PID: 3689 Comm: udevd Not tainted 5.17.0-rc4-syzkaller-00229-g4f12b742eb2b #0
    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     print_address_description.constprop.0.cold+0x8d/0x303 mm/kasan/report.c:255
     __kasan_report mm/kasan/report.c:442 [inline]
     kasan_report.cold+0x83/0xdf mm/kasan/report.c:459
     dev_uevent+0x712/0x780 drivers/base/core.c:2320
     uevent_show+0x1b8/0x380 drivers/base/core.c:2391
     dev_attr_show+0x4b/0x90 drivers/base/core.c:2094
    
    Although the bug manifested in the driver core, the real cause was a
    race with the gadget core.  dev_uevent() does:
    
            if (dev-&gt;driver)
                    add_uevent_var(env, "DRIVER=%s", dev-&gt;driver-&gt;name);
    
    and between the test and the dereference of dev-&gt;driver, the gadget
    core sets dev-&gt;driver to NULL.
    
    The race wouldn't occur if the gadget core registered its devices on
    a real bus, using the standard synchronization techniques of the
    driver core.  However, it's not necessary to make such a large change
    in order to fix this bug; all we need to do is make sure that
    udc-&gt;dev.driver is always NULL.
    
    In fact, there is no reason for udc-&gt;dev.driver ever to be set to
    anything, let alone to the value it currently gets: the address of the
    gadget's driver.  After all, a gadget driver only knows how to manage
    a gadget, not how to manage a UDC.
    
    This patch simply removes the statements in the gadget core that touch
    udc-&gt;dev.driver.
    
    Fixes: 2ccea03a8f7e ("usb: gadget: introduce UDC Class")
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+348b571beb5eeb70a582@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YiQgukfFFbBnwJ/9@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 568534a0d17c..c109b069f511 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1436,7 +1436,6 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	usb_gadget_udc_stop(udc);
 
 	udc-&gt;driver = NULL;
-	udc-&gt;dev.driver = NULL;
 	udc-&gt;gadget-&gt;dev.driver = NULL;
 }
 
@@ -1498,7 +1497,6 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 			driver-&gt;function);
 
 	udc-&gt;driver = driver;
-	udc-&gt;dev.driver = &amp;driver-&gt;driver;
 	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
@@ -1521,7 +1519,6 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
 			udc-&gt;driver-&gt;function, ret);
 	udc-&gt;driver = NULL;
-	udc-&gt;dev.driver = NULL;
 	udc-&gt;gadget-&gt;dev.driver = NULL;
 	return ret;
 }</pre>
    <div class="pagination">
        <a href='2_4.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><span>[5]</span><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_6.html'>Next&gt;&gt;</a>
    <div>
</body>
