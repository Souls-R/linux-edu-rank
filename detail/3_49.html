<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_48.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><span>[49]</span><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_50.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 53af545b277508d6b4829e90546cbd1beef536a9
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Sep 11 21:46:44 2009 -0400

    Staging: hv: remove more usages of internal list routines
    
    The hv driver has it's own linked list routines.  This removes them
    from more places in hv.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Cc: Haiyang Zhang &lt;haiyangz@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Channel.c b/drivers/staging/hv/Channel.c
index ed94e3656e71..d649ee169d95 100644
--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -247,8 +247,8 @@ int VmbusChannelOpen(struct vmbus_channel *NewChannel, u32 SendRingBufferSize,
 		memcpy(openMsg-&gt;UserData, UserData, UserDataLen);
 
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&amp;gVmbusConnection.ChannelMsgList,
-			 &amp;openInfo-&gt;MsgListEntry);
+	list_add_tail(&amp;openInfo-&gt;MsgListEntry,
+		      &amp;gVmbusConnection.ChannelMsgList);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Sending channel open msg...");
@@ -271,7 +271,7 @@ int VmbusChannelOpen(struct vmbus_channel *NewChannel, u32 SendRingBufferSize,
 
 Cleanup:
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&amp;openInfo-&gt;MsgListEntry);
+	list_del(&amp;openInfo-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(openInfo-&gt;WaitEvent);
@@ -362,7 +362,7 @@ static int VmbusChannelCreateGpadlHeader(void *Kbuffer, u32 Size,
 			  sizeof(struct gpa_range) + pfnCount * sizeof(u64);
 		msgHeader =  kzalloc(msgSize, GFP_KERNEL);
 
-		INITIALIZE_LIST_HEAD(&amp;msgHeader-&gt;SubMsgList);
+		INIT_LIST_HEAD(&amp;msgHeader-&gt;SubMsgList);
 		msgHeader-&gt;MessageSize = msgSize;
 
 		gpaHeader = (struct vmbus_channel_gpadl_header *)msgHeader-&gt;Msg;
@@ -411,8 +411,8 @@ static int VmbusChannelCreateGpadlHeader(void *Kbuffer, u32 Size,
 				gpadlBody-&gt;Pfn[i] = pfn + pfnSum + i;
 
 			/* add to msg header */
-			INSERT_TAIL_LIST(&amp;msgHeader-&gt;SubMsgList,
-					 &amp;msgBody-&gt;MsgListEntry);
+			list_add_tail(&amp;msgBody-&gt;MsgListEntry,
+				      &amp;msgHeader-&gt;SubMsgList);
 			pfnSum += pfnCurr;
 			pfnLeft -= pfnCurr;
 		}
@@ -457,8 +457,7 @@ int VmbusChannelEstablishGpadl(struct vmbus_channel *Channel, void *Kbuffer,
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_msginfo *subMsgInfo;
 	u32 msgCount;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	u32 nextGpadlHandle;
 	unsigned long flags;
 	int ret;
@@ -481,10 +480,10 @@ int VmbusChannelEstablishGpadl(struct vmbus_channel *Channel, void *Kbuffer,
 	DumpGpadlHeader(gpadlMsg);
 
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&amp;gVmbusConnection.ChannelMsgList,
-			 &amp;msgInfo-&gt;MsgListEntry);
-	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
+	list_add_tail(&amp;msgInfo-&gt;MsgListEntry,
+		      &amp;gVmbusConnection.ChannelMsgList);
 
+	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 	DPRINT_DBG(VMBUS, "buffer %p, size %d msg cnt %d",
 		   Kbuffer, Size, msgCount);
 
@@ -499,7 +498,9 @@ int VmbusChannelEstablishGpadl(struct vmbus_channel *Channel, void *Kbuffer,
 	}
 
 	if (msgCount &gt; 1) {
-		ITERATE_LIST_ENTRIES(anchor, curr, &amp;msgInfo-&gt;SubMsgList) {
+		list_for_each(curr, &amp;msgInfo-&gt;SubMsgList) {
+
+			/* FIXME: should this use list_entry() instead ? */
 			subMsgInfo = (struct vmbus_channel_msginfo *)curr;
 			gpadlBody =
 			     (struct vmbus_channel_gpadl_body *)subMsgInfo-&gt;Msg;
@@ -532,7 +533,7 @@ int VmbusChannelEstablishGpadl(struct vmbus_channel *Channel, void *Kbuffer,
 
 Cleanup:
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&amp;msgInfo-&gt;MsgListEntry);
+	list_del(&amp;msgInfo-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(msgInfo-&gt;WaitEvent);
@@ -570,7 +571,8 @@ int VmbusChannelTeardownGpadl(struct vmbus_channel *Channel, u32 GpadlHandle)
 	msg-&gt;Gpadl = GpadlHandle;
 
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&amp;gVmbusConnection.ChannelMsgList, &amp;info-&gt;MsgListEntry);
+	list_add_tail(&amp;info-&gt;MsgListEntry,
+		      &amp;gVmbusConnection.ChannelMsgList);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	ret = VmbusPostMessage(msg,
@@ -584,7 +586,7 @@ int VmbusChannelTeardownGpadl(struct vmbus_channel *Channel, u32 GpadlHandle)
 
 	/* Received a torndown response */
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&amp;info-&gt;MsgListEntry);
+	list_del(&amp;info-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(info-&gt;WaitEvent);
@@ -651,7 +653,7 @@ void VmbusChannelClose(struct vmbus_channel *Channel)
 
 	if (Channel-&gt;State == CHANNEL_OPEN_STATE) {
 		spin_lock_irqsave(&amp;gVmbusConnection.channel_lock, flags);
-		REMOVE_ENTRY_LIST(&amp;Channel-&gt;ListEntry);
+		list_del(&amp;Channel-&gt;ListEntry);
 		spin_unlock_irqrestore(&amp;gVmbusConnection.channel_lock, flags);
 
 		FreeVmbusChannel(Channel);
diff --git a/drivers/staging/hv/ChannelMgmt.c b/drivers/staging/hv/ChannelMgmt.c
index 4a014ea7cf1b..3db62caedcff 100644
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -20,6 +20,7 @@
  */
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
+#include &lt;linux/list.h&gt;
 #include "osd.h"
 #include "logging.h"
 #include "VmbusPrivate.h"
@@ -136,8 +137,6 @@ static void VmbusChannelProcessOffer(void *context)
 {
 	struct vmbus_channel *newChannel = context;
 	struct vmbus_channel *channel;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
 	bool fNew = true;
 	int ret;
 	unsigned long flags;
@@ -147,10 +146,7 @@ static void VmbusChannelProcessOffer(void *context)
 	/* Make sure this is a new offer */
 	spin_lock_irqsave(&amp;gVmbusConnection.channel_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelList) {
-		channel = CONTAINING_RECORD(curr, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry(channel, &amp;gVmbusConnection.ChannelList, ListEntry) {
 		if (!memcmp(&amp;channel-&gt;OfferMsg.Offer.InterfaceType,
 			    &amp;newChannel-&gt;OfferMsg.Offer.InterfaceType,
 			    sizeof(struct hv_guid)) &amp;&amp;
@@ -163,8 +159,8 @@ static void VmbusChannelProcessOffer(void *context)
 	}
 
 	if (fNew)
-		INSERT_TAIL_LIST(&amp;gVmbusConnection.ChannelList,
-				 &amp;newChannel-&gt;ListEntry);
+		list_add_tail(&amp;newChannel-&gt;ListEntry,
+			      &amp;gVmbusConnection.ChannelList);
 
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channel_lock, flags);
 
@@ -201,7 +197,7 @@ static void VmbusChannelProcessOffer(void *context)
 			   newChannel-&gt;OfferMsg.ChildRelId);
 
 		spin_lock_irqsave(&amp;gVmbusConnection.channel_lock, flags);
-		REMOVE_ENTRY_LIST(&amp;newChannel-&gt;ListEntry);
+		list_del(&amp;newChannel-&gt;ListEntry);
 		spin_unlock_irqrestore(&amp;gVmbusConnection.channel_lock, flags);
 
 		FreeVmbusChannel(newChannel);
@@ -360,8 +356,7 @@ static void VmbusChannelOnOffersDelivered(
 static void VmbusChannelOnOpenResult(struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_open_result *result;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_open_channel *openMsg;
@@ -377,7 +372,8 @@ static void VmbusChannelOnOpenResult(struct vmbus_channel_message_header *hdr)
 	 */
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &amp;gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo-&gt;Msg;
 
@@ -408,8 +404,7 @@ static void VmbusChannelOnOpenResult(struct vmbus_channel_message_header *hdr)
 static void VmbusChannelOnGpadlCreated(struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_gpadl_created *gpadlCreated;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_gpadl_header *gpadlHeader;
@@ -427,7 +422,8 @@ static void VmbusChannelOnGpadlCreated(struct vmbus_channel_message_header *hdr)
 	 */
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &amp;gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo-&gt;Msg;
 
@@ -461,8 +457,7 @@ static void VmbusChannelOnGpadlTorndown(
 			struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_gpadl_torndown *gpadlTorndown;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_gpadl_teardown *gpadlTeardown;
@@ -477,7 +472,8 @@ static void VmbusChannelOnGpadlTorndown(
 	 */
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &amp;gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo-&gt;Msg;
 
@@ -508,8 +504,7 @@ static void VmbusChannelOnGpadlTorndown(
 static void VmbusChannelOnVersionResponse(
 		struct vmbus_channel_message_header *hdr)
 {
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_initiate_contact *initiate;
@@ -521,7 +516,8 @@ static void VmbusChannelOnVersionResponse(
 	versionResponse = (struct vmbus_channel_version_response *)hdr;
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &amp;gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo-&gt;Msg;
 
@@ -659,23 +655,19 @@ int VmbusChannelRequestOffers(void)
  */
 void VmbusChannelReleaseUnattachedChannels(void)
 {
-	LIST_ENTRY *entry;
-	struct vmbus_channel *channel;
+	struct vmbus_channel *channel, *pos;
 	struct vmbus_channel *start = NULL;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;gVmbusConnection.channel_lock, flags);
 
-	while (!IsListEmpty(&amp;gVmbusConnection.ChannelList)) {
-		entry = TOP_LIST_ENTRY(&amp;gVmbusConnection.ChannelList);
-		channel = CONTAINING_RECORD(entry, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry_safe(channel, pos, &amp;gVmbusConnection.ChannelList,
+				 ListEntry) {
 		if (channel == start)
 			break;
 
 		if (!channel-&gt;DeviceObject-&gt;Driver) {
-			REMOVE_ENTRY_LIST(&amp;channel-&gt;ListEntry);
+			list_del(&amp;channel-&gt;ListEntry);
 			DPRINT_INFO(VMBUS,
 				    "Releasing unattached device object %p",
 				    channel-&gt;DeviceObject);
diff --git a/drivers/staging/hv/ChannelMgmt.h b/drivers/staging/hv/ChannelMgmt.h
index 0730182fe202..a839d8fe6cec 100644
--- a/drivers/staging/hv/ChannelMgmt.h
+++ b/drivers/staging/hv/ChannelMgmt.h
@@ -25,7 +25,7 @@
 #ifndef _CHANNEL_MGMT_H_
 #define _CHANNEL_MGMT_H_
 
-#include "List.h"
+#include &lt;linux/list.h&gt;
 #include "RingBuffer.h"
 #include "VmbusChannelInterface.h"
 #include "VmbusPacketFormat.h"
@@ -225,7 +225,7 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel {
-	LIST_ENTRY ListEntry;
+	struct list_head ListEntry;
 
 	struct hv_device *DeviceObject;
 
@@ -281,10 +281,10 @@ struct vmbus_channel_debug_info {
  */
 struct vmbus_channel_msginfo {
 	/* Bookkeeping stuff */
-	LIST_ENTRY MsgListEntry;
+	struct list_head MsgListEntry;
 
 	/* So far, this is only used to handle gpadl body message */
-	LIST_ENTRY SubMsgList;
+	struct list_head SubMsgList;
 
 	/* Synchronize the request/response if needed */
 	struct osd_waitevent *WaitEvent;
diff --git a/drivers/staging/hv/Connection.c b/drivers/staging/hv/Connection.c
index e574389615b6..43c2e6855015 100644
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -57,10 +57,10 @@ int VmbusConnect(void)
 		goto Cleanup;
 	}
 
-	INITIALIZE_LIST_HEAD(&amp;gVmbusConnection.ChannelMsgList);
+	INIT_LIST_HEAD(&amp;gVmbusConnection.ChannelMsgList);
 	spin_lock_init(&amp;gVmbusConnection.channelmsg_lock);
 
-	INITIALIZE_LIST_HEAD(&amp;gVmbusConnection.ChannelList);
+	INIT_LIST_HEAD(&amp;gVmbusConnection.ChannelList);
 	spin_lock_init(&amp;gVmbusConnection.channel_lock);
 
 	/*
@@ -112,8 +112,9 @@ int VmbusConnect(void)
 	 * receive the response before returning from this routine
 	 */
 	spin_lock_irqsave(&amp;gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&amp;gVmbusConnection.ChannelMsgList,
-			 &amp;msgInfo-&gt;MsgListEntry);
+	list_add_tail(&amp;msgInfo-&gt;MsgListEntry,
+		      &amp;gVmbusConnection.ChannelMsgList);
+
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Vmbus connection - interrupt pfn %llx, "
@@ -124,14 +125,14 @@ int VmbusConnect(void)
 	ret = VmbusPostMessage(msg,
 			       sizeof(struct vmbus_channel_initiate_contact));
 	if (ret != 0) {
-		REMOVE_ENTRY_LIST(&amp;msgInfo-&gt;MsgListEntry);
+		list_del(&amp;msgInfo-&gt;MsgListEntry);
 		goto Cleanup;
 	}
 
 	/* Wait for the connection response */
 	osd_WaitEventWait(msgInfo-&gt;WaitEvent);
 
-	REMOVE_ENTRY_LIST(&amp;msgInfo-&gt;MsgListEntry);
+	list_del(&amp;msgInfo-&gt;MsgListEntry);
 
 	/* Check if successful */
 	if (msgInfo-&gt;Response.VersionResponse.VersionSupported) {
@@ -223,15 +224,10 @@ struct vmbus_channel *GetChannelFromRelId(u32 relId)
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *foundChannel  = NULL;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;gVmbusConnection.channel_lock, flags);
-	ITERATE_LIST_ENTRIES(anchor, curr, &amp;gVmbusConnection.ChannelList) {
-		channel = CONTAINING_RECORD(curr, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry(channel, &amp;gVmbusConnection.ChannelList, ListEntry) {
 		if (channel-&gt;OfferMsg.ChildRelId == relId) {
 			foundChannel = channel;
 			break;
diff --git a/drivers/staging/hv/VmbusPrivate.h b/drivers/staging/hv/VmbusPrivate.h
index 4aabb974348e..05ad2c9380d5 100644
--- a/drivers/staging/hv/VmbusPrivate.h
+++ b/drivers/staging/hv/VmbusPrivate.h
@@ -31,7 +31,7 @@
 #include "ChannelMgmt.h"
 #include "ChannelInterface.h"
 #include "RingBuffer.h"
-#include "List.h"
+#include &lt;linux/list.h&gt;
 
 
 /*
@@ -76,11 +76,11 @@ struct VMBUS_CONNECTION {
 	 * is child-&gt;parent notification
 	 */
 	void *MonitorPages;
-	LIST_ENTRY ChannelMsgList;
+	struct list_head ChannelMsgList;
 	spinlock_t channelmsg_lock;
 
 	/* List of channels */
-	LIST_ENTRY ChannelList;
+	struct list_head ChannelList;
 	spinlock_t channel_lock;
 
 	struct workqueue_struct *WorkQueue;
@@ -89,7 +89,7 @@ struct VMBUS_CONNECTION {
 
 struct VMBUS_MSGINFO {
 	/* Bookkeeping stuff */
-	LIST_ENTRY MsgListEntry;
+	struct list_head MsgListEntry;
 
 	/* Synchronize the request/response if needed */
 	struct osd_waitevent *WaitEvent;</pre><hr><pre>commit d29274efb73735c6a94f20214b1e4ea994da8848
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Sep 11 21:46:43 2009 -0400

    Staging: hv: remove use of internal list routines in NetVsc
    
    The hv driver has it's own linked list routines.  This removes them
    from NetVsc and uses the kernels routines instead.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Cc: Haiyang Zhang &lt;haiyangz@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/NetVsc.c b/drivers/staging/hv/NetVsc.c
index 92f956578962..1610b845198f 100644
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -711,8 +711,7 @@ static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
 	int ret = 0;
 	int i;
 	struct netvsc_device *netDevice;
-	struct hv_netvsc_packet *packet;
-	LIST_ENTRY *entry;
+	struct hv_netvsc_packet *packet, *pos;
 	struct netvsc_driver *netDriver =
 				(struct netvsc_driver *)Device-&gt;Driver;
 
@@ -732,7 +731,7 @@ static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
 
 	netDevice-&gt;SendBufferSize = NETVSC_SEND_BUFFER_SIZE;
 
-	INITIALIZE_LIST_HEAD(&amp;netDevice-&gt;ReceivePacketList);
+	INIT_LIST_HEAD(&amp;netDevice-&gt;ReceivePacketList);
 
 	for (i = 0; i &lt; NETVSC_RECEIVE_PACKETLIST_COUNT; i++) {
 		packet = kzalloc(sizeof(struct hv_netvsc_packet) +
@@ -744,9 +743,8 @@ static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
 				   NETVSC_RECEIVE_PACKETLIST_COUNT, i);
 			break;
 		}
-
-		INSERT_TAIL_LIST(&amp;netDevice-&gt;ReceivePacketList,
-				 &amp;packet-&gt;ListEntry);
+		list_add_tail(&amp;packet-&gt;ListEntry,
+			      &amp;netDevice-&gt;ReceivePacketList);
 	}
 	netDevice-&gt;ChannelInitEvent = osd_WaitEventCreate();
 
@@ -790,11 +788,10 @@ static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
 	if (netDevice) {
 		kfree(netDevice-&gt;ChannelInitEvent);
 
-		while (!IsListEmpty(&amp;netDevice-&gt;ReceivePacketList)) {
-			entry = REMOVE_HEAD_LIST(&amp;netDevice-&gt;ReceivePacketList);
-			packet = CONTAINING_RECORD(entry,
-						   struct hv_netvsc_packet,
-						   ListEntry);
+		list_for_each_entry_safe(packet, pos,
+					 &amp;netDevice-&gt;ReceivePacketList,
+					 ListEntry) {
+			list_del(&amp;packet-&gt;ListEntry);
 			kfree(packet);
 		}
 
@@ -814,8 +811,7 @@ static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
 static int NetVscOnDeviceRemove(struct hv_device *Device)
 {
 	struct netvsc_device *netDevice;
-	struct hv_netvsc_packet *netvscPacket;
-	LIST_ENTRY *entry;
+	struct hv_netvsc_packet *netvscPacket, *pos;
 
 	DPRINT_ENTER(NETVSC);
 
@@ -853,12 +849,9 @@ static int NetVscOnDeviceRemove(struct hv_device *Device)
 	Device-&gt;Driver-&gt;VmbusChannelInterface.Close(Device);
 
 	/* Release all resources */
-	while (!IsListEmpty(&amp;netDevice-&gt;ReceivePacketList)) {
-		entry = REMOVE_HEAD_LIST(&amp;netDevice-&gt;ReceivePacketList);
-		netvscPacket = CONTAINING_RECORD(entry,
-						 struct hv_netvsc_packet,
-						 ListEntry);
-
+	list_for_each_entry_safe(netvscPacket, pos,
+				 &amp;netDevice-&gt;ReceivePacketList, ListEntry) {
+		list_del(&amp;netvscPacket-&gt;ListEntry);
 		kfree(netvscPacket);
 	}
 
@@ -994,15 +987,14 @@ static void NetVscOnReceive(struct hv_device *Device,
 	struct vmtransfer_page_packet_header *vmxferpagePacket;
 	struct nvsp_message *nvspPacket;
 	struct hv_netvsc_packet *netvscPacket = NULL;
-	LIST_ENTRY *entry;
 	unsigned long start;
 	unsigned long end, endVirtual;
 	/* struct netvsc_driver *netvscDriver; */
 	struct xferpage_packet *xferpagePacket = NULL;
-	LIST_ENTRY listHead;
 	int i, j;
 	int count = 0, bytesRemain = 0;
 	unsigned long flags;
+	LIST_HEAD(listHead);
 
 	DPRINT_ENTER(NETVSC);
 
@@ -1052,8 +1044,6 @@ static void NetVscOnReceive(struct hv_device *Device,
 	DPRINT_DBG(NETVSC, "xfer page - range count %d",
 		   vmxferpagePacket-&gt;RangeCount);
 
-	INITIALIZE_LIST_HEAD(&amp;listHead);
-
 	/*
 	 * Grab free packets (range count + 1) to represent this xfer
 	 * page packet. +1 to represent the xfer page packet itself.
@@ -1061,14 +1051,8 @@ static void NetVscOnReceive(struct hv_device *Device,
 	 * fulfil
 	 */
 	spin_lock_irqsave(&amp;netDevice-&gt;receive_packet_list_lock, flags);
-	while (!IsListEmpty(&amp;netDevice-&gt;ReceivePacketList)) {
-		entry = REMOVE_HEAD_LIST(&amp;netDevice-&gt;ReceivePacketList);
-		netvscPacket = CONTAINING_RECORD(entry,
-						 struct hv_netvsc_packet,
-						 ListEntry);
-
-		INSERT_TAIL_LIST(&amp;listHead, &amp;netvscPacket-&gt;ListEntry);
-
+	while (!list_empty(&amp;netDevice-&gt;ReceivePacketList)) {
+		list_move_tail(&amp;netDevice-&gt;ReceivePacketList, &amp;listHead);
 		if (++count == vmxferpagePacket-&gt;RangeCount + 1)
 			break;
 	}
@@ -1087,13 +1071,8 @@ static void NetVscOnReceive(struct hv_device *Device,
 		/* Return it to the freelist */
 		spin_lock_irqsave(&amp;netDevice-&gt;receive_packet_list_lock, flags);
 		for (i = count; i != 0; i--) {
-			entry = REMOVE_HEAD_LIST(&amp;listHead);
-			netvscPacket = CONTAINING_RECORD(entry,
-						struct hv_netvsc_packet,
-						ListEntry);
-
-			INSERT_TAIL_LIST(&amp;netDevice-&gt;ReceivePacketList,
-					 &amp;netvscPacket-&gt;ListEntry);
+			list_move_tail(&amp;listHead,
+				       &amp;netDevice-&gt;ReceivePacketList);
 		}
 		spin_unlock_irqrestore(&amp;netDevice-&gt;receive_packet_list_lock,
 				       flags);
@@ -1106,9 +1085,10 @@ static void NetVscOnReceive(struct hv_device *Device,
 	}
 
 	/* Remove the 1st packet to represent the xfer page packet itself */
-	entry = REMOVE_HEAD_LIST(&amp;listHead);
-	xferpagePacket = CONTAINING_RECORD(entry, struct xferpage_packet,
-					   ListEntry);
+	xferpagePacket = list_entry(&amp;listHead, struct xferpage_packet,
+				    ListEntry);
+	list_del(&amp;xferpagePacket-&gt;ListEntry);
+
 	/* This is how much we can satisfy */
 	xferpagePacket-&gt;Count = count - 1;
 	ASSERT(xferpagePacket-&gt;Count &gt; 0 &amp;&amp; xferpagePacket-&gt;Count &lt;=
@@ -1122,10 +1102,9 @@ static void NetVscOnReceive(struct hv_device *Device,
 
 	/* Each range represents 1 RNDIS pkt that contains 1 ethernet frame */
 	for (i = 0; i &lt; (count - 1); i++) {
-		entry = REMOVE_HEAD_LIST(&amp;listHead);
-		netvscPacket = CONTAINING_RECORD(entry,
-						 struct hv_netvsc_packet,
-						 ListEntry);
+		netvscPacket = list_entry(&amp;listHead, struct hv_netvsc_packet,
+					  ListEntry);
+		list_del(&amp;netvscPacket-&gt;ListEntry);
 
 		/* Initialize the netvsc packet */
 		netvscPacket-&gt;XferPagePacket = xferpagePacket;
@@ -1198,7 +1177,7 @@ static void NetVscOnReceive(struct hv_device *Device,
 		NetVscOnReceiveCompletion(netvscPacket-&gt;Completion.Recv.ReceiveCompletionContext);
 	}
 
-	ASSERT(IsListEmpty(&amp;listHead));
+	ASSERT(list_empty(&amp;listHead));
 
 	PutNetDevice(Device);
 	DPRINT_EXIT(NETVSC);
@@ -1290,13 +1269,13 @@ static void NetVscOnReceiveCompletion(void *Context)
 	if (packet-&gt;XferPagePacket-&gt;Count == 0) {
 		fSendReceiveComp = true;
 		transactionId = packet-&gt;Completion.Recv.ReceiveCompletionTid;
+		list_add_tail(&amp;packet-&gt;XferPagePacket-&gt;ListEntry,
+			      &amp;netDevice-&gt;ReceivePacketList);
 
-		INSERT_TAIL_LIST(&amp;netDevice-&gt;ReceivePacketList,
-				 &amp;packet-&gt;XferPagePacket-&gt;ListEntry);
 	}
 
 	/* Put the packet back */
-	INSERT_TAIL_LIST(&amp;netDevice-&gt;ReceivePacketList, &amp;packet-&gt;ListEntry);
+	list_add_tail(&amp;packet-&gt;ListEntry, &amp;netDevice-&gt;ReceivePacketList);
 	spin_unlock_irqrestore(&amp;netDevice-&gt;receive_packet_list_lock, flags);
 
 	/* Send a receive completion for the xfer page packet */
diff --git a/drivers/staging/hv/NetVsc.h b/drivers/staging/hv/NetVsc.h
index 89ba02b1d607..3e7112f7c755 100644
--- a/drivers/staging/hv/NetVsc.h
+++ b/drivers/staging/hv/NetVsc.h
@@ -24,9 +24,9 @@
 #ifndef _NETVSC_H_
 #define _NETVSC_H_
 
+#include &lt;linux/list.h&gt;
 #include "VmbusPacketFormat.h"
 #include "VmbusChannelInterface.h"
-#include "List.h"
 #include "NetVscApi.h"
 
 
@@ -299,7 +299,7 @@ struct netvsc_device {
 	 * List of free preallocated hv_netvsc_packet to represent receive
 	 * packet
 	 */
-	LIST_ENTRY ReceivePacketList;
+	struct list_head ReceivePacketList;
 	spinlock_t receive_packet_list_lock;
 
 	/* Send buffer allocated by us but manages by NetVSP */
diff --git a/drivers/staging/hv/NetVscApi.h b/drivers/staging/hv/NetVscApi.h
index 1cf12871dbc9..34e8fd79205c 100644
--- a/drivers/staging/hv/NetVscApi.h
+++ b/drivers/staging/hv/NetVscApi.h
@@ -37,7 +37,7 @@ struct hv_netvsc_packet;
 
 /* Represent the xfer page packet which contains 1 or more netvsc packet */
 struct xferpage_packet {
-	LIST_ENTRY ListEntry;
+	struct list_head ListEntry;
 
 	/* # of netvsc packets this xfer packet contains */
 	u32 Count;
@@ -52,7 +52,7 @@ struct xferpage_packet {
  */
 struct hv_netvsc_packet {
 	/* Bookkeeping stuff */
-	LIST_ENTRY ListEntry;
+	struct list_head ListEntry;
 
 	struct hv_device *Device;
 	bool IsDataPacket;</pre><hr><pre>commit 45da89e559219d24a639f24a8d95a6c71d54736f
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:15 2009 -0400

    Staging: hv: remove wrapper functions around kmap_
    
    Remove PageMapVirtualAddress() and PageUnmapVirtualAddress() which
    were wrappers around kmap_atomic() and kunmap_atomic()
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/RndisFilter.c b/drivers/staging/hv/RndisFilter.c
index 98d82f92c029..362efb0704b2 100644
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -22,7 +22,9 @@
  */
 
 #include &lt;linux/kernel.h&gt;
-#include &lt;linux/mm.h&gt;
+#include &lt;linux/highmem.h&gt;
+#include &lt;asm/kmap_types.h&gt;
+
 #include "include/logging.h"
 
 #include "include/NetVscApi.h"
@@ -518,7 +520,7 @@ RndisFilterOnReceive(
 		return -1;
 	}
 
-	rndisHeader = (RNDIS_MESSAGE*)PageMapVirtualAddress(Packet-&gt;PageBuffers[0].Pfn);
+	rndisHeader = (RNDIS_MESSAGE *)kmap_atomic(pfn_to_page(Packet-&gt;PageBuffers[0].Pfn), KM_IRQ0);
 
 	rndisHeader = (void*)((unsigned long)rndisHeader + Packet-&gt;PageBuffers[0].Offset);
 
@@ -528,7 +530,7 @@ RndisFilterOnReceive(
 #if 0
 	if ( Packet-&gt;TotalDataBufferLength != rndisHeader-&gt;MessageLength )
 	{
-		PageUnmapVirtualAddress((void*)(unsigned long)rndisHeader - Packet-&gt;PageBuffers[0].Offset);
+		kunmap_atomic(rndisHeader - Packet-&gt;PageBuffers[0].Offset, KM_IRQ0);
 
 		DPRINT_ERR(NETVSC, "invalid rndis message? (expected %u bytes got %u)...dropping this message!",
 			rndisHeader-&gt;MessageLength, Packet-&gt;TotalDataBufferLength);
@@ -545,7 +547,7 @@ RndisFilterOnReceive(
 
 	memcpy(&amp;rndisMessage, rndisHeader, (rndisHeader-&gt;MessageLength &gt; sizeof(RNDIS_MESSAGE))?sizeof(RNDIS_MESSAGE):rndisHeader-&gt;MessageLength);
 
-	PageUnmapVirtualAddress((void*)(unsigned long)rndisHeader - Packet-&gt;PageBuffers[0].Offset);
+	kunmap_atomic(rndisHeader - Packet-&gt;PageBuffers[0].Offset, KM_IRQ0);
 
 	DumpRndisMessage(&amp;rndisMessage);
 
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index f8b5411426da..6eeb87ebdac0 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -138,10 +138,6 @@ unsigned long Logical2PhysicalAddr(void * LogicalAddr);
 
 unsigned long Virtual2Physical(void * VirtAddr);
 
-void* PageMapVirtualAddress(unsigned long Pfn);
-void PageUnmapVirtualAddress(void* VirtAddr);
-
-
 int osd_schedule_callback(struct workqueue_struct *wq,
 			  void (*func)(void *),
 			  void *data);
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index f19b9c9ea1e6..ad883c93ec9c 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -88,17 +88,6 @@ void PageFree(void* page, unsigned int count)
 	__free_page(p);*/
 }
 
-
-void* PageMapVirtualAddress(unsigned long Pfn)
-{
-	return kmap_atomic(pfn_to_page(Pfn), KM_IRQ0);
-}
-
-void PageUnmapVirtualAddress(void* VirtAddr)
-{
-	kunmap_atomic(VirtAddr, KM_IRQ0);
-}
-
 void *MemMapIO(unsigned long phys, unsigned long size)
 {
 	return (void*)GetVirtualAddress(phys); /* return ioremap_nocache(phys, size); */</pre><hr><pre>commit b7c947f04888b8bb2dc79832c10ede73c5b8dae2
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:13 2009 -0400

    Staging: hv: remove wrapper function VirtualFree
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Hv.c b/drivers/staging/hv/Hv.c
index 36e0d860f14d..334812fdc84b 100644
--- a/drivers/staging/hv/Hv.c
+++ b/drivers/staging/hv/Hv.c
@@ -21,7 +21,7 @@
  *
  */
 
-
+#include &lt;linux/vmalloc.h&gt;
 #include "include/logging.h"
 #include "VmbusPrivate.h"
 
@@ -330,7 +330,7 @@ HvInit (
 			WriteMsr(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
 		}
 
-		VirtualFree(virtAddr);
+		vfree(virtAddr);
 	}
 	ret = -1;
 	DPRINT_EXIT(VMBUS);
@@ -370,7 +370,7 @@ HvCleanup (
 		{
 			hypercallMsr.AsUINT64 = 0;
 			WriteMsr(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
-			VirtualFree(gHvContext.HypercallPage);
+			vfree(gHvContext.HypercallPage);
 			gHvContext.HypercallPage = NULL;
 		}
 	}
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index bf010fcec6f8..f8b5411426da 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -110,7 +110,6 @@ static inline void do_cpuid(unsigned int op, unsigned int *eax, unsigned int *eb
 /* Osd routines */
 
 extern void* VirtualAllocExec(unsigned int size);
-extern void VirtualFree(void* VirtAddr);
 
 extern void* PageAlloc(unsigned int count);
 extern void PageFree(void* page, unsigned int count);
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index 1d338721194e..f19b9c9ea1e6 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -65,11 +65,6 @@ void* VirtualAllocExec(unsigned int size)
 #endif
 }
 
-void VirtualFree(void* VirtAddr)
-{
-	return vfree(VirtAddr);
-}
-
 void* PageAlloc(unsigned int count)
 {
 	void *p;</pre><hr><pre>commit f4888417083723c4f5cbfdf4895653279ffdc31e
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:12 2009 -0400

    Staging: hv: remove wrapper functions for atomic operations
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Channel.c b/drivers/staging/hv/Channel.c
index 4b5e3e40aa3a..61fc345211e9 100644
--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -540,8 +540,8 @@ VmbusChannelEstablishGpadl(
 
 	DPRINT_ENTER(VMBUS);
 
-	nextGpadlHandle = gVmbusConnection.NextGpadlHandle;
-	InterlockedIncrement((int*)&amp;gVmbusConnection.NextGpadlHandle);
+	nextGpadlHandle = atomic_read(&amp;gVmbusConnection.NextGpadlHandle);
+	atomic_inc(&amp;gVmbusConnection.NextGpadlHandle);
 
 	VmbusChannelCreateGpadlHeader(Kbuffer, Size, &amp;msgInfo, &amp;msgCount);
 	ASSERT(msgInfo != NULL);
diff --git a/drivers/staging/hv/Connection.c b/drivers/staging/hv/Connection.c
index b7df7e7a38e6..d7091ad130f3 100644
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -31,7 +31,7 @@
 
 struct VMBUS_CONNECTION gVmbusConnection = {
 	.ConnectState		= Disconnected,
-	.NextGpadlHandle	= 0xE1E10,
+	.NextGpadlHandle	= ATOMIC_INIT(0xE1E10),
 };
 
 
diff --git a/drivers/staging/hv/NetVsc.c b/drivers/staging/hv/NetVsc.c
index dea54098e510..8e71ce6406e9 100644
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -122,7 +122,7 @@ static inline struct NETVSC_DEVICE *AllocNetDevice(struct hv_device *Device)
 		return NULL;
 
 	/* Set to 2 to allow both inbound and outbound traffic */
-	InterlockedCompareExchange(&amp;netDevice-&gt;RefCount, 2, 0);
+	atomic_cmpxchg(&amp;netDevice-&gt;RefCount, 0, 2);
 
 	netDevice-&gt;Device = Device;
 	Device-&gt;Extension = netDevice;
@@ -132,7 +132,7 @@ static inline struct NETVSC_DEVICE *AllocNetDevice(struct hv_device *Device)
 
 static inline void FreeNetDevice(struct NETVSC_DEVICE *Device)
 {
-	ASSERT(Device-&gt;RefCount == 0);
+	ASSERT(atomic_read(&amp;Device-&gt;RefCount) == 0);
 	Device-&gt;Device-&gt;Extension = NULL;
 	kfree(Device);
 }
@@ -144,14 +144,10 @@ static inline struct NETVSC_DEVICE *GetOutboundNetDevice(struct hv_device *Devic
 	struct NETVSC_DEVICE *netDevice;
 
 	netDevice = (struct NETVSC_DEVICE*)Device-&gt;Extension;
-	if (netDevice &amp;&amp; netDevice-&gt;RefCount &gt; 1)
-	{
-		InterlockedIncrement(&amp;netDevice-&gt;RefCount);
-	}
+	if (netDevice &amp;&amp; atomic_read(&amp;netDevice-&gt;RefCount) &gt; 1)
+		atomic_inc(&amp;netDevice-&gt;RefCount);
 	else
-	{
 		netDevice = NULL;
-	}
 
 	return netDevice;
 }
@@ -162,14 +158,10 @@ static inline struct NETVSC_DEVICE *GetInboundNetDevice(struct hv_device *Device
 	struct NETVSC_DEVICE *netDevice;
 
 	netDevice = (struct NETVSC_DEVICE*)Device-&gt;Extension;
-	if (netDevice &amp;&amp; netDevice-&gt;RefCount)
-	{
-		InterlockedIncrement(&amp;netDevice-&gt;RefCount);
-	}
+	if (netDevice &amp;&amp; atomic_read(&amp;netDevice-&gt;RefCount))
+		atomic_inc(&amp;netDevice-&gt;RefCount);
 	else
-	{
 		netDevice = NULL;
-	}
 
 	return netDevice;
 }
@@ -181,7 +173,7 @@ static inline void PutNetDevice(struct hv_device *Device)
 	netDevice = (struct NETVSC_DEVICE*)Device-&gt;Extension;
 	ASSERT(netDevice);
 
-	InterlockedDecrement(&amp;netDevice-&gt;RefCount);
+	atomic_dec(&amp;netDevice-&gt;RefCount);
 }
 
 static inline struct NETVSC_DEVICE *ReleaseOutboundNetDevice(struct hv_device *Device)
@@ -193,7 +185,7 @@ static inline struct NETVSC_DEVICE *ReleaseOutboundNetDevice(struct hv_device *D
 		return NULL;
 
 	/* Busy wait until the ref drop to 2, then set it to 1 */
-	while (InterlockedCompareExchange(&amp;netDevice-&gt;RefCount, 1, 2) != 2)
+	while (atomic_cmpxchg(&amp;netDevice-&gt;RefCount, 2, 1) != 2)
 	{
 		udelay(100);
 	}
@@ -210,7 +202,7 @@ static inline struct NETVSC_DEVICE *ReleaseInboundNetDevice(struct hv_device *De
 		return NULL;
 
 	/* Busy wait until the ref drop to 1, then set it to 0 */
-	while (InterlockedCompareExchange(&amp;netDevice-&gt;RefCount, 0, 1) != 1)
+	while (atomic_cmpxchg(&amp;netDevice-&gt;RefCount, 1, 0) != 1)
 	{
 		udelay(100);
 	}
@@ -932,9 +924,9 @@ NetVscOnDeviceRemove(
 	}
 
 	/* Wait for all send completions */
-	while (netDevice-&gt;NumOutstandingSends)
+	while (atomic_read(&amp;netDevice-&gt;NumOutstandingSends))
 	{
-		DPRINT_INFO(NETVSC, "waiting for %d requests to complete...", netDevice-&gt;NumOutstandingSends);
+		DPRINT_INFO(NETVSC, "waiting for %d requests to complete...", atomic_read(&amp;netDevice-&gt;NumOutstandingSends));
 
 		udelay(100);
 	}
@@ -1032,7 +1024,7 @@ NetVscOnSendCompletion(
 		/* Notify the layer above us */
 		nvscPacket-&gt;Completion.Send.OnSendCompletion(nvscPacket-&gt;Completion.Send.SendCompletionContext);
 
-		InterlockedDecrement(&amp;netDevice-&gt;NumOutstandingSends);
+		atomic_dec(&amp;netDevice-&gt;NumOutstandingSends);
 	}
 	else
 	{
@@ -1101,7 +1093,7 @@ NetVscOnSend(
 		DPRINT_ERR(NETVSC, "Unable to send packet %p ret %d", Packet, ret);
 	}
 
-	InterlockedIncrement(&amp;netDevice-&gt;NumOutstandingSends);
+	atomic_inc(&amp;netDevice-&gt;NumOutstandingSends);
 	PutNetDevice(Device);
 
 	DPRINT_EXIT(NETVSC);
diff --git a/drivers/staging/hv/NetVsc.h b/drivers/staging/hv/NetVsc.h
index 0389318f2a2c..770a7b46c2c9 100644
--- a/drivers/staging/hv/NetVsc.h
+++ b/drivers/staging/hv/NetVsc.h
@@ -57,9 +57,8 @@
 struct NETVSC_DEVICE {
 	struct hv_device *Device;
 
-	int								RefCount;
-
-	int								NumOutstandingSends;
+	atomic_t RefCount;
+	atomic_t NumOutstandingSends;
 	/* List of free preallocated hv_netvsc_packet to represent receive packet */
 	LIST_ENTRY						ReceivePacketList;
 	spinlock_t receive_packet_list_lock;
diff --git a/drivers/staging/hv/RndisFilter.c b/drivers/staging/hv/RndisFilter.c
index 5b992dfdb0f6..98d82f92c029 100644
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -50,7 +50,7 @@ typedef struct _RNDIS_DEVICE {
 
 	RNDIS_DEVICE_STATE		State;
 	u32					LinkStatus;
-	u32					NewRequestId;
+	atomic_t NewRequestId;
 
 	spinlock_t request_lock;
 	LIST_ENTRY				RequestList;
@@ -255,7 +255,7 @@ static inline RNDIS_REQUEST* GetRndisRequest(RNDIS_DEVICE *Device, u32 MessageTy
 	/* Set the request id. This field is always after the rndis header for request/response packet types so */
 	/* we just used the SetRequest as a template */
 	set = &amp;rndisMessage-&gt;Message.SetRequest;
-	set-&gt;RequestId = InterlockedIncrement((int*)&amp;Device-&gt;NewRequestId);
+	set-&gt;RequestId = atomic_inc_return(&amp;Device-&gt;NewRequestId);
 
 	/* Add to the request list */
 	spin_lock_irqsave(&amp;Device-&gt;request_lock, flags);
@@ -863,7 +863,7 @@ RndisFilterHaltDevice(
 
 	/* Setup the rndis set */
 	halt = &amp;request-&gt;RequestMessage.Message.HaltRequest;
-	halt-&gt;RequestId = InterlockedIncrement((int*)&amp;Device-&gt;NewRequestId);
+	halt-&gt;RequestId = atomic_inc_return(&amp;Device-&gt;NewRequestId);
 
 	/* Ignore return since this msg is optional. */
 	RndisFilterSendRequest(Device, request);
diff --git a/drivers/staging/hv/StorVsc.c b/drivers/staging/hv/StorVsc.c
index ef8031fd3850..09e3eda78e36 100644
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -57,9 +57,9 @@ typedef struct _STORVSC_REQUEST_EXTENSION {
 typedef struct _STORVSC_DEVICE{
 	struct hv_device *Device;
 
-	int							RefCount; /* 0 indicates the device is being destroyed */
+	atomic_t RefCount; /* 0 indicates the device is being destroyed */
 
-	int							NumOutstandingRequests;
+	atomic_t NumOutstandingRequests;
 
 	/*
 	 * Each unique Port/Path/Target represents 1 channel ie scsi
@@ -155,7 +155,7 @@ static inline STORVSC_DEVICE* AllocStorDevice(struct hv_device *Device)
 
 	/* Set to 2 to allow both inbound and outbound traffics */
 	/* (ie GetStorDevice() and MustGetStorDevice()) to proceed. */
-	InterlockedCompareExchange(&amp;storDevice-&gt;RefCount, 2, 0);
+	atomic_cmpxchg(&amp;storDevice-&gt;RefCount, 0, 2);
 
 	storDevice-&gt;Device = Device;
 	Device-&gt;Extension = storDevice;
@@ -165,7 +165,7 @@ static inline STORVSC_DEVICE* AllocStorDevice(struct hv_device *Device)
 
 static inline void FreeStorDevice(STORVSC_DEVICE *Device)
 {
-	ASSERT(Device-&gt;RefCount == 0);
+	ASSERT( atomic_read(&amp;Device-&gt;RefCount) == 0);
 	kfree(Device);
 }
 
@@ -175,14 +175,10 @@ static inline STORVSC_DEVICE* GetStorDevice(struct hv_device *Device)
 	STORVSC_DEVICE *storDevice;
 
 	storDevice = (STORVSC_DEVICE*)Device-&gt;Extension;
-	if (storDevice &amp;&amp; storDevice-&gt;RefCount &gt; 1)
-	{
-		InterlockedIncrement(&amp;storDevice-&gt;RefCount);
-	}
+	if (storDevice &amp;&amp; atomic_read(&amp;storDevice-&gt;RefCount) &gt; 1)
+		atomic_inc(&amp;storDevice-&gt;RefCount);
 	else
-	{
 		storDevice = NULL;
-	}
 
 	return storDevice;
 }
@@ -193,14 +189,10 @@ static inline STORVSC_DEVICE* MustGetStorDevice(struct hv_device *Device)
 	STORVSC_DEVICE *storDevice;
 
 	storDevice = (STORVSC_DEVICE*)Device-&gt;Extension;
-	if (storDevice &amp;&amp; storDevice-&gt;RefCount)
-	{
-		InterlockedIncrement(&amp;storDevice-&gt;RefCount);
-	}
+	if (storDevice &amp;&amp; atomic_read(&amp;storDevice-&gt;RefCount))
+		atomic_inc(&amp;storDevice-&gt;RefCount);
 	else
-	{
 		storDevice = NULL;
-	}
 
 	return storDevice;
 }
@@ -212,8 +204,8 @@ static inline void PutStorDevice(struct hv_device *Device)
 	storDevice = (STORVSC_DEVICE*)Device-&gt;Extension;
 	ASSERT(storDevice);
 
-	InterlockedDecrement(&amp;storDevice-&gt;RefCount);
-	ASSERT(storDevice-&gt;RefCount);
+	atomic_dec(&amp;storDevice-&gt;RefCount);
+	ASSERT(atomic_read(&amp;storDevice-&gt;RefCount));
 }
 
 /* Drop ref count to 1 to effectively disable GetStorDevice() */
@@ -225,7 +217,7 @@ static inline STORVSC_DEVICE* ReleaseStorDevice(struct hv_device *Device)
 	ASSERT(storDevice);
 
 	/* Busy wait until the ref drop to 2, then set it to 1 */
-	while (InterlockedCompareExchange(&amp;storDevice-&gt;RefCount, 1, 2) != 2)
+	while (atomic_cmpxchg(&amp;storDevice-&gt;RefCount, 2, 1) != 2)
 	{
 		udelay(100);
 	}
@@ -242,7 +234,7 @@ static inline STORVSC_DEVICE* FinalReleaseStorDevice(struct hv_device *Device)
 	ASSERT(storDevice);
 
 	/* Busy wait until the ref drop to 1, then set it to 0 */
-	while (InterlockedCompareExchange(&amp;storDevice-&gt;RefCount, 0, 1) != 1)
+	while (atomic_cmpxchg(&amp;storDevice-&gt;RefCount, 1, 0) != 1)
 	{
 		udelay(100);
 	}
@@ -591,9 +583,9 @@ StorVscOnDeviceRemove(
 	 * only allow inbound traffic (responses) to proceed so that
 	 * outstanding requests can be completed.
 	 */
-	while (storDevice-&gt;NumOutstandingRequests)
+	while (atomic_read(&amp;storDevice-&gt;NumOutstandingRequests))
 	{
-		DPRINT_INFO(STORVSC, "waiting for %d requests to complete...", storDevice-&gt;NumOutstandingRequests);
+		DPRINT_INFO(STORVSC, "waiting for %d requests to complete...", atomic_read(&amp;storDevice-&gt;NumOutstandingRequests));
 
 		udelay(100);
 	}
@@ -788,7 +780,7 @@ StorVscOnIORequest(
 		DPRINT_DBG(STORVSC, "Unable to send packet %p ret %d", vstorPacket, ret);
 	}
 
-	InterlockedIncrement(&amp;storDevice-&gt;NumOutstandingRequests);
+	atomic_inc(&amp;storDevice-&gt;NumOutstandingRequests);
 
 	PutStorDevice(Device);
 
@@ -877,7 +869,7 @@ StorVscOnIOCompletion(
 
 	request-&gt;OnIOCompletion(request);
 
-	InterlockedDecrement(&amp;storDevice-&gt;NumOutstandingRequests);
+	atomic_dec(&amp;storDevice-&gt;NumOutstandingRequests);
 
 	PutStorDevice(Device);
 
diff --git a/drivers/staging/hv/VmbusPrivate.h b/drivers/staging/hv/VmbusPrivate.h
index bf47408258e0..906736bfd9eb 100644
--- a/drivers/staging/hv/VmbusPrivate.h
+++ b/drivers/staging/hv/VmbusPrivate.h
@@ -67,7 +67,7 @@ struct VMBUS_CONNECTION {
 
 	enum VMBUS_CONNECT_STATE					ConnectState;
 
-	u32								NextGpadlHandle;
+	atomic_t NextGpadlHandle;
 
 	/*
 	 * Represents channel interrupts. Each bit position represents
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index ee44e7e9547d..bf010fcec6f8 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -109,10 +109,6 @@ static inline void do_cpuid(unsigned int op, unsigned int *eax, unsigned int *eb
 
 /* Osd routines */
 
-extern int InterlockedIncrement(int *val);
-extern int InterlockedDecrement(int *val);
-extern int InterlockedCompareExchange(int *val, int new, int curr);
-
 extern void* VirtualAllocExec(unsigned int size);
 extern void VirtualFree(void* VirtAddr);
 
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index ff01a7b9c120..1d338721194e 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -56,26 +56,6 @@ struct osd_callback_struct {
 	void *data;
 };
 
-int InterlockedIncrement(int *val)
-{
-	return atomic_inc_return((atomic_t*)val);
-}
-
-int InterlockedDecrement(int *val)
-{
-	return atomic_dec_return((atomic_t*)val);
-}
-
-#ifndef atomic_cmpxchg
-#define atomic_cmpxchg(v, old, new) ((int)cmpxchg(&amp;((v)-&gt;counter), old, new))
-#endif
-int InterlockedCompareExchange(int *val, int new, int curr)
-{
-	/* return ((int)cmpxchg(((atomic_t*)val), curr, new)); */
-	return atomic_cmpxchg((atomic_t*)val, curr, new);
-
-}
-
 void* VirtualAllocExec(unsigned int size)
 {
 #ifdef __x86_64__
diff --git a/drivers/staging/hv/vmbus_drv.c b/drivers/staging/hv/vmbus_drv.c
index 375dde94eb16..0e13d778c003 100644
--- a/drivers/staging/hv/vmbus_drv.c
+++ b/drivers/staging/hv/vmbus_drv.c
@@ -606,7 +606,7 @@ static int vmbus_child_device_register(struct hv_device *root_device_obj, struct
 	int ret=0;
 	struct device_context *root_device_ctx = to_device_context(root_device_obj);
 	struct device_context *child_device_ctx = to_device_context(child_device_obj);
-	static int device_num=0;
+	static atomic_t device_num = ATOMIC_INIT(0);
 
 	DPRINT_ENTER(VMBUS_DRV);
 
@@ -623,7 +623,7 @@ static int vmbus_child_device_register(struct hv_device *root_device_obj, struct
 	}
 
 	/* Set the device bus id. Otherwise, device_register()will fail. */
-	dev_set_name(&amp;child_device_ctx-&gt;device, "vmbus_0_%d", InterlockedIncrement(&amp;device_num));
+	dev_set_name(&amp;child_device_ctx-&gt;device, "vmbus_0_%d", atomic_inc_return(&amp;device_num));
 
 	/* The new device belongs to this bus */
 	child_device_ctx-&gt;device.bus = &amp;g_vmbus_drv.bus; /* device-&gt;dev.bus; */</pre><hr><pre>commit 7c369f405bc918f3245c7ee0b0ad6c6b6c750166
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:11 2009 -0400

    Staging: hv: remove wrapper functions for bit operations
    
    There were several Bit* functions that did nothing but call the kernel
    functions with the parameters reversed.  Remove these and call the
    functions directly.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Channel.c b/drivers/staging/hv/Channel.c
index e6337418767a..4b5e3e40aa3a 100644
--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -104,12 +104,16 @@ VmbusChannelSetEvent(
 	if (Channel-&gt;OfferMsg.MonitorAllocated)
 	{
 		/* Each u32 represents 32 channels */
-		BitSet((u32*)gVmbusConnection.SendInterruptPage + (Channel-&gt;OfferMsg.ChildRelId &gt;&gt; 5), Channel-&gt;OfferMsg.ChildRelId &amp; 31);
+		set_bit(Channel-&gt;OfferMsg.ChildRelId &amp; 31,
+			(unsigned long *) gVmbusConnection.SendInterruptPage +
+			(Channel-&gt;OfferMsg.ChildRelId &gt;&gt; 5) );
 
 		monitorPage = (HV_MONITOR_PAGE*)gVmbusConnection.MonitorPages;
 		monitorPage++; /* Get the child to parent monitor page */
 
-		BitSet((u32*) &amp;monitorPage-&gt;TriggerGroup[Channel-&gt;MonitorGroup].Pending, Channel-&gt;MonitorBit);
+		set_bit(Channel-&gt;MonitorBit,
+			(unsigned long *) &amp;monitorPage-&gt;TriggerGroup[Channel-&gt;MonitorGroup].Pending);
+
 	}
 	else
 	{
@@ -132,12 +136,14 @@ VmbusChannelClearEvent(
 	if (Channel-&gt;OfferMsg.MonitorAllocated)
 	{
 		/* Each u32 represents 32 channels */
-		BitClear((u32*)gVmbusConnection.SendInterruptPage + (Channel-&gt;OfferMsg.ChildRelId &gt;&gt; 5), Channel-&gt;OfferMsg.ChildRelId &amp; 31);
+		clear_bit(Channel-&gt;OfferMsg.ChildRelId &amp; 31,
+			  (unsigned long *) gVmbusConnection.SendInterruptPage + (Channel-&gt;OfferMsg.ChildRelId &gt;&gt; 5));
 
 		monitorPage = (HV_MONITOR_PAGE*)gVmbusConnection.MonitorPages;
 		monitorPage++; /* Get the child to parent monitor page */
 
-		BitClear((u32*) &amp;monitorPage-&gt;TriggerGroup[Channel-&gt;MonitorGroup].Pending, Channel-&gt;MonitorBit);
+		clear_bit(Channel-&gt;MonitorBit,
+			  (unsigned long *) &amp;monitorPage-&gt;TriggerGroup[Channel-&gt;MonitorGroup].Pending);
 	}
 
 	DPRINT_EXIT(VMBUS);
diff --git a/drivers/staging/hv/Connection.c b/drivers/staging/hv/Connection.c
index 8d76bd45db87..b7df7e7a38e6 100644
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -358,7 +358,7 @@ VmbusOnEvents(
 			{
 				for (bit = 0; bit &lt; 32; bit++)
 				{
-					if (BitTestAndClear(&amp;recvInterruptPage[dword], bit))
+					if (test_and_clear_bit(bit, (unsigned long *) &amp;recvInterruptPage[dword]))
 					{
 						relid = (dword &lt;&lt; 5) + bit;
 
@@ -432,7 +432,9 @@ VmbusSetEvent(u32 childRelId)
 	DPRINT_ENTER(VMBUS);
 
 	/* Each u32 represents 32 channels */
-	BitSet((u32*)gVmbusConnection.SendInterruptPage + (childRelId &gt;&gt; 5), childRelId &amp; 31);
+	set_bit(childRelId &amp; 31,
+		(unsigned long *) gVmbusConnection.SendInterruptPage + (childRelId &gt;&gt; 5));
+
 	ret = HvSignalEvent();
 
 	DPRINT_EXIT(VMBUS);
diff --git a/drivers/staging/hv/Vmbus.c b/drivers/staging/hv/Vmbus.c
index 13d7ac80d6b4..fa8c58f57829 100644
--- a/drivers/staging/hv/Vmbus.c
+++ b/drivers/staging/hv/Vmbus.c
@@ -511,7 +511,7 @@ VmbusOnISR(
 	event = (HV_SYNIC_EVENT_FLAGS*)page_addr + VMBUS_MESSAGE_SINT;
 
 	/* Since we are a child, we only need to check bit 0 */
-	if (BitTestAndClear(&amp;event-&gt;Flags32[0], 0))
+	if (test_and_clear_bit(0, (unsigned long *) &amp;event-&gt;Flags32[0]))
 	{
 		DPRINT_DBG(VMBUS, "received event %d", event-&gt;Flags32[0]);
 		ret |= 0x2;
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index e1f37879f52d..ee44e7e9547d 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -109,12 +109,6 @@ static inline void do_cpuid(unsigned int op, unsigned int *eax, unsigned int *eb
 
 /* Osd routines */
 
-extern void BitSet(unsigned int* addr, int value);
-extern void BitClear(unsigned int* addr, int value);
-extern int BitTest(unsigned int* addr, int value);
-extern int BitTestAndClear(unsigned int* addr, int value);
-extern int BitTestAndSet(unsigned int* addr, int value);
-
 extern int InterlockedIncrement(int *val);
 extern int InterlockedDecrement(int *val);
 extern int InterlockedCompareExchange(int *val, int new, int curr);
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index 8ca56a4fce2b..ff01a7b9c120 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -56,33 +56,6 @@ struct osd_callback_struct {
 	void *data;
 };
 
-
-void BitSet(unsigned int* addr, int bit)
-{
-	set_bit(bit, (unsigned long*)addr);
-}
-
-int BitTest(unsigned int* addr, int bit)
-{
-	return test_bit(bit, (unsigned long*)addr);
-}
-
-void BitClear(unsigned int* addr, int bit)
-{
-	clear_bit(bit, (unsigned long*)addr);
-}
-
-int BitTestAndClear(unsigned int* addr, int bit)
-{
-	return test_and_clear_bit(bit, (unsigned long*)addr);
-}
-
-int BitTestAndSet(unsigned int* addr, int bit)
-{
-	return test_and_set_bit(bit, (unsigned long*)addr);
-}
-
-
 int InterlockedIncrement(int *val)
 {
 	return atomic_inc_return((atomic_t*)val);</pre><hr><pre>commit 420beac4fcc9efd6f7d838ef7cc5693c58c98015
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:10 2009 -0400

    Staging: hv: remove WaitEventClose()
    
    All WaitEventClose() close did was call kfree(), so get rid of it and
    replace it with a call to kfree()
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Channel.c b/drivers/staging/hv/Channel.c
index 34c86628422c..e6337418767a 100644
--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -309,7 +309,7 @@ VmbusChannelOpen(
 	REMOVE_ENTRY_LIST(&amp;openInfo-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	WaitEventClose(openInfo-&gt;WaitEvent);
+	kfree(openInfo-&gt;WaitEvent);
 	kfree(openInfo);
 
 	DPRINT_EXIT(VMBUS);
@@ -596,7 +596,7 @@ VmbusChannelEstablishGpadl(
 	REMOVE_ENTRY_LIST(&amp;msgInfo-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	WaitEventClose(msgInfo-&gt;WaitEvent);
+	kfree(msgInfo-&gt;WaitEvent);
 	kfree(msgInfo);
 
 	DPRINT_EXIT(VMBUS);
@@ -658,7 +658,7 @@ VmbusChannelTeardownGpadl(
 	REMOVE_ENTRY_LIST(&amp;info-&gt;MsgListEntry);
 	spin_unlock_irqrestore(&amp;gVmbusConnection.channelmsg_lock, flags);
 
-	WaitEventClose(info-&gt;WaitEvent);
+	kfree(info-&gt;WaitEvent);
 	kfree(info);
 
 	DPRINT_EXIT(VMBUS);
diff --git a/drivers/staging/hv/ChannelMgmt.c b/drivers/staging/hv/ChannelMgmt.c
index 2c4f4c8e5e72..7ef1f2ba19d2 100644
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -762,7 +762,7 @@ VmbusChannelRequestOffers(
 Cleanup:
 	if (msgInfo)
 	{
-		WaitEventClose(msgInfo-&gt;WaitEvent);
+		kfree(msgInfo-&gt;WaitEvent);
 		kfree(msgInfo);
 	}
 
diff --git a/drivers/staging/hv/Connection.c b/drivers/staging/hv/Connection.c
index 33e5628b88c3..8d76bd45db87 100644
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -155,7 +155,7 @@ VmbusConnect(void)
 	}
 
 
-	WaitEventClose(msgInfo-&gt;WaitEvent);
+	kfree(msgInfo-&gt;WaitEvent);
 	kfree(msgInfo);
 	DPRINT_EXIT(VMBUS);
 
@@ -183,7 +183,7 @@ VmbusConnect(void)
 	if (msgInfo)
 	{
 		if (msgInfo-&gt;WaitEvent)
-			WaitEventClose(msgInfo-&gt;WaitEvent);
+			kfree(msgInfo-&gt;WaitEvent);
 
 		kfree(msgInfo);
 	}
diff --git a/drivers/staging/hv/NetVsc.c b/drivers/staging/hv/NetVsc.c
index 9445e36423b9..dea54098e510 100644
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -880,7 +880,7 @@ NetVscOnDeviceAdd(
 
 	if (netDevice)
 	{
-		WaitEventClose(netDevice-&gt;ChannelInitEvent);
+		kfree(netDevice-&gt;ChannelInitEvent);
 
 		while (!IsListEmpty(&amp;netDevice-&gt;ReceivePacketList))
 		{
@@ -963,7 +963,7 @@ NetVscOnDeviceRemove(
 		kfree(netvscPacket);
 	}
 
-	WaitEventClose(netDevice-&gt;ChannelInitEvent);
+	kfree(netDevice-&gt;ChannelInitEvent);
 	FreeNetDevice(netDevice);
 
 	DPRINT_EXIT(NETVSC);
diff --git a/drivers/staging/hv/RndisFilter.c b/drivers/staging/hv/RndisFilter.c
index c6b9dfd2f2e4..5b992dfdb0f6 100644
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -273,7 +273,7 @@ static inline void PutRndisRequest(RNDIS_DEVICE *Device, RNDIS_REQUEST *Request)
 	REMOVE_ENTRY_LIST(&amp;Request-&gt;ListEntry);
 	spin_unlock_irqrestore(&amp;Device-&gt;request_lock, flags);
 
-	WaitEventClose(Request-&gt;WaitEvent);
+	kfree(Request-&gt;WaitEvent);
 	kfree(Request);
 }
 
diff --git a/drivers/staging/hv/StorVsc.c b/drivers/staging/hv/StorVsc.c
index 1c82e7923ff0..ef8031fd3850 100644
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -516,7 +516,7 @@ static int StorVscChannelInit(struct hv_device *Device)
 Cleanup:
 	if (request-&gt;WaitEvent)
 	{
-		WaitEventClose(request-&gt;WaitEvent);
+		kfree(request-&gt;WaitEvent);
 		request-&gt;WaitEvent = NULL;
 	}
 
@@ -678,7 +678,7 @@ StorVscOnHostReset(
 	/* FIXME: Add a timeout */
 	WaitEventWait(request-&gt;WaitEvent);
 
-	WaitEventClose(request-&gt;WaitEvent);
+	kfree(request-&gt;WaitEvent);
 	DPRINT_INFO(STORVSC, "host adapter reset completed");
 
 	/*
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index 4147aba5d314..e1f37879f52d 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -134,7 +134,6 @@ extern int TimerStop(struct osd_timer *t);
 extern void TimerStart(struct osd_timer *t, u32 expirationInUs);
 
 extern struct osd_waitevent *WaitEventCreate(void);
-extern void WaitEventClose(struct osd_waitevent *waitEvent);
 extern void WaitEventSet(struct osd_waitevent *waitEvent);
 extern int	WaitEventWait(struct osd_waitevent *waitEvent);
 
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index 46cdf88cf9d5..8ca56a4fce2b 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -216,11 +216,6 @@ struct osd_waitevent *WaitEventCreate(void)
 	return wait;
 }
 
-void WaitEventClose(struct osd_waitevent *waitEvent)
-{
-	kfree(waitEvent);
-}
-
 void WaitEventSet(struct osd_waitevent *waitEvent)
 {
 	waitEvent-&gt;condition = 1;</pre><hr><pre>commit de65a38406bdf712abc2a845fe1f3db7d1a083ed
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Jul 29 17:00:09 2009 -0400

    Staging: hv: rework use of workqueues in osd
    
    Change the usage of workqueues to be consistant with other parts of
    the kernel.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/ChannelMgmt.c b/drivers/staging/hv/ChannelMgmt.c
index c5efc6ec6c36..2c4f4c8e5e72 100644
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -149,7 +149,7 @@ static VMBUS_CHANNEL* AllocVmbusChannel(void)
 	}
 
 	/* channel-&gt;dataWorkQueue = WorkQueueCreate("data"); */
-	channel-&gt;ControlWQ = WorkQueueCreate("control");
+	channel-&gt;ControlWQ = create_workqueue("hv_vmbus_ctl");
 	if (!channel-&gt;ControlWQ)
 	{
 		TimerClose(channel-&gt;PollTimer);
@@ -176,7 +176,7 @@ static inline void ReleaseVmbusChannel(void* Context)
 	DPRINT_ENTER(VMBUS);
 
 	DPRINT_DBG(VMBUS, "releasing channel (%p)", channel);
-	WorkQueueClose(channel-&gt;ControlWQ);
+	destroy_workqueue(channel-&gt;ControlWQ);
 	DPRINT_DBG(VMBUS, "channel released (%p)", channel);
 
 	kfree(channel);
@@ -199,7 +199,8 @@ static void FreeVmbusChannel(VMBUS_CHANNEL* Channel)
 
 	/* We have to release the channel's workqueue/thread in the vmbus's workqueue/thread context */
 	/* ie we can't destroy ourselves. */
-	WorkQueueQueueWorkItem(gVmbusConnection.WorkQueue, ReleaseVmbusChannel, (void*)Channel);
+	osd_schedule_callback(gVmbusConnection.WorkQueue, ReleaseVmbusChannel,
+			      (void *)Channel);
 }
 
 
@@ -389,7 +390,8 @@ VmbusChannelOnOffer(
 	newChannel-&gt;MonitorBit = (u8)offer-&gt;MonitorId % 32;
 
 	/* TODO: Make sure the offer comes from our parent partition */
-	WorkQueueQueueWorkItem(newChannel-&gt;ControlWQ, VmbusChannelProcessOffer, newChannel);
+	osd_schedule_callback(newChannel-&gt;ControlWQ, VmbusChannelProcessOffer,
+			      newChannel);
 
 	DPRINT_EXIT(VMBUS);
 }
@@ -422,7 +424,9 @@ VmbusChannelOnOfferRescind(
 		return;
 	}
 
-	WorkQueueQueueWorkItem(channel-&gt;ControlWQ, VmbusChannelProcessRescindOffer, channel);
+	osd_schedule_callback(channel-&gt;ControlWQ,
+			      VmbusChannelProcessRescindOffer,
+			      channel);
 
 	DPRINT_EXIT(VMBUS);
 }
diff --git a/drivers/staging/hv/Connection.c b/drivers/staging/hv/Connection.c
index a2888cb46709..33e5628b88c3 100644
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -60,7 +60,12 @@ VmbusConnect(void)
 
 	/* Initialize the vmbus connection */
 	gVmbusConnection.ConnectState = Connecting;
-	gVmbusConnection.WorkQueue = WorkQueueCreate("vmbusQ");
+	gVmbusConnection.WorkQueue = create_workqueue("hv_vmbus_con");
+	if (!gVmbusConnection.WorkQueue)
+	{
+		ret = -1;
+		goto Cleanup;
+	}
 
 	INITIALIZE_LIST_HEAD(&amp;gVmbusConnection.ChannelMsgList);
 	spin_lock_init(&amp;gVmbusConnection.channelmsg_lock);
@@ -160,7 +165,8 @@ VmbusConnect(void)
 
 	gVmbusConnection.ConnectState = Disconnected;
 
-	WorkQueueClose(gVmbusConnection.WorkQueue);
+	if (gVmbusConnection.WorkQueue)
+		destroy_workqueue(gVmbusConnection.WorkQueue);
 
 	if (gVmbusConnection.InterruptPage)
 	{
@@ -226,7 +232,7 @@ VmbusDisconnect(
 
 	/* TODO: iterate thru the msg list and free up */
 
-	WorkQueueClose(gVmbusConnection.WorkQueue);
+	destroy_workqueue(gVmbusConnection.WorkQueue);
 
 	gVmbusConnection.ConnectState = Disconnected;
 
diff --git a/drivers/staging/hv/Vmbus.c b/drivers/staging/hv/Vmbus.c
index c8e0df6c4805..13d7ac80d6b4 100644
--- a/drivers/staging/hv/Vmbus.c
+++ b/drivers/staging/hv/Vmbus.c
@@ -423,7 +423,9 @@ VmbusOnMsgDPC(
 			}
 
 			memcpy(copied, msg, sizeof(HV_MESSAGE));
-			WorkQueueQueueWorkItem(gVmbusConnection.WorkQueue, VmbusOnChannelMessage, (void*)copied);
+			osd_schedule_callback(gVmbusConnection.WorkQueue,
+					      VmbusOnChannelMessage,
+					      (void *)copied);
 		}
 
 		msg-&gt;Header.MessageType = HvMessageTypeNone;
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index 2a47d149b83e..4147aba5d314 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -47,7 +47,6 @@ typedef struct _DLIST_ENTRY {
 
 /* typedef unsigned char		GUID[16]; */
 
-typedef void (*PFN_WORKITEM_CALLBACK)(void* context);
 typedef void (*PFN_TIMER_CALLBACK)(void* context);
 
 
@@ -155,12 +154,8 @@ void* PageMapVirtualAddress(unsigned long Pfn);
 void PageUnmapVirtualAddress(void* VirtAddr);
 
 
-extern struct workqueue_struct *WorkQueueCreate(char* name);
-extern void WorkQueueClose(struct workqueue_struct *hWorkQueue);
-extern int WorkQueueQueueWorkItem(struct workqueue_struct *hWorkQueue,
-				  PFN_WORKITEM_CALLBACK workItem,
-				  void *context);
-
-extern void QueueWorkItem(PFN_WORKITEM_CALLBACK workItem, void* context);
+int osd_schedule_callback(struct workqueue_struct *wq,
+			  void (*func)(void *),
+			  void *data);
 
 #endif /* _OSD_H_ */
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index ea3e226f178a..46cdf88cf9d5 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -50,11 +50,11 @@
 /* Data types */
 
 
-typedef struct _WORKITEM {
+struct osd_callback_struct {
 	struct work_struct work;
-	PFN_WORKITEM_CALLBACK callback;
-	void* context;
-} WORKITEM;
+	void (*callback)(void *);
+	void *data;
+};
 
 
 void BitSet(unsigned int* addr, int bit)
@@ -269,56 +269,32 @@ unsigned long Virtual2Physical(void * VirtAddr)
 	return pfn &lt;&lt; PAGE_SHIFT;
 }
 
-static void WorkItemCallback(struct work_struct *work)
+static void osd_callback_work(struct work_struct *work)
 {
-	WORKITEM* w = (WORKITEM*)work;
+	struct osd_callback_struct *cb = container_of(work,
+						      struct osd_callback_struct,
+						      work);
+	(cb-&gt;callback)(cb-&gt;data);
 
-	w-&gt;callback(w-&gt;context);
-
-	kfree(w);
-}
-
-struct workqueue_struct *WorkQueueCreate(char *name)
-{
-	struct workqueue_struct *wq;
-	wq = create_workqueue(name);
-	if (unlikely(!wq))
-		return NULL;
-	return wq;
+	kfree(cb);
 }
 
-void WorkQueueClose(struct workqueue_struct *hWorkQueue)
+int osd_schedule_callback(struct workqueue_struct *wq,
+			  void (*func)(void *),
+			  void *data)
 {
-	destroy_workqueue(hWorkQueue);
-	return;
-}
+	struct osd_callback_struct *cb;
 
-int WorkQueueQueueWorkItem(struct workqueue_struct *hWorkQueue,
-			   PFN_WORKITEM_CALLBACK workItem,
-			   void* context)
-{
-	WORKITEM* w = kmalloc(sizeof(WORKITEM), GFP_ATOMIC);
-	if (!w)
+	cb = kmalloc(sizeof(*cb), GFP_KERNEL);
+	if (!cb)
 	{
+		printk(KERN_ERR "unable to allocate memory in osd_schedule_callback");
 		return -1;
 	}
 
-	w-&gt;callback = workItem,
-	w-&gt;context = context;
-	INIT_WORK(&amp;w-&gt;work, WorkItemCallback);
-	return queue_work(hWorkQueue, &amp;w-&gt;work);
+	cb-&gt;callback = func;
+	cb-&gt;data = data;
+	INIT_WORK(&amp;cb-&gt;work, osd_callback_work);
+	return queue_work(wq, &amp;cb-&gt;work);
 }
 
-void QueueWorkItem(PFN_WORKITEM_CALLBACK workItem, void* context)
-{
-	WORKITEM* w = kmalloc(sizeof(WORKITEM), GFP_ATOMIC);
-	if (!w)
-	{
-		return;
-	}
-
-	w-&gt;callback = workItem,
-	w-&gt;context = context;
-	INIT_WORK(&amp;w-&gt;work, WorkItemCallback);
-	schedule_work(&amp;w-&gt;work);
-}</pre><hr><pre>commit 44f357f835d8a8223b922984eea01aaea29a5f0f
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Jul 28 13:46:26 2009 -0400

    Staging: hv: remove HANDLE typedef
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/Hv.c b/drivers/staging/hv/Hv.c
index 2a8a652c1f74..0883179cf847 100644
--- a/drivers/staging/hv/Hv.c
+++ b/drivers/staging/hv/Hv.c
@@ -235,8 +235,8 @@ HvInit (
 
 	DPRINT_ENTER(VMBUS);
 
-	memset(gHvContext.synICEventPage, 0, sizeof(HANDLE)*MAX_NUM_CPUS);
-	memset(gHvContext.synICMessagePage, 0, sizeof(HANDLE)*MAX_NUM_CPUS);
+	memset(gHvContext.synICEventPage, 0, sizeof(void *) * MAX_NUM_CPUS);
+	memset(gHvContext.synICMessagePage, 0, sizeof(void *) * MAX_NUM_CPUS);
 
 	if (!HvQueryHypervisorPresence())
 	{
diff --git a/drivers/staging/hv/Hv.h b/drivers/staging/hv/Hv.h
index a62ac33d97d2..b5ea3dcc6f1b 100644
--- a/drivers/staging/hv/Hv.h
+++ b/drivers/staging/hv/Hv.h
@@ -119,8 +119,8 @@ typedef struct {
 	HV_INPUT_SIGNAL_EVENT_BUFFER *SignalEventBuffer;
 	HV_INPUT_SIGNAL_EVENT *SignalEventParam; /* 8-bytes aligned of the buffer above */
 
-	HANDLE	synICMessagePage[MAX_NUM_CPUS];
-	HANDLE	synICEventPage[MAX_NUM_CPUS];
+	void *synICMessagePage[MAX_NUM_CPUS];
+	void *synICEventPage[MAX_NUM_CPUS];
 } HV_CONTEXT;
 
 extern HV_CONTEXT gHvContext;
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index 2cd2cf034044..2a47d149b83e 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -46,7 +46,6 @@ typedef struct _DLIST_ENTRY {
 /* Other types */
 
 /* typedef unsigned char		GUID[16]; */
-typedef void*				HANDLE;
 
 typedef void (*PFN_WORKITEM_CALLBACK)(void* context);
 typedef void (*PFN_TIMER_CALLBACK)(void* context);</pre><hr><pre>commit 06d2e318b749689d659b3f0c90a157f1ebb31f15
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Jul 28 13:46:25 2009 -0400

    Staging: hv remove TIMER typedef
    
    Remove the TIMER typedef and also replace HANDLE types that use
    the timer calls.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Hank Janssen &lt;hjanssen@microsoft.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/hv/ChannelMgmt.h b/drivers/staging/hv/ChannelMgmt.h
index 7cf01738e42c..71173d0f537e 100644
--- a/drivers/staging/hv/ChannelMgmt.h
+++ b/drivers/staging/hv/ChannelMgmt.h
@@ -47,7 +47,7 @@ typedef struct _VMBUS_CHANNEL {
 
 	struct hv_device *DeviceObject;
 
-	HANDLE						PollTimer; /* SA-111 workaround */
+	struct osd_timer *PollTimer; /* SA-111 workaround */
 
 	VMBUS_CHANNEL_STATE			State;
 
diff --git a/drivers/staging/hv/include/osd.h b/drivers/staging/hv/include/osd.h
index 470d8021b030..2cd2cf034044 100644
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -48,6 +48,10 @@ typedef struct _DLIST_ENTRY {
 /* typedef unsigned char		GUID[16]; */
 typedef void*				HANDLE;
 
+typedef void (*PFN_WORKITEM_CALLBACK)(void* context);
+typedef void (*PFN_TIMER_CALLBACK)(void* context);
+
+
 typedef struct {
 	unsigned char	Data[16];
 } GUID;
@@ -57,9 +61,12 @@ struct osd_waitevent {
 	wait_queue_head_t event;
 };
 
+struct osd_timer {
+	struct timer_list timer;
+	PFN_TIMER_CALLBACK callback;
+	void* context;
+};
 
-typedef void (*PFN_WORKITEM_CALLBACK)(void* context);
-typedef void (*PFN_TIMER_CALLBACK)(void* context);
 
 
 #ifdef __x86_64__
@@ -123,10 +130,10 @@ extern void PageFree(void* page, unsigned int count);
 extern void* MemMapIO(unsigned long phys, unsigned long size);
 extern void MemUnmapIO(void* virt);
 
-extern HANDLE TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context);
-extern void TimerClose(HANDLE hTimer);
-extern int TimerStop(HANDLE hTimer);
-extern void TimerStart(HANDLE hTimer, u32 expirationInUs);
+extern struct osd_timer *TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context);
+extern void TimerClose(struct osd_timer *t);
+extern int TimerStop(struct osd_timer *t);
+extern void TimerStart(struct osd_timer *t, u32 expirationInUs);
 
 extern struct osd_waitevent *WaitEventCreate(void);
 extern void WaitEventClose(struct osd_waitevent *waitEvent);
diff --git a/drivers/staging/hv/osd.c b/drivers/staging/hv/osd.c
index 50a2ca7dde2e..35c9ac2f3158 100644
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -49,11 +49,6 @@
 
 /* Data types */
 
-typedef struct _TIMER {
-	struct timer_list timer;
-	PFN_TIMER_CALLBACK callback;
-	void* context;
-}TIMER;
 
 typedef struct _WORKITEM {
 	struct work_struct work;
@@ -168,14 +163,14 @@ void MemUnmapIO(void *virt)
 
 void TimerCallback(unsigned long data)
 {
-	TIMER* t = (TIMER*)data;
+	struct osd_timer *t = (struct osd_timer *) data;
 
 	t-&gt;callback(t-&gt;context);
 }
 
-HANDLE TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
+struct osd_timer *TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
 {
-	TIMER* t = kmalloc(sizeof(TIMER), GFP_KERNEL);
+	struct osd_timer *t = kmalloc(sizeof(struct osd_timer), GFP_KERNEL);
 	if (!t)
 	{
 		return NULL;
@@ -191,25 +186,19 @@ HANDLE TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
 	return t;
 }
 
-void TimerStart(HANDLE hTimer, u32 expirationInUs)
+void TimerStart(struct osd_timer *t, u32 expirationInUs)
 {
-	TIMER* t  = (TIMER* )hTimer;
-
 	t-&gt;timer.expires = jiffies + usecs_to_jiffies(expirationInUs);
 	add_timer(&amp;t-&gt;timer);
 }
 
-int TimerStop(HANDLE hTimer)
+int TimerStop(struct osd_timer *t)
 {
-	TIMER* t  = (TIMER* )hTimer;
-
 	return del_timer(&amp;t-&gt;timer);
 }
 
-void TimerClose(HANDLE hTimer)
+void TimerClose(struct osd_timer *t)
 {
-	TIMER* t  = (TIMER* )hTimer;
-
 	del_timer(&amp;t-&gt;timer);
 	kfree(t);
 }</pre>
    <div class="pagination">
        <a href='3_48.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><span>[49]</span><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_50.html'>Next&gt;&gt;</a>
    <div>
</body>
