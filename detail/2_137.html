<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_136.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><span>[137]</span><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_138.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b375a0495fd622037560c73c05f23ae6f127bb0c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 16:11:07 2005 -0400

    [PATCH] USB: URB_ASYNC_UNLINK flag removed from the kernel
    
    29 July 2005, Cambridge, MA:
    
    This afternoon Alan Stern submitted a patch to remove the URB_ASYNC_UNLINK
    flag from the Linux kernel.  Mr. Stern explained, "This flag is a relic
    from an earlier, less-well-designed system.  For over a year it hasn't
    been used for anything other than printing warning messages."
    
    An anonymous spokesman for the Linux kernel development community
    commented, "This is exactly the sort of thing we see happening all the
    time.  As the kernel evolves, support for old techniques and old code can
    be jettisoned and replaced by newer, better approaches.  Proprietary
    operating systems do not have the freedom or flexibility to change so
    quickly."
    
    Mr. Stern, a staff member at Harvard University's Rowland Institute who
    works on Linux only as a hobby, noted that the patch (labelled as548) did
    not update two files, keyspan.c and option.c, in the USB drivers' "serial"
    subdirectory.  "Those files need more extensive changes," he remarked.
    "They examine the status field of several URBs at times when they're not
    supposed to.  That will need to be fixed before the URB_ASYNC_UNLINK flag
    is removed."
    
    Greg Kroah-Hartman, the kernel maintainer responsible for overseeing all
    of Linux's USB drivers, did not respond to our inquiries or return our
    calls.  His only comment was "Applied, thanks."
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/block/ub.c b/drivers/block/ub.c
index 57d3279a8815..aa0bf7ee008d 100644
--- a/drivers/block/ub.c
+++ b/drivers/block/ub.c
@@ -1010,7 +1010,7 @@ static int ub_scsi_cmd_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	sc-&gt;last_pipe = sc-&gt;send_bulk_pipe;
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;send_bulk_pipe,
 	    bcb, US_BULK_CB_WRAP_LEN, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 
 	/* Fill what we shouldn't be filling, because usb-storage did so. */
 	sc-&gt;work_urb.actual_length = 0;
@@ -1395,7 +1395,7 @@ static void ub_data_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, pipe,
 	    page_address(sg-&gt;page) + sg-&gt;offset, sg-&gt;length,
 	    ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
@@ -1442,7 +1442,7 @@ static int __ub_state_stat(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	sc-&gt;last_pipe = sc-&gt;recv_bulk_pipe;
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;recv_bulk_pipe,
 	    &amp;sc-&gt;work_bcs, US_BULK_CS_WRAP_LEN, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
@@ -1563,7 +1563,7 @@ static int ub_submit_clear_stall(struct ub_dev *sc, struct ub_scsi_cmd *cmd,
 
 	usb_fill_control_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;send_ctrl_pipe,
 	    (unsigned char*) cr, NULL, 0, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
diff --git a/drivers/net/irda/irda-usb.c b/drivers/net/irda/irda-usb.c
index 46e0022d3258..6c766fdc51a6 100644
--- a/drivers/net/irda/irda-usb.c
+++ b/drivers/net/irda/irda-usb.c
@@ -267,7 +267,7 @@ static void irda_usb_change_speed_xbofs(struct irda_usb_cb *self)
                       frame, IRDA_USB_SPEED_MTU,
                       speed_bulk_callback, self);
 	urb-&gt;transfer_buffer_length = USB_IRDA_HEADER;
-	urb-&gt;transfer_flags = URB_ASYNC_UNLINK;
+	urb-&gt;transfer_flags = 0;
 
 	/* Irq disabled -&gt; GFP_ATOMIC */
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC))) {
@@ -401,15 +401,12 @@ static int irda_usb_hard_xmit(struct sk_buff *skb, struct net_device *netdev)
                       skb-&gt;data, IRDA_SKB_MAX_MTU,
                       write_bulk_callback, skb);
 	urb-&gt;transfer_buffer_length = skb-&gt;len;
-	/* Note : unlink *must* be Asynchronous because of the code in 
-	 * irda_usb_net_timeout() -&gt; call in irq - Jean II */
-	urb-&gt;transfer_flags = URB_ASYNC_UNLINK;
 	/* This flag (URB_ZERO_PACKET) indicates that what we send is not
 	 * a continuous stream of data but separate packets.
 	 * In this case, the USB layer will insert an empty USB frame (TD)
 	 * after each of our packets that is exact multiple of the frame size.
 	 * This is how the dongle will detect the end of packet - Jean II */
-	urb-&gt;transfer_flags |= URB_ZERO_PACKET;
+	urb-&gt;transfer_flags = URB_ZERO_PACKET;
 
 	/* Generate min turn time. FIXME: can we do better than this? */
 	/* Trying to a turnaround time at this level is trying to measure
@@ -630,8 +627,6 @@ static void irda_usb_net_timeout(struct net_device *netdev)
 			 * in completion handler, because urb-&gt;status will
 			 * be -ENOENT. We will fix that at the next watchdog,
 			 * leaving more time to USB to recover...
-			 * Also, we are in interrupt, so we need to have
-			 * URB_ASYNC_UNLINK to work properly...
 			 * Jean II */
 			done = 1;
 			break;
@@ -1008,9 +1003,7 @@ static int irda_usb_net_close(struct net_device *netdev)
 		}
 	}
 	/* Cancel Tx and speed URB - need to be synchronous to avoid races */
-	self-&gt;tx_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 	usb_kill_urb(self-&gt;tx_urb);
-	self-&gt;speed_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 	usb_kill_urb(self-&gt;speed_urb);
 
 	/* Stop and remove instance of IrLAP */
@@ -1521,9 +1514,7 @@ static void irda_usb_disconnect(struct usb_interface *intf)
 			usb_kill_urb(self-&gt;rx_urb[i]);
 		/* Cancel Tx and speed URB.
 		 * Toggle flags to make sure it's synchronous. */
-		self-&gt;tx_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		usb_kill_urb(self-&gt;tx_urb);
-		self-&gt;speed_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		usb_kill_urb(self-&gt;speed_urb);
 	}
 
diff --git a/drivers/usb/atm/cxacru.c b/drivers/usb/atm/cxacru.c
index 8e184e2641cb..79861ee12a29 100644
--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -715,13 +715,11 @@ static int cxacru_bind(struct usbatm_data *usbatm_instance,
 			usb_dev, usb_rcvintpipe(usb_dev, CXACRU_EP_CMD),
 			instance-&gt;rcv_buf, PAGE_SIZE,
 			cxacru_blocking_completion, &amp;instance-&gt;rcv_done, 1);
-	instance-&gt;rcv_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	usb_fill_int_urb(instance-&gt;snd_urb,
 			usb_dev, usb_sndintpipe(usb_dev, CXACRU_EP_CMD),
 			instance-&gt;snd_buf, PAGE_SIZE,
 			cxacru_blocking_completion, &amp;instance-&gt;snd_done, 4);
-	instance-&gt;snd_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	init_MUTEX(&amp;instance-&gt;cm_serialize);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 88d1b376f67c..74197249c245 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -48,7 +48,6 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int* actual_length)
 
 	init_completion(&amp;done); 	
 	urb-&gt;context = &amp;done;
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	urb-&gt;actual_length = 0;
 	status = usb_submit_urb(urb, GFP_NOIO);
 
@@ -357,8 +356,7 @@ int usb_sg_init (
 	if (!io-&gt;urbs)
 		goto nomem;
 
-	urb_flags = URB_ASYNC_UNLINK | URB_NO_TRANSFER_DMA_MAP
-			| URB_NO_INTERRUPT;
+	urb_flags = URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT;
 	if (usb_pipein (pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c0feee25ff0a..c846fefb7386 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,9 +309,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
 	unsigned int	allowed;
 
 	/* enforce simple/standard policy */
-	allowed = URB_ASYNC_UNLINK;	// affects later unlinks
-	allowed |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
-	allowed |= URB_NO_INTERRUPT;
+	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
+			URB_NO_INTERRUPT);
 	switch (temp) {
 	case PIPE_BULK:
 		if (is_out)
@@ -400,14 +399,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
  * canceled (rather than any other code) and will quickly be removed
  * from host controller data structures.
  *
- * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the
- * URB indicated that the request was synchronous.  This usage is now
- * deprecated; if the flag is clear the call will be forwarded to
- * usb_kill_urb() and the return value will be 0.  In the future, drivers
- * should call usb_kill_urb() directly for synchronous unlinking.
- *
- * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this
- * request is asynchronous.  Success is indicated by returning -EINPROGRESS,
+ * This request is always asynchronous.
+ * Success is indicated by returning -EINPROGRESS,
  * at which time the URB will normally have been unlinked but not yet
  * given back to the device driver.  When it is called, the completion
  * function will see urb-&gt;status == -ECONNRESET.  Failure is indicated
@@ -453,17 +446,6 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;transfer_flags &amp; URB_ASYNC_UNLINK)) {
-#ifdef CONFIG_DEBUG_KERNEL
-		if (printk_ratelimit()) {
-			printk(KERN_NOTICE "usb_unlink_urb() is deprecated for "
-				"synchronous unlinks.  Use usb_kill_urb() instead.\n");
-			WARN_ON(1);
-		}
-#endif
-		usb_kill_urb(urb);
-		return 0;
-	}
 	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
 		return -ENODEV;
 	return urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ECONNRESET);
diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index 719c0316cc39..1ab95d24c5e2 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1688,7 +1688,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			usb_fill_int_urb(hid-&gt;urbin, dev, pipe, hid-&gt;inbuf, 0,
 					 hid_irq_in, hid, interval);
 			hid-&gt;urbin-&gt;transfer_dma = hid-&gt;inbuf_dma;
-			hid-&gt;urbin-&gt;transfer_flags |=(URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid-&gt;urbin-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		} else {
 			if (hid-&gt;urbout)
 				continue;
@@ -1698,7 +1698,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			usb_fill_int_urb(hid-&gt;urbout, dev, pipe, hid-&gt;outbuf, 0,
 					 hid_irq_out, hid, interval);
 			hid-&gt;urbout-&gt;transfer_dma = hid-&gt;outbuf_dma;
-			hid-&gt;urbout-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid-&gt;urbout-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		}
 	}
 
@@ -1750,7 +1750,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			     hid-&gt;ctrlbuf, 1, hid_ctrl, hid);
 	hid-&gt;urbctrl-&gt;setup_dma = hid-&gt;cr_dma;
 	hid-&gt;urbctrl-&gt;transfer_dma = hid-&gt;ctrlbuf_dma;
-	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP | URB_ASYNC_UNLINK);
+	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
 
 	return hid;
 
diff --git a/drivers/usb/misc/auerswald.c b/drivers/usb/misc/auerswald.c
index 6f7994f5a714..ae4681f9f0ea 100644
--- a/drivers/usb/misc/auerswald.c
+++ b/drivers/usb/misc/auerswald.c
@@ -426,7 +426,7 @@ static int auerchain_submit_urb (pauerchain_t acp, struct urb * urb)
 
 /* cancel an urb which is submitted to the chain
    the result is 0 if the urb is cancelled, or -EINPROGRESS if
-   URB_ASYNC_UNLINK is set and the function is successfully started.
+   the function is successfully started.
 */
 static int auerchain_unlink_urb (pauerchain_t acp, struct urb * urb)
 {
@@ -515,7 +515,6 @@ static void auerchain_unlink_all (pauerchain_t acp)
         acep = acp-&gt;active;
         if (acep) {
                 urbp = acep-&gt;urbp;
-                urbp-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
                 dbg ("unlink active urb");
                 usb_kill_urb (urbp);
         }
diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index 2fd12264fd53..d63ce6c030f3 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -229,7 +229,7 @@ sisusb_bulkout_msg(struct sisusb_usb_data *sisusb, int index, unsigned int pipe,
 	usb_fill_bulk_urb(urb, sisusb-&gt;sisusb_dev, pipe, data, len,
 		sisusb_bulk_completeout, &amp;sisusb-&gt;urbout_context[index]);
 
-	urb-&gt;transfer_flags |= (tflags | URB_ASYNC_UNLINK);
+	urb-&gt;transfer_flags |= tflags;
 	urb-&gt;actual_length = 0;
 
 	if ((urb-&gt;transfer_dma = transfer_dma))
@@ -295,7 +295,7 @@ sisusb_bulkin_msg(struct sisusb_usb_data *sisusb, unsigned int pipe, void *data,
 	usb_fill_bulk_urb(urb, sisusb-&gt;sisusb_dev, pipe, data, len,
 			sisusb_bulk_completein, sisusb);
 
-	urb-&gt;transfer_flags |= (tflags | URB_ASYNC_UNLINK);
+	urb-&gt;transfer_flags |= tflags;
 	urb-&gt;actual_length = 0;
 
 	if ((urb-&gt;transfer_dma = transfer_dma))
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index fd7fb98e4b20..54799eb0bc60 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -986,7 +986,6 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 		u-&gt;context = &amp;context;
 		u-&gt;complete = ctrl_complete;
-		u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	}
 
 	/* queue the urbs */
@@ -1052,7 +1051,6 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
 	if (!urb)
 		return -ENOMEM;
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	urb-&gt;context = &amp;completion;
 	urb-&gt;complete = unlink1_callback;
 
diff --git a/drivers/usb/net/catc.c b/drivers/usb/net/catc.c
index c8be912f24e1..37ef365a2472 100644
--- a/drivers/usb/net/catc.c
+++ b/drivers/usb/net/catc.c
@@ -383,7 +383,6 @@ static void catc_tx_done(struct urb *urb, struct pt_regs *regs)
 
 	if (urb-&gt;status == -ECONNRESET) {
 		dbg("Tx Reset.");
-		urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		urb-&gt;status = 0;
 		catc-&gt;netdev-&gt;trans_start = jiffies;
 		catc-&gt;stats.tx_errors++;
@@ -445,7 +444,6 @@ static void catc_tx_timeout(struct net_device *netdev)
 	struct catc *catc = netdev_priv(netdev);
 
 	warn("Transmit timed out.");
-	catc-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(catc-&gt;tx_urb);
 }
 
diff --git a/drivers/usb/net/kaweth.c b/drivers/usb/net/kaweth.c
index 7ffa99b9760f..e04b0ce3611a 100644
--- a/drivers/usb/net/kaweth.c
+++ b/drivers/usb/net/kaweth.c
@@ -787,7 +787,6 @@ static int kaweth_start_xmit(struct sk_buff *skb, struct net_device *net)
 		      kaweth_usb_transmit_complete,
 		      kaweth);
 	kaweth-&gt;end = 0;
-	kaweth-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	if((res = usb_submit_urb(kaweth-&gt;tx_urb, GFP_ATOMIC)))
 	{
diff --git a/drivers/usb/net/pegasus.c b/drivers/usb/net/pegasus.c
index fcd6d3ccef44..7484d34780fc 100644
--- a/drivers/usb/net/pegasus.c
+++ b/drivers/usb/net/pegasus.c
@@ -825,7 +825,6 @@ static void pegasus_tx_timeout(struct net_device *net)
 	pegasus_t *pegasus = netdev_priv(net);
 	if (netif_msg_timer(pegasus))
 		printk(KERN_WARNING "%s: tx timeout\n", net-&gt;name);
-	pegasus-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(pegasus-&gt;tx_urb);
 	pegasus-&gt;stats.tx_errors++;
 }
diff --git a/drivers/usb/net/rtl8150.c b/drivers/usb/net/rtl8150.c
index 59ab40ebb394..c3d4e3589e30 100644
--- a/drivers/usb/net/rtl8150.c
+++ b/drivers/usb/net/rtl8150.c
@@ -653,7 +653,6 @@ static void rtl8150_tx_timeout(struct net_device *netdev)
 {
 	rtl8150_t *dev = netdev_priv(netdev);
 	warn("%s: Tx timeout.", netdev-&gt;name);
-	dev-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(dev-&gt;tx_urb);
 	dev-&gt;stats.tx_errors++;
 }
diff --git a/drivers/usb/net/usbnet.c b/drivers/usb/net/usbnet.c
index 4682696450db..3c6eef4168e5 100644
--- a/drivers/usb/net/usbnet.c
+++ b/drivers/usb/net/usbnet.c
@@ -2987,7 +2987,6 @@ static void rx_submit (struct usbnet *dev, struct urb *urb, unsigned flags)
 
 	usb_fill_bulk_urb (urb, dev-&gt;udev, dev-&gt;in,
 		skb-&gt;data, size, rx_complete, skb);
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	spin_lock_irqsave (&amp;dev-&gt;rxq.lock, lockflags);
 
@@ -3561,7 +3560,6 @@ static int usbnet_start_xmit (struct sk_buff *skb, struct net_device *net)
 
 	usb_fill_bulk_urb (urb, dev-&gt;udev, dev-&gt;out,
 			skb-&gt;data, skb-&gt;len, tx_complete, skb);
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	/* don't assume the hardware handles USB_ZERO_PACKET
 	 * NOTE:  strictly conforming cdc-ether devices should expect
diff --git a/drivers/usb/net/zd1201.c b/drivers/usb/net/zd1201.c
index fc013978837e..c4e479ee926a 100644
--- a/drivers/usb/net/zd1201.c
+++ b/drivers/usb/net/zd1201.c
@@ -847,7 +847,6 @@ static void zd1201_tx_timeout(struct net_device *dev)
 		return;
 	dev_warn(&amp;zd-&gt;usb-&gt;dev, "%s: TX timeout, shooting down urb\n",
 	    dev-&gt;name);
-	zd-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(zd-&gt;tx_urb);
 	zd-&gt;stats.tx_errors++;
 	/* Restart the timeout to quiet the watchdog: */
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e42875152c34..c1ba5301ebfc 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -96,8 +96,8 @@
  * or before the URB_ACTIVE bit was set.  If so, it's essential to cancel
  * the URB if it hasn't been cancelled already (i.e., if the URB_ACTIVE bit
  * is still set).  Either way, the function must then wait for the URB to
- * finish.  Note that because the URB_ASYNC_UNLINK flag is set, the URB can
- * still be in progress even after a call to usb_unlink_urb() returns.
+ * finish.  Note that the URB can still be in progress even after a call to
+ * usb_unlink_urb() returns.
  *
  * The idea is that (1) once the ABORTING or DISCONNECTING bit is set,
  * either the stop_transport() function or the submitting function
@@ -158,8 +158,7 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	 * hasn't been mapped for DMA.  Yes, this is clunky, but it's
 	 * easier than always having the caller tell us whether the
 	 * transfer buffer has already been mapped. */
-	us-&gt;current_urb-&gt;transfer_flags =
-			URB_ASYNC_UNLINK | URB_NO_SETUP_DMA_MAP;
+	us-&gt;current_urb-&gt;transfer_flags = URB_NO_SETUP_DMA_MAP;
 	if (us-&gt;current_urb-&gt;transfer_buffer == us-&gt;iobuf)
 		us-&gt;current_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	us-&gt;current_urb-&gt;transfer_dma = us-&gt;iobuf_dma;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 434e35120c65..4dbe580f9335 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -616,7 +616,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
-#define URB_ASYNC_UNLINK	0x0010	/* usb_unlink_urb() returns asap */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
@@ -724,13 +723,7 @@ typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
  * Initialization:
  *
  * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
- * zero), and complete fields.
- * The URB_ASYNC_UNLINK transfer flag affects later invocations of
- * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK
- * with usb_unlink_urb() is deprecated.  For synchronous unlinks use
- * usb_kill_urb() instead.
- *
- * All URBs must also initialize 
+ * zero), and complete fields.  All URBs must also initialize
  * transfer_buffer and transfer_buffer_length.  They may provide the
  * URB_SHORT_NOT_OK transfer flag, indicating that short reads are
  * to be treated as errors; that flag is invalid for write requests.
diff --git a/sound/usb/usbaudio.c b/sound/usb/usbaudio.c
index 5aa5fe651a8a..bfbec5876659 100644
--- a/sound/usb/usbaudio.c
+++ b/sound/usb/usbaudio.c
@@ -735,10 +735,9 @@ static int deactivate_urbs(snd_usb_substream_t *subs, int force, int can_sleep)
 		if (test_bit(i, &amp;subs-&gt;active_mask)) {
 			if (! test_and_set_bit(i, &amp;subs-&gt;unlink_mask)) {
 				struct urb *u = subs-&gt;dataurb[i].urb;
-				if (async) {
-					u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
+				if (async)
 					usb_unlink_urb(u);
-				} else
+				else
 					usb_kill_urb(u);
 			}
 		}
@@ -748,10 +747,9 @@ static int deactivate_urbs(snd_usb_substream_t *subs, int force, int can_sleep)
 			if (test_bit(i+16, &amp;subs-&gt;active_mask)) {
  				if (! test_and_set_bit(i+16, &amp;subs-&gt;unlink_mask)) {
 					struct urb *u = subs-&gt;syncurb[i].urb;
-					if (async) {
-						u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
+					if (async)
 						usb_unlink_urb(u);
-					} else
+					else
 						usb_kill_urb(u);
 				}
 			}</pre><hr><pre>commit fad21bdf56a25e1cb3e92bba33349de368e8f0b0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 15:15:57 2005 -0400

    [PATCH] USB: Fix regression in core/devio.c
    
    This patch (as551) fixes another little problem recently added to the
    USB core.  Someone didn't fix the type of the first argument to
    unregister_chrdev_region.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index d12bc5e84a1a..56c082f34927 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -76,6 +76,8 @@ MODULE_PARM_DESC (usbfs_snoop, "true to log all usbfs traffic");
 			dev_info( dev , format , ## arg);	\
 	} while (0)
 
+#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
+
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
@@ -1530,18 +1532,17 @@ int __init usbdev_init(void)
 {
 	int retval;
 
-	retval = register_chrdev_region(MKDEV(USB_DEVICE_MAJOR, 0),
-				        USB_DEVICE_MAX, "usb_device");
+	retval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,
+			"usb_device");
 	if (retval) {
 		err("unable to register minors for usb_device");
 		goto out;
 	}
 	cdev_init(&amp;usb_device_cdev, &amp;usbfs_device_file_operations);
-	retval = cdev_add(&amp;usb_device_cdev,
-			  MKDEV(USB_DEVICE_MAJOR, 0), USB_DEVICE_MAX);
+	retval = cdev_add(&amp;usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);
 	if (retval) {
 		err("unable to get usb_device major %d", USB_DEVICE_MAJOR);
-		unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+		unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 		goto out;
 	}
 	usb_device_class = class_create(THIS_MODULE, "usb_device");
@@ -1550,7 +1551,7 @@ int __init usbdev_init(void)
 		retval = PTR_ERR(usb_device_class);
 		usb_device_class = NULL;
 		cdev_del(&amp;usb_device_cdev);
-		unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+		unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 	}
 
 out:
@@ -1561,6 +1562,6 @@ void usbdev_cleanup(void)
 {
 	class_destroy(usb_device_class);
 	cdev_del(&amp;usb_device_cdev);
-	unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+	unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 }
 </pre><hr><pre>commit 11f3859b1e85dd408756c72e228cfb5aa7230c87
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 15:18:44 2005 -0400

    [PATCH] PCI: Fix regression in pci_enable_device_bars
    
    This patch (as552) fixes yet another small problem recently added.  If an
    attempt to put a PCI device back into D0 fails because the device doesn't
    support PCI PM, it shouldn't count as error.  Without this patch the UHCI
    controllers on my Intel motherboard don't work.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index afee2de3f323..3dcb83d7eb25 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -445,7 +445,7 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	int err;
 
 	err = pci_set_power_state(dev, PCI_D0);
-	if (err)
+	if (err &lt; 0 &amp;&amp; err != -EIO)
 		return err;
 	err = pcibios_enable_device(dev, bars);
 	if (err &lt; 0)</pre><hr><pre>commit 4451e472627881e3e2240b224f127c99be500f91
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 12 10:45:17 2005 -0400

    [SCSI] sd: pause in sd_spinup_disk for slow USB devices
    
    This patch adds a delay tailored for USB flash devices that are slow to
    initialize their firmware.  The symptom is a repeated Unit Attention with
    ASC=0x28 (Not Ready to Ready transition).  The patch will wait for up to 5
    seconds for such devices to become ready.  Normal devices won't send the
    repeated Unit Attention sense key and hence won't trigger the patch.
    
    This fixes a problem with James Roberts-Thomson's USB device, and I've
    seen several reports of other devices exhibiting the same symptoms --
    presumably they will be helped as well.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 0410e1bf109a..41ba0809f791 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -984,7 +984,7 @@ static void
 sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 	       struct scsi_request *SRpnt, unsigned char *buffer) {
 	unsigned char cmd[10];
-	unsigned long spintime_value = 0;
+	unsigned long spintime_expire = 0;
 	int retries, spintime;
 	unsigned int the_result;
 	struct scsi_sense_hdr sshdr;
@@ -1071,12 +1071,27 @@ sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 				scsi_wait_req(SRpnt, (void *)cmd, 
 					      (void *) buffer, 0/*512*/, 
 					      SD_TIMEOUT, SD_MAX_RETRIES);
-				spintime_value = jiffies;
+				spintime_expire = jiffies + 100 * HZ;
+				spintime = 1;
 			}
-			spintime = 1;
 			/* Wait 1 second for next try */
 			msleep(1000);
 			printk(".");
+
+		/*
+		 * Wait for USB flash devices with slow firmware.
+		 * Yes, this sense key/ASC combination shouldn't
+		 * occur here.  It's characteristic of these devices.
+		 */
+		} else if (sense_valid &amp;&amp;
+				sshdr.sense_key == UNIT_ATTENTION &amp;&amp;
+				sshdr.asc == 0x28) {
+			if (!spintime) {
+				spintime_expire = jiffies + 5 * HZ;
+				spintime = 1;
+			}
+			/* Wait 1 second for next try */
+			msleep(1000);
 		} else {
 			/* we don't understand the sense code, so it's
 			 * probably pointless to loop */
@@ -1088,8 +1103,7 @@ sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 			break;
 		}
 				
-	} while (spintime &amp;&amp;
-		 time_after(spintime_value + 100 * HZ, jiffies));
+	} while (spintime &amp;&amp; time_before_eq(jiffies, spintime_expire));
 
 	if (spintime) {
 		if (scsi_status_is_good(the_result))</pre><hr><pre>commit e47373ec1c9aab9ee134f4e2b8249957e9f4c7ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 30 15:05:45 2005 -0500

    [SCSI] return success after retries in scsi_eh_tur
    
    The problem lies in the way the error handler uses TEST UNIT READY to
    tell whether error recovery has succeeded.  The scsi_eh_tur function
    gives up after one round of retrying; after that it decides that more
    error recovery is needed.
    
    However TUR is liable to report sense data indicating a retry is needed
    when in fact error recovery has succeeded.  A typical example might be
    SK=2, ASC=4, ASCQ=1 (Logical unit in process of becoming ready).  The mere
    fact that we were able to get a sensible reply to the TUR should indicate
    that the device is working well enough to stop error recovery.
    
    I ran across a case back in January where this happened.  A CD-ROM drive
    timed out the INQUIRY command, and a device reset fixed the blockage.
    But then the drive kept responding with 2/4/1 -- because it was spinning
    up I suppose -- until the error handler gave up and placed it offline.
    If the initial INQUIRY had received the 2/4/1 instead, everything would
    have worked okay.  It doesn't seem reasonable for things to fail just
    because the error handler had started running.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index e9c451ba71fc..688bce740786 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -776,9 +776,11 @@ static int scsi_eh_tur(struct scsi_cmnd *scmd)
 		__FUNCTION__, scmd, rtn));
 	if (rtn == SUCCESS)
 		return 0;
-	else if (rtn == NEEDS_RETRY)
+	else if (rtn == NEEDS_RETRY) {
 		if (retry_cnt--)
 			goto retry_tur;
+		return 0;
+	}
 	return 1;
 }
 </pre><hr><pre>commit 86d30741e480f40676c2173e1153368a4846da48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 12:17:16 2005 -0700

    [PATCH] USB: Usbcore: Don't try to delete unregistered interfaces
    
    This patch handles a rarely-encountered failure mode in usbcore.  It's
    legal for device_add to fail (although now it happens even more rarely
    than before since failure to bind a driver is no longer fatal).  So when
    we destroy the interfaces in a configuration, we shouldn't try to delete
    ones which weren't successfully registered.  Also, failure to register an
    interface shouldn't be fatal either -- I think; you may disagree about
    this part of the patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a428ef479bd7..88d1b376f67c 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -985,8 +985,10 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
 
-			/* remove this interface */
+			/* remove this interface if it has been registered */
 			interface = dev-&gt;actconfig-&gt;interface[i];
+			if (!klist_node_attached(&amp;interface-&gt;dev.knode_bus))
+				continue;
 			dev_dbg (&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
 			usb_remove_sysfs_intf_files(interface);
@@ -1439,7 +1441,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 	}
 
-	return ret;
+	return 0;
 }
 
 // synchronous request completion model</pre><hr><pre>commit fe0410c7f43e133e156e54e3156392e800bedc21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 12:16:58 2005 -0700

    [PATCH] USB: usbfs: Don't leak uninitialized data
    
    This patch fixes an information leak in the usbfs snoop facility:
    uninitialized data from __get_free_page can be returned to userspace and
    written to the system log.  It also improves the snoop output by printing
    the wLength value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 787c27a63c51..f86bf1454e21 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -569,8 +569,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 			free_page((unsigned long)tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
+		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x "
+				"bRrequestType=%02x wValue=%04x "
+				"wIndex=%04x wLength=%04x\n",
+			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
+				ctrl.wIndex, ctrl.wLength);
 
 		usb_unlock_device(dev);
 		i = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), ctrl.bRequest, ctrl.bRequestType,
@@ -579,11 +582,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 		if ((i &gt; 0) &amp;&amp; ctrl.wLength) {
 			if (usbfs_snoop) {
 				dev_info(&amp;dev-&gt;dev, "control read: data ");
-				for (j = 0; j &lt; ctrl.wLength; ++j)
+				for (j = 0; j &lt; i; ++j)
 					printk ("%02x ", (unsigned char)(tbuf)[j]);
 				printk("\n");
 			}
-			if (copy_to_user(ctrl.data, tbuf, ctrl.wLength)) {
+			if (copy_to_user(ctrl.data, tbuf, i)) {
 				free_page((unsigned long)tbuf);
 				return -EFAULT;
 			}
@@ -595,8 +598,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
+		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x "
+				"bRrequestType=%02x wValue=%04x "
+				"wIndex=%04x wLength=%04x\n",
+			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
+				ctrl.wIndex, ctrl.wLength);
 		if (usbfs_snoop) {
 			dev_info(&amp;dev-&gt;dev, "control write: data: ");
 			for (j = 0; j &lt; ctrl.wLength; ++j)</pre><hr><pre>commit b24b1033451fcc87087a692fc47ca45daebd51ac
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 27 11:43:46 2005 -0700

    [PATCH] scsi_scan: check return code from scsi_sysfs_add_sdev
    
    Adds a missing check for an error return code from scsi_sysfs_add_sdev.
    This resolves entry #4863 in the OSDL bugzilla.  Although in that bug
    report the failure occurred because of a confusion over scanning vs.
    rescanning, in general add_sdev can fail for a number of reasons (the
    simplest being insufficient memory) and the caller should cope properly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index ad3a5b142468..2d3c4ac475f2 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -756,7 +756,8 @@ static int scsi_add_lun(struct scsi_device *sdev, char *inq_result, int *bflags)
 	 * register it and tell the rest of the kernel
 	 * about it.
 	 */
-	scsi_sysfs_add_sdev(sdev);
+	if (scsi_sysfs_add_sdev(sdev) != 0)
+		return SCSI_SCAN_NO_RESPONSE;
 
 	return SCSI_SCAN_LUN_PRESENT;
 }</pre><hr><pre>commit 0ed0c0c48c508578c30aa58f755ca0d692636906
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 15:49:48 2005 -0400

    [PATCH] USB: usbcore: inverted test for resuming interfaces
    
    This one-liner fixes a test for interfaces that are already resumed.
    
    It would be nice if this could get into 2.6.12, but it's not critical
    since it only affects people doing selective (runtime) suspend/resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 63ee3d97b6a9..32ff32181852 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1733,7 +1733,7 @@ static int finish_port_resume(struct usb_device *udev)
 			struct usb_driver	*driver;
 
 			intf = udev-&gt;actconfig-&gt;interface[i];
-			if (intf-&gt;dev.power.power_state == PMSG_SUSPEND)
+			if (intf-&gt;dev.power.power_state == PMSG_ON)
 				continue;
 			if (!intf-&gt;dev.driver) {
 				/* FIXME maybe force to alt 0 */</pre><hr><pre>commit e07fefa6b212f43c40fdbc1a62de690d91a4b617
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 31 16:33:21 2005 -0400

    [PATCH] USB UHCI: Detect invalid ports
    
    This patch changes the way uhci-hcd detects valid ports.  The
    specification doesn't mention any way to find out how many ports a
    controller has, so the driver has to use some heuristics, reading the port
    status and control register and deciding whether the value makes sense.
    With this patch the driver will recognize a typical failure mode (all bits
    set to one) for nonexistent ports and won't assume there are always at
    least 2 ports -- such an assumption seems silly if the heuristics have
    already shown that the ports don't exist.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fdf54295da73..0d5d2545bf07 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -495,24 +495,24 @@ static int uhci_reset(struct usb_hcd *hcd)
 
 	/* The UHCI spec says devices must have 2 ports, and goes on to say
 	 * they may have more but gives no way to determine how many there
-	 * are.  However, according to the UHCI spec, Bit 7 of the port
+	 * are.  However according to the UHCI spec, Bit 7 of the port
 	 * status and control register is always set to 1.  So we try to
-	 * use this to our advantage.
+	 * use this to our advantage.  Another common failure mode when
+	 * a nonexistent register is addressed is to return all ones, so
+	 * we test for that also.
 	 */
 	for (port = 0; port &lt; (io_size - USBPORTSC1) / 2; port++) {
 		unsigned int portstatus;
 
 		portstatus = inw(uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
-		if (!(portstatus &amp; 0x0080))
+		if (!(portstatus &amp; 0x0080) || portstatus == 0xffff)
 			break;
 	}
 	if (debug)
 		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
 
-	/* Anything less than 2 or greater than 7 is weird,
-	 * so we'll ignore it.
-	 */
-	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
+	/* Anything greater than 7 is weird so we'll ignore it. */
+	if (port &gt; UHCI_RH_MAXCHILD) {
 		dev_info(uhci_dev(uhci), "port count misdetected? "
 				"forcing to 2 ports\n");
 		port = 2;</pre>
    <div class="pagination">
        <a href='2_136.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><span>[137]</span><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_138.html'>Next&gt;&gt;</a>
    <div>
</body>
