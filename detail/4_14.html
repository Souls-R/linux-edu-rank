<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_13.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><span>[14]</span><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_15.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4dc6ec00f6347b72312fa41dfc587d5302b05544
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Apr 19 15:11:28 2010 -0400

    nfsd4: implement reclaim_complete
    
    This is a mandatory operation.  Also, here (not in open) is where we
    should be committing the reboot recovery information.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/Documentation/filesystems/nfs/nfs41-server.txt b/Documentation/filesystems/nfs/nfs41-server.txt
index 6a53a84afc72..04884914a1c8 100644
--- a/Documentation/filesystems/nfs/nfs41-server.txt
+++ b/Documentation/filesystems/nfs/nfs41-server.txt
@@ -137,7 +137,7 @@ NS*| OPENATTR             | OPT        |              | Section 18.17  |
    | READ                 | REQ        |              | Section 18.22  |
    | READDIR              | REQ        |              | Section 18.23  |
    | READLINK             | OPT        |              | Section 18.24  |
-NS | RECLAIM_COMPLETE     | REQ        |              | Section 18.51  |
+   | RECLAIM_COMPLETE     | REQ        |              | Section 18.51  |
    | RELEASE_LOCKOWNER    | MNI        |              | N/A            |
    | REMOVE               | REQ        |              | Section 18.25  |
    | RENAME               | REQ        |              | Section 18.26  |
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index e2dc9608281b..59ec449b0c7f 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -1312,6 +1312,11 @@ static struct nfsd4_operation nfsd4_ops[] = {
 		.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,
 		.op_name = "OP_SEQUENCE",
 	},
+	[OP_RECLAIM_COMPLETE] = {
+		.op_func = (nfsd4op_func)nfsd4_reclaim_complete,
+		.op_flags = ALLOWED_WITHOUT_FH,
+		.op_name = "OP_RECLAIM_COMPLETE",
+	},
 };
 
 static const char *nfsd4_op_name(unsigned opnum)
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index ede9dde52fe8..84b0fe9a262a 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1501,6 +1501,35 @@ nfsd4_sequence(struct svc_rqst *rqstp,
 	return status;
 }
 
+__be32
+nfsd4_reclaim_complete(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_reclaim_complete *rc)
+{
+	if (rc-&gt;rca_one_fs) {
+		if (!cstate-&gt;current_fh.fh_dentry)
+			return nfserr_nofilehandle;
+		/*
+		 * We don't take advantage of the rca_one_fs case.
+		 * That's OK, it's optional, we can safely ignore it.
+		 */
+		 return nfs_ok;
+	}
+	nfs4_lock_state();
+	if (is_client_expired(cstate-&gt;session-&gt;se_client)) {
+		nfs4_unlock_state();
+		/*
+		 * The following error isn't really legal.
+		 * But we only get here if the client just explicitly
+		 * destroyed the client.  Surely it no longer cares what
+		 * error it gets back on an operation for the dead
+		 * client.
+		 */
+		return nfserr_stale_clientid;
+	}
+	nfsd4_create_clid_dir(cstate-&gt;session-&gt;se_client);
+	nfs4_unlock_state();
+	return nfs_ok;
+}
+
 __be32
 nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		  struct nfsd4_setclientid *setclid)
@@ -2510,10 +2539,8 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	}
 	memcpy(&amp;open-&gt;op_stateid, &amp;stp-&gt;st_stateid, sizeof(stateid_t));
 
-	if (nfsd4_has_session(&amp;resp-&gt;cstate)) {
+	if (nfsd4_has_session(&amp;resp-&gt;cstate))
 		open-&gt;op_stateowner-&gt;so_confirmed = 1;
-		nfsd4_create_clid_dir(open-&gt;op_stateowner-&gt;so_client);
-	}
 
 	/*
 	* Attempt to hand out a delegation. No error return, because the
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 126d0caabb3c..ac17a7080239 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1234,6 +1234,16 @@ nfsd4_decode_sequence(struct nfsd4_compoundargs *argp,
 	DECODE_TAIL;
 }
 
+static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)
+{
+	DECODE_HEAD;
+
+	READ_BUF(4);
+	READ32(rc-&gt;rca_one_fs);
+
+	DECODE_TAIL;
+}
+
 static __be32
 nfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)
 {
@@ -1346,7 +1356,7 @@ static nfsd4_dec nfsd41_dec_ops[] = {
 	[OP_TEST_STATEID]	= (nfsd4_dec)nfsd4_decode_notsupp,
 	[OP_WANT_DELEGATION]	= (nfsd4_dec)nfsd4_decode_notsupp,
 	[OP_DESTROY_CLIENTID]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_RECLAIM_COMPLETE]	= (nfsd4_dec)nfsd4_decode_notsupp,
+	[OP_RECLAIM_COMPLETE]	= (nfsd4_dec)nfsd4_decode_reclaim_complete,
 };
 
 struct nfsd4_minorversion_ops {
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index c28958ec216c..4d476ff08ae6 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -381,6 +381,10 @@ struct nfsd4_destroy_session {
 	struct nfs4_sessionid	sessionid;
 };
 
+struct nfsd4_reclaim_complete {
+	u32 rca_one_fs;
+};
+
 struct nfsd4_op {
 	int					opnum;
 	__be32					status;
@@ -421,6 +425,7 @@ struct nfsd4_op {
 		struct nfsd4_create_session	create_session;
 		struct nfsd4_destroy_session	destroy_session;
 		struct nfsd4_sequence		sequence;
+		struct nfsd4_reclaim_complete	reclaim_complete;
 	} u;
 	struct nfs4_replay *			replay;
 };
@@ -523,6 +528,7 @@ extern __be32 nfsd4_sequence(struct svc_rqst *,
 extern __be32 nfsd4_destroy_session(struct svc_rqst *,
 		struct nfsd4_compound_state *,
 		struct nfsd4_destroy_session *);
+__be32 nfsd4_reclaim_complete(struct svc_rqst *, struct nfsd4_compound_state *, struct nfsd4_reclaim_complete *);
 extern __be32 nfsd4_process_open1(struct nfsd4_compound_state *,
 		struct nfsd4_open *open);
 extern __be32 nfsd4_process_open2(struct svc_rqst *rqstp,</pre><hr><pre>commit 5d4cec2f2fdbb3d830fa014226d0d965df548bad
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat May 1 12:56:06 2010 -0400

    nfsd4: fix bare destroy_session null dereference
    
    It's legal to send a DESTROY_SESSION outside any session (as the only
    operation in a compound), in which case cstate-&gt;session will be NULL;
    check for that case.
    
    While we're at it, move these checks into a separate helper function.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index f05a3276ba6b..835d6cef9ae9 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1352,6 +1352,13 @@ static bool nfsd4_last_compound_op(struct svc_rqst *rqstp)
 	return argp-&gt;opcnt == resp-&gt;opcnt;
 }
 
+static bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)
+{
+	if (!session)
+		return 0;
+	return !memcmp(sid, &amp;session-&gt;se_sessionid, sizeof(*sid));
+}
+
 __be32
 nfsd4_destroy_session(struct svc_rqst *r,
 		      struct nfsd4_compound_state *cstate,
@@ -1367,8 +1374,7 @@ nfsd4_destroy_session(struct svc_rqst *r,
 	 * - Do we need to clear any callback info from previous session?
 	 */
 
-	if (!memcmp(&amp;sessionid-&gt;sessionid, &amp;cstate-&gt;session-&gt;se_sessionid,
-					sizeof(struct nfs4_sessionid))) {
+	if (nfsd4_compound_in_session(cstate-&gt;session, &amp;sessionid-&gt;sessionid)) {
 		if (!nfsd4_last_compound_op(r))
 			return nfserr_not_only_op;
 	}</pre><hr><pre>commit 5306293c9cd2caf41849cc909281bda628bb989e
Merge: dbd65a7e44ff 66f41d4c5c8a
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue May 4 11:27:05 2010 -0400

    Merge commit 'v2.6.34-rc6'
    
    Conflicts:
            fs/nfsd/nfs4callback.c

diff --cc fs/nfsd/nfs4callback.c
index ea77aa63754a,7e32bd394e86..1d5051d46b46
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@@ -32,7 -32,7 +32,8 @@@
   */
  
  #include &lt;linux/sunrpc/clnt.h&gt;
 +#include &lt;linux/sunrpc/svc_xprt.h&gt;
+ #include &lt;linux/slab.h&gt;
  #include "nfsd.h"
  #include "state.h"
  </pre><hr><pre>commit fb4b698fc78347419aa9ae7114e1375f92107500
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Apr 28 17:45:06 2010 -0400

    nfsd: further comment typos
    
    Whoops, missed some more.
    
    "Reviewed-by, I guess": Chuck Lever &lt;chuck.lever@oracle.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/nfsd/nfsfh.h b/include/linux/nfsd/nfsfh.h
index 45bb5a8102c1..80d55bbc5365 100644
--- a/include/linux/nfsd/nfsfh.h
+++ b/include/linux/nfsd/nfsfh.h
@@ -40,12 +40,12 @@ struct nfs_fhbase_old {
  * This is the new flexible, extensible style NFSv2/v3 file handle.
  * by Neil Brown &lt;neilb@cse.unsw.edu.au&gt; - March 2000
  *
- * The file handle is seens as a list of four-byte words.
+ * The file handle starts with a sequence of four-byte words.
  * The first word contains a version number (1) and three descriptor bytes
  * that tell how the remaining 3 variable length fields should be handled.
  * These three bytes are auth_type, fsid_type and fileid_type.
  *
- * All 4byte values are in host-byte-order.
+ * All four-byte values are in host-byte-order.
  *
  * The auth_type field specifies how the filehandle can be authenticated
  * This might allow a file to be confirmed to be in a writable part of a</pre><hr><pre>commit 26c0c75e69265961e891ed80b38fb62a548ab371
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat Apr 24 15:35:43 2010 -0400

    nfsd4: fix unlikely race in session replay case
    
    In the replay case, the
    
            renew_client(session-&gt;se_client);
    
    happens after we've droppped the sessionid_lock, and without holding a
    reference on the session; so there's nothing preventing the session
    being freed before we get here.
    
    Thanks to Benny Halevy for catching a bug in an earlier version of this
    patch.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Acked-by: Benny Halevy &lt;bhalevy@panasas.com&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index e147dbcb7ef7..61282f8405b5 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -1027,6 +1027,7 @@ nfsd4_proc_compound(struct svc_rqst *rqstp,
 	resp-&gt;rqstp = rqstp;
 	resp-&gt;cstate.minorversion = args-&gt;minorversion;
 	resp-&gt;cstate.replay_owner = NULL;
+	resp-&gt;cstate.session = NULL;
 	fh_init(&amp;resp-&gt;cstate.current_fh, NFS4_FHSIZE);
 	fh_init(&amp;resp-&gt;cstate.save_fh, NFS4_FHSIZE);
 	/* Use the deferral mechanism only for NFSv4.0 compounds */
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index bba9fff49cfe..737315c61e7e 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1443,11 +1443,10 @@ nfsd4_sequence(struct svc_rqst *rqstp,
 	cstate-&gt;slot = slot;
 	cstate-&gt;session = session;
 
-	/* Hold a session reference until done processing the compound:
-	 * nfsd4_put_session called only if the cstate slot is set.
-	 */
-	nfsd4_get_session(session);
 out:
+	/* Hold a session reference until done processing the compound. */
+	if (cstate-&gt;session)
+		nfsd4_get_session(cstate-&gt;session);
 	spin_unlock(&amp;sessionid_lock);
 	/* Renew the clientid on success and on replay */
 	if (cstate-&gt;session) {
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index fb27b1db007b..05bc5bd63c95 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -3306,10 +3306,12 @@ nfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compo
 		iov = &amp;rqstp-&gt;rq_res.head[0];
 	iov-&gt;iov_len = ((char*)resp-&gt;p) - (char*)iov-&gt;iov_base;
 	BUG_ON(iov-&gt;iov_len &gt; PAGE_SIZE);
-	if (nfsd4_has_session(cs) &amp;&amp; cs-&gt;status != nfserr_replay_cache) {
-		nfsd4_store_cache_entry(resp);
-		dprintk("%s: SET SLOT STATE TO AVAILABLE\n", __func__);
-		resp-&gt;cstate.slot-&gt;sl_inuse = false;
+	if (nfsd4_has_session(cs)) {
+		if (cs-&gt;status != nfserr_replay_cache) {
+			nfsd4_store_cache_entry(resp);
+			dprintk("%s: SET SLOT STATE TO AVAILABLE\n", __func__);
+			resp-&gt;cstate.slot-&gt;sl_inuse = false;
+		}
 		nfsd4_put_session(resp-&gt;cstate.session);
 	}
 	return 1;</pre><hr><pre>commit e0c8233622cbd49d171bc57b60e725f2fb748750
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Apr 22 17:04:25 2010 -0400

    nfsd4: fix filehandle comment
    
    Minor typos.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/nfsd/nfsfh.h b/include/linux/nfsd/nfsfh.h
index 65e333afaee4..45bb5a8102c1 100644
--- a/include/linux/nfsd/nfsfh.h
+++ b/include/linux/nfsd/nfsfh.h
@@ -40,8 +40,8 @@ struct nfs_fhbase_old {
  * This is the new flexible, extensible style NFSv2/v3 file handle.
  * by Neil Brown &lt;neilb@cse.unsw.edu.au&gt; - March 2000
  *
- * The file handle is seens as a list of 4byte words.
- * The first word contains a version number (1) and four descriptor bytes
+ * The file handle is seens as a list of four-byte words.
+ * The first word contains a version number (1) and three descriptor bytes
  * that tell how the remaining 3 variable length fields should be handled.
  * These three bytes are auth_type, fsid_type and fileid_type.
  *</pre><hr><pre>commit 5771635592267758e7dc5647f2a0088aa6244159
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Apr 21 12:27:19 2010 -0400

    nfsd4: complete enforcement of 4.1 op ordering
    
    Enforce the rules about compound op ordering.
    
    Motivated by implementing RECLAIM_COMPLETE, for which the client is
    implicit in the current session, so it is important to ensure a
    succesful SEQUENCE proceeds the RECLAIM_COMPLETE.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 37514c469846..e147dbcb7ef7 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -968,20 +968,36 @@ static struct nfsd4_operation nfsd4_ops[];
 static const char *nfsd4_op_name(unsigned opnum);
 
 /*
- * Enforce NFSv4.1 COMPOUND ordering rules.
+ * Enforce NFSv4.1 COMPOUND ordering rules:
  *
- * TODO:
- * - enforce NFS4ERR_NOT_ONLY_OP,
- * - DESTROY_SESSION MUST be the final operation in the COMPOUND request.
+ * Also note, enforced elsewhere:
+ *	- SEQUENCE other than as first op results in
+ *	  NFS4ERR_SEQUENCE_POS. (Enforced in nfsd4_sequence().)
+ *	- BIND_CONN_TO_SESSION must be the only op in its compound
+ *	  (Will be enforced in nfsd4_bind_conn_to_session().)
+ *	- DESTROY_SESSION must be the final operation in a compound, if
+ *	  sessionid's in SEQUENCE and DESTROY_SESSION are the same.
+ *	  (Enforced in nfsd4_destroy_session().)
  */
-static bool nfs41_op_ordering_ok(struct nfsd4_compoundargs *args)
+static __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)
 {
-	if (args-&gt;minorversion &amp;&amp; args-&gt;opcnt &gt; 0) {
-		struct nfsd4_op *op = &amp;args-&gt;ops[0];
-		return (op-&gt;status == nfserr_op_illegal) ||
-		       (nfsd4_ops[op-&gt;opnum].op_flags &amp; ALLOWED_AS_FIRST_OP);
-	}
-	return true;
+	struct nfsd4_op *op = &amp;args-&gt;ops[0];
+
+	/* These ordering requirements don't apply to NFSv4.0: */
+	if (args-&gt;minorversion == 0)
+		return nfs_ok;
+	/* This is weird, but OK, not our problem: */
+	if (args-&gt;opcnt == 0)
+		return nfs_ok;
+	if (op-&gt;status == nfserr_op_illegal)
+		return nfs_ok;
+	if (!(nfsd4_ops[op-&gt;opnum].op_flags &amp; ALLOWED_AS_FIRST_OP))
+		return nfserr_op_not_in_session;
+	if (op-&gt;opnum == OP_SEQUENCE)
+		return nfs_ok;
+	if (args-&gt;opcnt != 1)
+		return nfserr_not_only_op;
+	return nfs_ok;
 }
 
 /*
@@ -1023,13 +1039,13 @@ nfsd4_proc_compound(struct svc_rqst *rqstp,
 	if (args-&gt;minorversion &gt; nfsd_supported_minorversion)
 		goto out;
 
-	if (!nfs41_op_ordering_ok(args)) {
+	status = nfs41_check_op_ordering(args);
+	if (status) {
 		op = &amp;args-&gt;ops[0];
-		op-&gt;status = nfserr_sequence_pos;
+		op-&gt;status = status;
 		goto encode_op;
 	}
 
-	status = nfs_ok;
 	while (!status &amp;&amp; resp-&gt;opcnt &lt; args-&gt;opcnt) {
 		op = &amp;args-&gt;ops[resp-&gt;opcnt++];
 
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 4300d9ffe95f..bba9fff49cfe 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1343,6 +1343,14 @@ nfsd4_create_session(struct svc_rqst *rqstp,
 	return status;
 }
 
+static bool nfsd4_last_compound_op(struct svc_rqst *rqstp)
+{
+	struct nfsd4_compoundres *resp = rqstp-&gt;rq_resp;
+	struct nfsd4_compoundargs *argp = rqstp-&gt;rq_argp;
+
+	return argp-&gt;opcnt == resp-&gt;opcnt;
+}
+
 __be32
 nfsd4_destroy_session(struct svc_rqst *r,
 		      struct nfsd4_compound_state *cstate,
@@ -1358,6 +1366,11 @@ nfsd4_destroy_session(struct svc_rqst *r,
 	 * - Do we need to clear any callback info from previous session?
 	 */
 
+	if (!memcmp(&amp;sessionid-&gt;sessionid, &amp;cstate-&gt;session-&gt;se_sessionid,
+					sizeof(struct nfs4_sessionid))) {
+		if (!nfsd4_last_compound_op(r))
+			return nfserr_not_only_op;
+	}
 	dump_sessionid(__func__, &amp;sessionid-&gt;sessionid);
 	spin_lock(&amp;sessionid_lock);
 	ses = find_in_sessionid_hashtbl(&amp;sessionid-&gt;sessionid);</pre><hr><pre>commit 4b21d0defcc9680da8a694e92d5fe8eb668c2c0b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sun Mar 7 23:39:01 2010 -0500

    nfsd4: allow 4.0 clients to change callback path
    
    The rfc allows a client to change the callback parameters, but we didn't
    previously implement it.
    
    Teach the callbacks to rerun themselves (by placing themselves on a
    workqueue) when they recognize that their rpc task has been killed and
    that the callback connection has changed.
    
    Then we can change the callback connection by setting up a new rpc
    client, modifying the nfs4 client to point at it, waiting for any work
    in progress to complete, and then shutting down the old client.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index d6c46a9de422..ea77aa63754a 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -457,9 +457,8 @@ static int max_cb_time(void)
 /* Reference counting, callback cleanup, etc., all look racy as heck.
  * And why is cl_cb_set an atomic? */
 
-int setup_callback_client(struct nfs4_client *clp)
+int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
 {
-	struct nfs4_cb_conn *cb = &amp;clp-&gt;cl_cb_conn;
 	struct rpc_timeout	timeparms = {
 		.to_initval	= max_cb_time(),
 		.to_retries	= 0,
@@ -481,7 +480,7 @@ int setup_callback_client(struct nfs4_client *clp)
 	if (!clp-&gt;cl_principal &amp;&amp; (clp-&gt;cl_flavor &gt;= RPC_AUTH_GSS_KRB5))
 		return -EINVAL;
 	if (cb-&gt;cb_minorversion) {
-		args.bc_xprt = clp-&gt;cl_cb_conn.cb_xprt;
+		args.bc_xprt = cb-&gt;cb_xprt;
 		args.protocol = XPRT_TRANSPORT_BC_TCP;
 	}
 	/* Create RPC client */
@@ -491,7 +490,7 @@ int setup_callback_client(struct nfs4_client *clp)
 			PTR_ERR(client));
 		return PTR_ERR(client);
 	}
-	clp-&gt;cl_cb_client = client;
+	nfsd4_set_callback_client(clp, client);
 	return 0;
 
 }
@@ -548,14 +547,13 @@ void do_probe_callback(struct nfs4_client *clp)
 /*
  * Set up the callback client and put a NFSPROC4_CB_NULL on the wire...
  */
-void
-nfsd4_probe_callback(struct nfs4_client *clp)
+void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
 {
 	int status;
 
 	BUG_ON(atomic_read(&amp;clp-&gt;cl_cb_set));
 
-	status = setup_callback_client(clp);
+	status = setup_callback_client(clp, cb);
 	if (status) {
 		warn_no_callback_path(clp, status);
 		return;
@@ -645,18 +643,32 @@ static void nfsd4_cb_done(struct rpc_task *task, void *calldata)
 	}
 }
 
+
 static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 {
 	struct nfs4_delegation *dp = calldata;
 	struct nfs4_client *clp = dp-&gt;dl_client;
+	struct rpc_clnt *current_rpc_client = clp-&gt;cl_cb_client;
 
 	nfsd4_cb_done(task, calldata);
 
+	if (current_rpc_client == NULL) {
+		/* We're shutting down; give up. */
+		/* XXX: err, or is it ok just to fall through
+		 * and rpc_restart_call? */
+		return;
+	}
+
 	switch (task-&gt;tk_status) {
 	case -EIO:
 		/* Network partition? */
 		atomic_set(&amp;clp-&gt;cl_cb_set, 0);
 		warn_no_callback_path(clp, task-&gt;tk_status);
+		if (current_rpc_client != task-&gt;tk_client) {
+			/* queue a callback on the new connection: */
+			nfsd4_cb_recall(dp);
+			return;
+		}
 	case -EBADHANDLE:
 	case -NFS4ERR_BAD_STATEID:
 		/* Race: client probably got cb_recall
@@ -705,8 +717,7 @@ void nfsd4_destroy_callback_queue(void)
 	destroy_workqueue(callback_wq);
 }
 
-void nfsd4_set_callback_client(struct nfs4_client *clp, struct rpc_clnt
-*new)
+void nfsd4_set_callback_client(struct nfs4_client *clp, struct rpc_clnt *new)
 {
 	struct rpc_clnt *old = clp-&gt;cl_cb_client;
 
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 59c9bd4c89e1..4300d9ffe95f 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1312,7 +1312,7 @@ nfsd4_create_session(struct svc_rqst *rqstp,
 				cstate-&gt;minorversion;
 			unconf-&gt;cl_cb_conn.cb_prog = cr_ses-&gt;callback_prog;
 			unconf-&gt;cl_cb_seq_nr = 1;
-			nfsd4_probe_callback(unconf);
+			nfsd4_probe_callback(unconf, &amp;unconf-&gt;cl_cb_conn);
 		}
 		conf = unconf;
 	} else {
@@ -1605,9 +1605,8 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		if (!same_creds(&amp;conf-&gt;cl_cred, &amp;unconf-&gt;cl_cred))
 			status = nfserr_clid_inuse;
 		else {
-			/* XXX: We just turn off callbacks until we can handle
-			  * change request correctly. */
 			atomic_set(&amp;conf-&gt;cl_cb_set, 0);
+			nfsd4_probe_callback(conf, &amp;unconf-&gt;cl_cb_conn);
 			expire_client(unconf);
 			status = nfs_ok;
 
@@ -1641,7 +1640,7 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 			}
 			move_to_confirmed(unconf);
 			conf = unconf;
-			nfsd4_probe_callback(conf);
+			nfsd4_probe_callback(conf, &amp;conf-&gt;cl_cb_conn);
 			status = nfs_ok;
 		}
 	} else if ((!conf || (conf &amp;&amp; !same_verf(&amp;conf-&gt;cl_confirm, &amp;confirm)))
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index cf43812e6da5..98836fd87f69 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -390,7 +390,7 @@ extern int nfs4_in_grace(void);
 extern __be32 nfs4_check_open_reclaim(clientid_t *clid);
 extern void nfs4_free_stateowner(struct kref *kref);
 extern int set_callback_cred(void);
-extern void nfsd4_probe_callback(struct nfs4_client *clp);
+extern void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *);
 extern void nfsd4_do_callback_rpc(struct work_struct *);
 extern void nfsd4_cb_recall(struct nfs4_delegation *dp);
 extern int nfsd4_create_callback_queue(void);</pre><hr><pre>commit 2bf23875f55af6038a5d1c164a52cec4c24609ba
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Mar 8 12:37:27 2010 -0500

    nfsd4: rearrange cb data structures
    
    Mainly I just want to separate the arguments used for setting up the tcp
    client from the rest.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 5856fc8adb70..d6c46a9de422 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -455,7 +455,7 @@ static int max_cb_time(void)
 }
 
 /* Reference counting, callback cleanup, etc., all look racy as heck.
- * And why is cb_set an atomic? */
+ * And why is cl_cb_set an atomic? */
 
 int setup_callback_client(struct nfs4_client *clp)
 {
@@ -481,7 +481,7 @@ int setup_callback_client(struct nfs4_client *clp)
 	if (!clp-&gt;cl_principal &amp;&amp; (clp-&gt;cl_flavor &gt;= RPC_AUTH_GSS_KRB5))
 		return -EINVAL;
 	if (cb-&gt;cb_minorversion) {
-		args.bc_xprt = clp-&gt;cl_cb_xprt;
+		args.bc_xprt = clp-&gt;cl_cb_conn.cb_xprt;
 		args.protocol = XPRT_TRANSPORT_BC_TCP;
 	}
 	/* Create RPC client */
@@ -491,7 +491,7 @@ int setup_callback_client(struct nfs4_client *clp)
 			PTR_ERR(client));
 		return PTR_ERR(client);
 	}
-	cb-&gt;cb_client = client;
+	clp-&gt;cl_cb_client = client;
 	return 0;
 
 }
@@ -509,7 +509,7 @@ static void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)
 	if (task-&gt;tk_status)
 		warn_no_callback_path(clp, task-&gt;tk_status);
 	else
-		atomic_set(&amp;clp-&gt;cl_cb_conn.cb_set, 1);
+		atomic_set(&amp;clp-&gt;cl_cb_set, 1);
 }
 
 static const struct rpc_call_ops nfsd4_cb_probe_ops = {
@@ -531,7 +531,6 @@ int set_callback_cred(void)
 
 void do_probe_callback(struct nfs4_client *clp)
 {
-	struct nfs4_cb_conn *cb = &amp;clp-&gt;cl_cb_conn;
 	struct rpc_message msg = {
 		.rpc_proc       = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],
 		.rpc_argp       = clp,
@@ -539,7 +538,7 @@ void do_probe_callback(struct nfs4_client *clp)
 	};
 	int status;
 
-	status = rpc_call_async(cb-&gt;cb_client, &amp;msg,
+	status = rpc_call_async(clp-&gt;cl_cb_client, &amp;msg,
 				RPC_TASK_SOFT | RPC_TASK_SOFTCONN,
 				&amp;nfsd4_cb_probe_ops, (void *)clp);
 	if (status)
@@ -554,7 +553,7 @@ nfsd4_probe_callback(struct nfs4_client *clp)
 {
 	int status;
 
-	BUG_ON(atomic_read(&amp;clp-&gt;cl_cb_conn.cb_set));
+	BUG_ON(atomic_read(&amp;clp-&gt;cl_cb_set));
 
 	status = setup_callback_client(clp);
 	if (status) {
@@ -656,7 +655,7 @@ static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 	switch (task-&gt;tk_status) {
 	case -EIO:
 		/* Network partition? */
-		atomic_set(&amp;clp-&gt;cl_cb_conn.cb_set, 0);
+		atomic_set(&amp;clp-&gt;cl_cb_set, 0);
 		warn_no_callback_path(clp, task-&gt;tk_status);
 	case -EBADHANDLE:
 	case -NFS4ERR_BAD_STATEID:
@@ -673,7 +672,7 @@ static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 		rpc_restart_call(task);
 		return;
 	} else {
-		atomic_set(&amp;clp-&gt;cl_cb_conn.cb_set, 0);
+		atomic_set(&amp;clp-&gt;cl_cb_set, 0);
 		warn_no_callback_path(clp, task-&gt;tk_status);
 	}
 }
@@ -709,11 +708,11 @@ void nfsd4_destroy_callback_queue(void)
 void nfsd4_set_callback_client(struct nfs4_client *clp, struct rpc_clnt
 *new)
 {
-	struct rpc_clnt *old = clp-&gt;cl_cb_conn.cb_client;
+	struct rpc_clnt *old = clp-&gt;cl_cb_client;
 
-	clp-&gt;cl_cb_conn.cb_client = new;
+	clp-&gt;cl_cb_client = new;
 	/*
-	 * After this, any work that saw the old value of cb_client will
+	 * After this, any work that saw the old value of cl_cb_client will
 	 * be gone:
 	 */
 	flush_workqueue(callback_wq);
@@ -728,7 +727,7 @@ void nfsd4_set_callback_client(struct nfs4_client *clp, struct rpc_clnt
 static void _nfsd4_cb_recall(struct nfs4_delegation *dp)
 {
 	struct nfs4_client *clp = dp-&gt;dl_client;
-	struct rpc_clnt *clnt = clp-&gt;cl_cb_conn.cb_client;
+	struct rpc_clnt *clnt = clp-&gt;cl_cb_client;
 	struct nfs4_rpc_args *args = &amp;dp-&gt;dl_recall.cb_args;
 	struct rpc_message msg = {
 		.rpc_proc = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index cf650cbb814b..59c9bd4c89e1 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -726,8 +726,8 @@ expire_client(struct nfs4_client *clp)
 		release_session(ses);
 	}
 	nfsd4_set_callback_client(clp, NULL);
-	if (clp-&gt;cl_cb_xprt)
-		svc_xprt_put(clp-&gt;cl_cb_xprt);
+	if (clp-&gt;cl_cb_conn.cb_xprt)
+		svc_xprt_put(clp-&gt;cl_cb_conn.cb_xprt);
 	free_client(clp);
 }
 
@@ -814,7 +814,7 @@ static struct nfs4_client *create_client(struct xdr_netobj name, char *recdir,
 	}
 
 	memcpy(clp-&gt;cl_recdir, recdir, HEXDIR_LEN);
-	atomic_set(&amp;clp-&gt;cl_cb_conn.cb_set, 0);
+	atomic_set(&amp;clp-&gt;cl_cb_set, 0);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_idhash);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_strhash);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_openowners);
@@ -1302,8 +1302,8 @@ nfsd4_create_session(struct svc_rqst *rqstp,
 		move_to_confirmed(unconf);
 
 		if (cr_ses-&gt;flags &amp; SESSION4_BACK_CHAN) {
-			unconf-&gt;cl_cb_xprt = rqstp-&gt;rq_xprt;
-			svc_xprt_get(unconf-&gt;cl_cb_xprt);
+			unconf-&gt;cl_cb_conn.cb_xprt = rqstp-&gt;rq_xprt;
+			svc_xprt_get(rqstp-&gt;rq_xprt);
 			rpc_copy_addr(
 				(struct sockaddr *)&amp;unconf-&gt;cl_cb_conn.cb_addr,
 				sa);
@@ -1607,7 +1607,7 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		else {
 			/* XXX: We just turn off callbacks until we can handle
 			  * change request correctly. */
-			atomic_set(&amp;conf-&gt;cl_cb_conn.cb_set, 0);
+			atomic_set(&amp;conf-&gt;cl_cb_set, 0);
 			expire_client(unconf);
 			status = nfs_ok;
 
@@ -2320,7 +2320,7 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 {
 	struct nfs4_delegation *dp;
 	struct nfs4_stateowner *sop = stp-&gt;st_stateowner;
-	struct nfs4_cb_conn *cb = &amp;sop-&gt;so_client-&gt;cl_cb_conn;
+	int cb_up = atomic_read(&amp;sop-&gt;so_client-&gt;cl_cb_set);
 	struct file_lock fl, *flp = &amp;fl;
 	int status, flag = 0;
 
@@ -2328,7 +2328,7 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 	open-&gt;op_recall = 0;
 	switch (open-&gt;op_claim_type) {
 		case NFS4_OPEN_CLAIM_PREVIOUS:
-			if (!atomic_read(&amp;cb-&gt;cb_set))
+			if (!cb_up)
 				open-&gt;op_recall = 1;
 			flag = open-&gt;op_delegate_type;
 			if (flag == NFS4_OPEN_DELEGATE_NONE)
@@ -2339,7 +2339,7 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 			 * had the chance to reclaim theirs.... */
 			if (locks_in_grace())
 				goto out;
-			if (!atomic_read(&amp;cb-&gt;cb_set) || !sop-&gt;so_confirmed)
+			if (!cb_up || !sop-&gt;so_confirmed)
 				goto out;
 			if (open-&gt;op_share_access &amp; NFS4_SHARE_ACCESS_WRITE)
 				flag = NFS4_OPEN_DELEGATE_WRITE;
@@ -2510,7 +2510,7 @@ nfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	renew_client(clp);
 	status = nfserr_cb_path_down;
 	if (!list_empty(&amp;clp-&gt;cl_delegations)
-			&amp;&amp; !atomic_read(&amp;clp-&gt;cl_cb_conn.cb_set))
+			&amp;&amp; !atomic_read(&amp;clp-&gt;cl_cb_set))
 		goto out;
 	status = nfs_ok;
 out:
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index cef20abf330c..cf43812e6da5 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -107,9 +107,7 @@ struct nfs4_cb_conn {
 	u32                     cb_prog;
 	u32			cb_minorversion;
 	u32                     cb_ident;	/* minorversion 0 only */
-	/* RPC client info */
-	atomic_t		cb_set;     /* successful CB_NULL call */
-	struct rpc_clnt *       cb_client;
+	struct svc_xprt		*cb_xprt;	/* minorversion 1 only */
 };
 
 /* Maximum number of slots per session. 160 is useful for long haul TCP */
@@ -223,9 +221,13 @@ struct nfs4_client {
 	struct svc_cred		cl_cred; 	/* setclientid principal */
 	clientid_t		cl_clientid;	/* generated by server */
 	nfs4_verifier		cl_confirm;	/* generated by server */
-	struct nfs4_cb_conn	cl_cb_conn;     /* callback info */
 	u32			cl_firststate;	/* recovery dir creation */
 
+	/* for v4.0 and v4.1 callbacks: */
+	struct nfs4_cb_conn	cl_cb_conn;
+	struct rpc_clnt		*cl_cb_client;
+	atomic_t		cl_cb_set;
+
 	/* for nfs41 */
 	struct list_head	cl_sessions;
 	struct nfsd4_clid_slot	cl_cs_slot;	/* create_session slot */
@@ -236,7 +238,6 @@ struct nfs4_client {
 	/* We currently support a single back channel with a single slot */
 	unsigned long		cl_cb_slot_busy;
 	u32			cl_cb_seq_nr;
-	struct svc_xprt		*cl_cb_xprt;	/* 4.1 callback transport */
 	struct rpc_wait_queue	cl_cb_waitq;	/* backchannel callers may */
 						/* wait here for slots */
 };</pre><hr><pre>commit b12a05cbdfdf7e4d8cbe8fa78e995f971420086b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Mar 4 11:32:59 2010 -0500

    nfsd4: cl_count is unused
    
    Now that the shutdown sequence guarantees callbacks are shut down before
    the client is destroyed, we no longer have a use for cl_count.
    
    We'll probably reinstate a reference count on the client some day, but
    it will be held by users other than callbacks.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index e078c747f49d..5856fc8adb70 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -681,10 +681,8 @@ static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 static void nfsd4_cb_recall_release(void *calldata)
 {
 	struct nfs4_delegation *dp = calldata;
-	struct nfs4_client *clp = dp-&gt;dl_client;
 
 	nfs4_put_delegation(dp);
-	put_nfs4_client(clp);
 }
 
 static const struct rpc_call_ops nfsd4_cb_recall_ops = {
@@ -746,10 +744,8 @@ static void _nfsd4_cb_recall(struct nfs4_delegation *dp)
 	dp-&gt;dl_retries = 1;
 	status = rpc_call_async(clnt, &amp;msg, RPC_TASK_SOFT,
 				&amp;nfsd4_cb_recall_ops, dp);
-	if (status) {
-		put_nfs4_client(clp);
+	if (status)
 		nfs4_put_delegation(dp);
-	}
 }
 
 void nfsd4_do_callback_rpc(struct work_struct *w)
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index adc51d10d435..cf650cbb814b 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -690,13 +690,6 @@ free_client(struct nfs4_client *clp)
 	kfree(clp);
 }
 
-void
-put_nfs4_client(struct nfs4_client *clp)
-{
-	if (atomic_dec_and_test(&amp;clp-&gt;cl_count))
-		free_client(clp);
-}
-
 static void
 expire_client(struct nfs4_client *clp)
 {
@@ -735,7 +728,7 @@ expire_client(struct nfs4_client *clp)
 	nfsd4_set_callback_client(clp, NULL);
 	if (clp-&gt;cl_cb_xprt)
 		svc_xprt_put(clp-&gt;cl_cb_xprt);
-	put_nfs4_client(clp);
+	free_client(clp);
 }
 
 static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)
@@ -821,7 +814,6 @@ static struct nfs4_client *create_client(struct xdr_netobj name, char *recdir,
 	}
 
 	memcpy(clp-&gt;cl_recdir, recdir, HEXDIR_LEN);
-	atomic_set(&amp;clp-&gt;cl_count, 1);
 	atomic_set(&amp;clp-&gt;cl_cb_conn.cb_set, 0);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_idhash);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_strhash);
@@ -2010,7 +2002,6 @@ void nfsd_break_deleg_cb(struct file_lock *fl)
 	 * lock) we know the server hasn't removed the lease yet, we know
 	 * it's safe to take a reference: */
 	atomic_inc(&amp;dp-&gt;dl_count);
-	atomic_inc(&amp;dp-&gt;dl_client-&gt;cl_count);
 
 	spin_lock(&amp;recall_lock);
 	list_add_tail(&amp;dp-&gt;dl_recall_lru, &amp;del_recall_lru);
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index c4c92aea8f39..cef20abf330c 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -224,7 +224,6 @@ struct nfs4_client {
 	clientid_t		cl_clientid;	/* generated by server */
 	nfs4_verifier		cl_confirm;	/* generated by server */
 	struct nfs4_cb_conn	cl_cb_conn;     /* callback info */
-	atomic_t		cl_count;	/* ref count */
 	u32			cl_firststate;	/* recovery dir creation */
 
 	/* for nfs41 */
@@ -388,7 +387,6 @@ extern void nfs4_lock_state(void);
 extern void nfs4_unlock_state(void);
 extern int nfs4_in_grace(void);
 extern __be32 nfs4_check_open_reclaim(clientid_t *clid);
-extern void put_nfs4_client(struct nfs4_client *clp);
 extern void nfs4_free_stateowner(struct kref *kref);
 extern int set_callback_cred(void);
 extern void nfsd4_probe_callback(struct nfs4_client *clp);</pre>
    <div class="pagination">
        <a href='4_13.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><span>[14]</span><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_15.html'>Next&gt;&gt;</a>
    <div>
</body>
