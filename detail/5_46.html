<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_45.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><span>[46]</span><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_47.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b22f687dd28a7a8886b918294b4d558ef175c07d
Author: Pete Wyckoff &lt;pw@osc.edu&gt;
Date:   Tue Mar 13 16:53:28 2007 -0400

    [SCSI] set resid in scsi_io_completion() even for check condition
    
    Some targets can return both valid data and sense information.
    Always update the request data_len from the SCSI command residual.
    Callers should interpret sense data to determine what parts of the
    data are valid in case of a CHECK CONDITION status.
    
    Signed-off-by: Pete Wyckoff &lt;pw@osc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 5f955707d902..be8e6558b89e 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -848,8 +848,8 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 				memcpy(req-&gt;sense, cmd-&gt;sense_buffer,  len);
 				req-&gt;sense_len = len;
 			}
-		} else
-			req-&gt;data_len = cmd-&gt;resid;
+		}
+		req-&gt;data_len = cmd-&gt;resid;
 	}
 
 	/*</pre><hr><pre>commit d6e24d1c8a197cc9c2a1568224474f4b7af50803
Author: Pete Wyckoff &lt;pw@osc.edu&gt;
Date:   Wed Nov 8 15:58:32 2006 -0600

    [SCSI] iscsi: add newlines to debug messages
    
    Some messages from debug_scsi do not have trailing newlines,
    making console messages difficult to read.  Fix that.
    
    Signed-off-by: Pete Wyckoff &lt;pw@osc.edu&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 2865ebd557ef..5d8862189485 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -975,13 +975,13 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
 failed:
 		debug_scsi("failing host reset: session terminated "
-			   "[CID %d age %d]", conn-&gt;id, session-&gt;age);
+			   "[CID %d age %d]\n", conn-&gt;id, session-&gt;age);
 		spin_unlock_bh(&amp;session-&gt;lock);
 		return FAILED;
 	}
 
 	if (sc-&gt;SCp.phase == session-&gt;age) {
-		debug_scsi("failing connection CID %d due to SCSI host reset",
+		debug_scsi("failing connection CID %d due to SCSI host reset\n",
 			   conn-&gt;id);
 		fail_session = 1;
 	}
@@ -1054,7 +1054,8 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 				     NULL, 0);
 	if (rc) {
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		debug_scsi("abort sent failure [itt 0x%x] %d", ctask-&gt;itt, rc);
+		debug_scsi("abort sent failure [itt 0x%x] %d\n", ctask-&gt;itt,
+		           rc);
 		return rc;
 	}
 
@@ -1071,7 +1072,7 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 		conn-&gt;tmabort_timer.function = iscsi_tmabort_timedout;
 		conn-&gt;tmabort_timer.data = (unsigned long)ctask;
 		add_timer(&amp;conn-&gt;tmabort_timer);
-		debug_scsi("abort set timeout [itt 0x%x]", ctask-&gt;itt);
+		debug_scsi("abort set timeout [itt 0x%x]\n", ctask-&gt;itt);
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 	mutex_unlock(&amp;conn-&gt;xmitmutex);</pre><hr><pre>commit 534284a09b3f58cd92acd0652b7267ee142932ba
Author: Pete Wyckoff &lt;pw@osc.edu&gt;
Date:   Wed Nov 8 15:58:31 2006 -0600

    [SCSI] iscsi: always release crypto
    
    Unconditionally free crypto state, as it is always allocated during
    TCP connection creation.  Without this, crypto structures leak and
    crc32c module refcounts grow as connections are created and
    destroyed.
    
    Signed-off-by: Pete Wyckoff &lt;pw@osc.edu&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 0a9dbc59663f..c0b8b33e935c 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1816,21 +1816,14 @@ iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
-	int digest = 0;
-
-	if (conn-&gt;hdrdgst_en || conn-&gt;datadgst_en)
-		digest = 1;
 
 	iscsi_tcp_release_conn(conn);
 	iscsi_conn_teardown(cls_conn);
 
-	/* now free tcp_conn */
-	if (digest) {
-		if (tcp_conn-&gt;tx_hash.tfm)
-			crypto_free_hash(tcp_conn-&gt;tx_hash.tfm);
-		if (tcp_conn-&gt;rx_hash.tfm)
-			crypto_free_hash(tcp_conn-&gt;rx_hash.tfm);
-	}
+	if (tcp_conn-&gt;tx_hash.tfm)
+		crypto_free_hash(tcp_conn-&gt;tx_hash.tfm);
+	if (tcp_conn-&gt;rx_hash.tfm)
+		crypto_free_hash(tcp_conn-&gt;rx_hash.tfm);
 
 	kfree(tcp_conn);
 }</pre><hr><pre>commit d2e9117c7aa9544d910634e17e3519fd67155229
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Wed Sep 12 10:44:19 2007 +0200

    [NET]: Change type of owner in sock_lock_t to int, rename
    
    The type of owner in sock_lock_t is currently (struct sock_iocb *),
    presumably for historical reasons.  It is never used as this type, only
    tested as NULL or set to (void *)1.  For clarity, this changes it to type
    int, and renames to owned, to avoid any possible type casting errors.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/net/sock.h b/include/net/sock.h
index 802c670ba820..5ed9fa42b6e8 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -76,10 +76,9 @@
  * between user contexts and software interrupt processing, whereas the
  * mini-semaphore synchronizes multiple users amongst themselves.
  */
-struct sock_iocb;
 typedef struct {
 	spinlock_t		slock;
-	struct sock_iocb	*owner;
+	int			owned;
 	wait_queue_head_t	wq;
 	/*
 	 * We express the mutex-alike socket_lock semantics
@@ -737,7 +736,7 @@ static inline int sk_stream_wmem_schedule(struct sock *sk, int size)
  * Since ~2.3.5 it is also exclusive sleep lock serializing
  * accesses from user process context.
  */
-#define sock_owned_by_user(sk)	((sk)-&gt;sk_lock.owner)
+#define sock_owned_by_user(sk)	((sk)-&gt;sk_lock.owned)
 
 /*
  * Macro so as to not evaluate some arguments when
@@ -748,7 +747,7 @@ static inline int sk_stream_wmem_schedule(struct sock *sk, int size)
  */
 #define sock_lock_init_class_and_name(sk, sname, skey, name, key) 	\
 do {									\
-	sk-&gt;sk_lock.owner = NULL;					\
+	sk-&gt;sk_lock.owned = 0;					\
 	init_waitqueue_head(&amp;sk-&gt;sk_lock.wq);				\
 	spin_lock_init(&amp;(sk)-&gt;sk_lock.slock);				\
 	debug_check_no_locks_freed((void *)&amp;(sk)-&gt;sk_lock,		\
diff --git a/net/core/sock.c b/net/core/sock.c
index 190de61cd648..beb924c248e8 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1585,9 +1585,9 @@ void fastcall lock_sock_nested(struct sock *sk, int subclass)
 {
 	might_sleep();
 	spin_lock_bh(&amp;sk-&gt;sk_lock.slock);
-	if (sk-&gt;sk_lock.owner)
+	if (sk-&gt;sk_lock.owned)
 		__lock_sock(sk);
-	sk-&gt;sk_lock.owner = (void *)1;
+	sk-&gt;sk_lock.owned = 1;
 	spin_unlock(&amp;sk-&gt;sk_lock.slock);
 	/*
 	 * The sk_lock has mutex_lock() semantics here:
@@ -1608,7 +1608,7 @@ void fastcall release_sock(struct sock *sk)
 	spin_lock_bh(&amp;sk-&gt;sk_lock.slock);
 	if (sk-&gt;sk_backlog.tail)
 		__release_sock(sk);
-	sk-&gt;sk_lock.owner = NULL;
+	sk-&gt;sk_lock.owned = 0;
 	if (waitqueue_active(&amp;sk-&gt;sk_lock.wq))
 		wake_up(&amp;sk-&gt;sk_lock.wq);
 	spin_unlock_bh(&amp;sk-&gt;sk_lock.slock);</pre><hr><pre>commit 02b3d34631831a19ee691516e233756b270eac6d
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Wed Sep 12 10:42:12 2007 +0200

    [NET] Cleanup: Use sock_owned_by_user() macro
    
    Changes asserts in sunrpc to use sock_owned_by_user() macro instead of
    referencing sock_lock.owner directly.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 406b3e687952..c75bffeb89eb 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -104,7 +104,7 @@ static struct lock_class_key svc_slock_key[2];
 static inline void svc_reclassify_socket(struct socket *sock)
 {
 	struct sock *sk = sock-&gt;sk;
-	BUG_ON(sk-&gt;sk_lock.owner != NULL);
+	BUG_ON(sock_owned_by_user(sk));
 	switch (sk-&gt;sk_family) {
 	case AF_INET:
 		sock_lock_init_class_and_name(sk, "slock-AF_INET-NFSD",
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 4ae7eed7f617..282efd447a61 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1186,7 +1186,7 @@ static struct lock_class_key xs_slock_key[2];
 static inline void xs_reclassify_socket(struct socket *sock)
 {
 	struct sock *sk = sock-&gt;sk;
-	BUG_ON(sk-&gt;sk_lock.owner != NULL);
+	BUG_ON(sock_owned_by_user(sk));
 	switch (sk-&gt;sk_family) {
 	case AF_INET:
 		sock_lock_init_class_and_name(sk, "slock-AF_INET-NFS",</pre><hr><pre>commit 628a5c561890a9a9a74dea017873530584aab06e
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Fri Apr 20 15:53:27 2007 -0700

    [INET]: Add IP(V6)_PMTUDISC_RPOBE
    
    Add IP(V6)_PMTUDISC_PROBE value for IP(V6)_MTU_DISCOVER.  This option forces
    us not to fragment, but does not make use of the kernel path MTU discovery.
    That is, it allows for user-mode MTU probing (or, packetization-layer path
    MTU discovery).  This is particularly useful for diagnostic utilities, like
    traceroute/tracepath.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/linux/in.h b/include/linux/in.h
index 1912e7c0bc26..3975cbf52f20 100644
--- a/include/linux/in.h
+++ b/include/linux/in.h
@@ -83,6 +83,7 @@ struct in_addr {
 #define IP_PMTUDISC_DONT		0	/* Never send DF frames */
 #define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
 #define IP_PMTUDISC_DO			2	/* Always DF		*/
+#define IP_PMTUDISC_PROBE		3       /* Ignore dst pmtu      */
 
 #define IP_MULTICAST_IF			32
 #define IP_MULTICAST_TTL 		33
diff --git a/include/linux/in6.h b/include/linux/in6.h
index 4e8350ae8869..d559fac4a26d 100644
--- a/include/linux/in6.h
+++ b/include/linux/in6.h
@@ -179,6 +179,7 @@ struct in6_flowlabel_req
 #define IPV6_PMTUDISC_DONT		0
 #define IPV6_PMTUDISC_WANT		1
 #define IPV6_PMTUDISC_DO		2
+#define IPV6_PMTUDISC_PROBE		3
 
 /* Flowlabel */
 #define IPV6_FLOWLABEL_MGR	32
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 34606eff8a05..534650cad3a8 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -189,6 +189,14 @@ static inline int ip_finish_output2(struct sk_buff *skb)
 	return -EINVAL;
 }
 
+static inline int ip_skb_dst_mtu(struct sk_buff *skb)
+{
+	struct inet_sock *inet = skb-&gt;sk ? inet_sk(skb-&gt;sk) : NULL;
+
+	return (inet &amp;&amp; inet-&gt;pmtudisc == IP_PMTUDISC_PROBE) ?
+	       skb-&gt;dst-&gt;dev-&gt;mtu : dst_mtu(skb-&gt;dst);
+}
+
 static inline int ip_finish_output(struct sk_buff *skb)
 {
 #if defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)
@@ -198,7 +206,7 @@ static inline int ip_finish_output(struct sk_buff *skb)
 		return dst_output(skb);
 	}
 #endif
-	if (skb-&gt;len &gt; dst_mtu(skb-&gt;dst) &amp;&amp; !skb_is_gso(skb))
+	if (skb-&gt;len &gt; ip_skb_dst_mtu(skb) &amp;&amp; !skb_is_gso(skb))
 		return ip_fragment(skb, ip_finish_output2);
 	else
 		return ip_finish_output2(skb);
@@ -422,7 +430,7 @@ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*))
 	if (unlikely((iph-&gt;frag_off &amp; htons(IP_DF)) &amp;&amp; !skb-&gt;local_df)) {
 		IP_INC_STATS(IPSTATS_MIB_FRAGFAILS);
 		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
-			  htonl(dst_mtu(&amp;rt-&gt;u.dst)));
+			  htonl(ip_skb_dst_mtu(skb)));
 		kfree_skb(skb);
 		return -EMSGSIZE;
 	}
@@ -787,7 +795,9 @@ int ip_append_data(struct sock *sk,
 			inet-&gt;cork.addr = ipc-&gt;addr;
 		}
 		dst_hold(&amp;rt-&gt;u.dst);
-		inet-&gt;cork.fragsize = mtu = dst_mtu(rt-&gt;u.dst.path);
+		inet-&gt;cork.fragsize = mtu = inet-&gt;pmtudisc == IP_PMTUDISC_PROBE ?
+					    rt-&gt;u.dst.dev-&gt;mtu :
+					    dst_mtu(rt-&gt;u.dst.path);
 		inet-&gt;cork.rt = rt;
 		inet-&gt;cork.length = 0;
 		sk-&gt;sk_sndmsg_page = NULL;
@@ -1203,13 +1213,13 @@ int ip_push_pending_frames(struct sock *sk)
 	 * to fragment the frame generated here. No matter, what transforms
 	 * how transforms change size of the packet, it will come out.
 	 */
-	if (inet-&gt;pmtudisc != IP_PMTUDISC_DO)
+	if (inet-&gt;pmtudisc &lt; IP_PMTUDISC_DO)
 		skb-&gt;local_df = 1;
 
 	/* DF bit is set when we want to see DF on outgoing frames.
 	 * If local_df is set too, we still allow to fragment this frame
 	 * locally. */
-	if (inet-&gt;pmtudisc == IP_PMTUDISC_DO ||
+	if (inet-&gt;pmtudisc &gt;= IP_PMTUDISC_DO ||
 	    (skb-&gt;len &lt;= dst_mtu(&amp;rt-&gt;u.dst) &amp;&amp;
 	     ip_dont_fragment(sk, &amp;rt-&gt;u.dst)))
 		df = htons(IP_DF);
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index c199d2311731..4d544573f48a 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -542,7 +542,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		inet-&gt;hdrincl = val ? 1 : 0;
 		break;
 	case IP_MTU_DISCOVER:
-		if (val&lt;0 || val&gt;2)
+		if (val&lt;0 || val&gt;3)
 			goto e_inval;
 		inet-&gt;pmtudisc = val;
 		break;
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 5a5b7d4ad31c..f508171bab73 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -137,9 +137,17 @@ static int ip6_output2(struct sk_buff *skb)
 	return NF_HOOK(PF_INET6, NF_IP6_POST_ROUTING, skb,NULL, skb-&gt;dev,ip6_output_finish);
 }
 
+static inline int ip6_skb_dst_mtu(struct sk_buff *skb)
+{
+	struct ipv6_pinfo *np = skb-&gt;sk ? inet6_sk(skb-&gt;sk) : NULL;
+
+	return (np &amp;&amp; np-&gt;pmtudisc == IPV6_PMTUDISC_PROBE) ?
+	       skb-&gt;dst-&gt;dev-&gt;mtu : dst_mtu(skb-&gt;dst);
+}
+
 int ip6_output(struct sk_buff *skb)
 {
-	if ((skb-&gt;len &gt; dst_mtu(skb-&gt;dst) &amp;&amp; !skb_is_gso(skb)) ||
+	if ((skb-&gt;len &gt; ip6_skb_dst_mtu(skb) &amp;&amp; !skb_is_gso(skb)) ||
 				dst_allfrag(skb-&gt;dst))
 		return ip6_fragment(skb, ip6_output2);
 	else
@@ -566,7 +574,7 @@ static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 	hlen = ip6_find_1stfragopt(skb, &amp;prevhdr);
 	nexthdr = *prevhdr;
 
-	mtu = dst_mtu(&amp;rt-&gt;u.dst);
+	mtu = ip6_skb_dst_mtu(skb);
 
 	/* We must not fragment if the socket is set to force MTU discovery
 	 * or if the skb it not generated by a local socket.  (This last
@@ -1063,7 +1071,8 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 		inet-&gt;cork.fl = *fl;
 		np-&gt;cork.hop_limit = hlimit;
 		np-&gt;cork.tclass = tclass;
-		mtu = dst_mtu(rt-&gt;u.dst.path);
+		mtu = np-&gt;pmtudisc == IPV6_PMTUDISC_PROBE ?
+		      rt-&gt;u.dst.dev-&gt;mtu : dst_mtu(rt-&gt;u.dst.path);
 		if (np-&gt;frag_size &lt; mtu) {
 			if (np-&gt;frag_size)
 				mtu = np-&gt;frag_size;
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index da930fa089c9..aa3d07c52a8f 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -694,7 +694,7 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
 		retv = ip6_ra_control(sk, val, NULL);
 		break;
 	case IPV6_MTU_DISCOVER:
-		if (val&lt;0 || val&gt;2)
+		if (val&lt;0 || val&gt;3)
 			goto e_inval;
 		np-&gt;pmtudisc = val;
 		retv = 0;</pre><hr><pre>commit b881ef7603230550aa0150b22af94089f07ab00d
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Fri Apr 20 15:52:39 2007 -0700

    [IPV6]: MTU discovery check in ip6_fragment()
    
    Adds a check in ip6_fragment() mirroring ip_fragment() for packets
    that we can't fragment, and sends an ICMP Packet Too Big message
    in response.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 4cfdad4e8356..5a5b7d4ad31c 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -567,6 +567,19 @@ static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 	nexthdr = *prevhdr;
 
 	mtu = dst_mtu(&amp;rt-&gt;u.dst);
+
+	/* We must not fragment if the socket is set to force MTU discovery
+	 * or if the skb it not generated by a local socket.  (This last
+	 * check should be redundant, but it's free.)
+	 */
+	if (!np || np-&gt;pmtudisc &gt;= IPV6_PMTUDISC_DO) {
+		skb-&gt;dev = skb-&gt;dst-&gt;dev;
+		icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, skb-&gt;dev);
+		IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_FRAGFAILS);
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+
 	if (np &amp;&amp; np-&gt;frag_size &lt; mtu) {
 		if (np-&gt;frag_size)
 			mtu = np-&gt;frag_size;</pre><hr><pre>commit 9af3912ec9e30509b76cb376abb65a4d8af27df3
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Sun Mar 25 23:32:29 2007 -0700

    [NET] Move DF check to ip_forward
    
    Do fragmentation check in ip_forward, similar to ipv6 forwarding.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 467ebedb99ba..61b30d100676 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -85,6 +85,14 @@ int ip_forward(struct sk_buff *skb)
 	if (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
 		goto sr_failed;
 
+	if (unlikely(skb-&gt;len &gt; dst_mtu(&amp;rt-&gt;u.dst) &amp;&amp;
+	             (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_DF))) &amp;&amp; !skb-&gt;local_df) {
+		IP_INC_STATS(IPSTATS_MIB_FRAGFAILS);
+		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
+			  htonl(dst_mtu(&amp;rt-&gt;u.dst)));
+		goto drop;
+	}
+
 	/* We are about to mangle packet. Copy it! */
 	if (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;u.dst.dev)+rt-&gt;u.dst.header_len))
 		goto drop;</pre><hr><pre>commit 886236c1247ab5e2ad9c73f6e9a652e3ae3c8b07
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Sun Mar 25 19:21:45 2007 -0700

    [TCP]: Add RFC3742 Limited Slow-Start, controlled by variable sysctl_tcp_max_ssthresh.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index 9a8970bf99a6..98e0fd241a25 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -438,6 +438,7 @@ enum
 	NET_CIPSOV4_RBM_STRICTVALID=121,
 	NET_TCP_AVAIL_CONG_CONTROL=122,
 	NET_TCP_ALLOWED_CONG_CONTROL=123,
+	NET_TCP_MAX_SSTHRESH=124,
 };
 
 enum {
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 7fd6b77519c3..6d09f5085f6a 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -230,6 +230,7 @@ extern int sysctl_tcp_mtu_probing;
 extern int sysctl_tcp_base_mss;
 extern int sysctl_tcp_workaround_signed_windows;
 extern int sysctl_tcp_slow_start_after_idle;
+extern int sysctl_tcp_max_ssthresh;
 
 extern atomic_t tcp_memory_allocated;
 extern atomic_t tcp_sockets_allocated;
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 0aa304711a96..d68effe98e8d 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -803,6 +803,14 @@ ctl_table ipv4_table[] = {
 		.proc_handler   = &amp;proc_allowed_congestion_control,
 		.strategy	= &amp;strategy_allowed_congestion_control,
 	},
+	{
+		.ctl_name	= NET_TCP_MAX_SSTHRESH,
+		.procname	= "tcp_max_ssthresh",
+		.data		= &amp;sysctl_tcp_max_ssthresh,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &amp;proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c
index 34ae3f13483a..ccd88407e0cd 100644
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@ -12,6 +12,8 @@
 #include &lt;linux/list.h&gt;
 #include &lt;net/tcp.h&gt;
 
+int sysctl_tcp_max_ssthresh = 0;
+
 static DEFINE_SPINLOCK(tcp_cong_list_lock);
 static LIST_HEAD(tcp_cong_list);
 
@@ -274,10 +276,13 @@ int tcp_set_congestion_control(struct sock *sk, const char *name)
 
 
 /*
- * Linear increase during slow start
+ * Slow start (exponential increase) with
+ * RFC3742 Limited Slow Start (fast linear increase) support.
  */
 void tcp_slow_start(struct tcp_sock *tp)
 {
+	int cnt = 0;
+
 	if (sysctl_tcp_abc) {
 		/* RFC3465: Slow Start
 		 * TCP sender SHOULD increase cwnd by the number of
@@ -286,17 +291,25 @@ void tcp_slow_start(struct tcp_sock *tp)
 		 */
 		if (tp-&gt;bytes_acked &lt; tp-&gt;mss_cache)
 			return;
-
-		/* We MAY increase by 2 if discovered delayed ack */
-		if (sysctl_tcp_abc &gt; 1 &amp;&amp; tp-&gt;bytes_acked &gt;= 2*tp-&gt;mss_cache) {
-			if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
-				tp-&gt;snd_cwnd++;
-		}
 	}
+
+	if (sysctl_tcp_max_ssthresh &gt; 0 &amp;&amp;
+	    tp-&gt;snd_cwnd &gt; sysctl_tcp_max_ssthresh)
+		cnt += sysctl_tcp_max_ssthresh&gt;&gt;1;
+	else
+		cnt += tp-&gt;snd_cwnd;
+
+	/* RFC3465: We MAY increase by 2 if discovered delayed ack */
+	if (sysctl_tcp_abc &gt; 1 &amp;&amp; tp-&gt;bytes_acked &gt;= 2*tp-&gt;mss_cache)
+		cnt &lt;&lt;= 1;
 	tp-&gt;bytes_acked = 0;
 
-	if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
-		tp-&gt;snd_cwnd++;
+	tp-&gt;snd_cwnd_cnt += cnt;
+	while (tp-&gt;snd_cwnd_cnt &gt;= tp-&gt;snd_cwnd) {
+		tp-&gt;snd_cwnd_cnt -= tp-&gt;snd_cwnd;
+		if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
+			tp-&gt;snd_cwnd++;
+	}
 }
 EXPORT_SYMBOL_GPL(tcp_slow_start);
 </pre><hr><pre>commit 84565070e442583ec67fb08a5962c80203e491c3
Author: John Heffner &lt;jheffner@psc.edu&gt;
Date:   Mon Apr 2 13:56:32 2007 -0700

    [TCP]: Do receiver-side SWS avoidance for rcvbuf &lt; MSS.
    
    Signed-off-by: John Heffner &lt;jheffner@psc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index dc151139b5af..688b95594f2e 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1607,6 +1607,9 @@ u32 __tcp_select_window(struct sock *sk)
 		 */
 		if (window &lt;= free_space - mss || window &gt; free_space)
 			window = (free_space/mss)*mss;
+		else if (mss == full_space &amp;&amp;
+		         free_space &gt; window + full_space/2)
+			window = free_space;
 	}
 
 	return window;</pre>
    <div class="pagination">
        <a href='5_45.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><span>[46]</span><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_47.html'>Next&gt;&gt;</a>
    <div>
</body>
