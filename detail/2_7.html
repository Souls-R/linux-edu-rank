<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_6.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><span>[7]</span><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_8.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d2f311ec91984adb219ac6985d4dd72c37ae734d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 1 12:36:06 2021 -0400

    HID: usbhid: Simplify code in hid_submit_ctrl()
    
    This patch makes a small simplification to the code in
    hid_submit_ctrl().  The test for maxpacket being &gt; 0 is unnecessary,
    because endpoint 0 always has a maxpacket value which is &gt;= 8.
    
    Furthermore, endpoint 0's maxpacket value is always a power of 2, so
    instead of open-coding the round-to-next-multiple computation we can
    call the optimized round_up() routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Acked-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index c56cb03c1551..2dcaf31eb9cd 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -388,14 +388,10 @@ static int hid_submit_ctrl(struct hid_device *hid)
 		usbhid-&gt;urbctrl-&gt;pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);
 		maxpacket = usb_maxpacket(hid_to_usb_dev(hid),
 					  usbhid-&gt;urbctrl-&gt;pipe, 0);
-		if (maxpacket &gt; 0) {
-			len += (len == 0);    /* Don't allow 0-length reports */
-			len = DIV_ROUND_UP(len, maxpacket);
-			len *= maxpacket;
-			if (len &gt; usbhid-&gt;bufsize)
-				len = usbhid-&gt;bufsize;
-		} else
-			len = 0;
+		len += (len == 0);	/* Don't allow 0-length reports */
+		len = round_up(len, maxpacket);
+		if (len &gt; usbhid-&gt;bufsize)
+			len = usbhid-&gt;bufsize;
 	}
 	usbhid-&gt;urbctrl-&gt;transfer_buffer_length = len;
 	usbhid-&gt;urbctrl-&gt;dev = hid_to_usb_dev(hid);</pre><hr><pre>commit 0a824efdb724e07574bafcd2c2486b2a3de35ff6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 1 12:36:00 2021 -0400

    HID: usbhid: Fix warning caused by 0-length input reports
    
    Syzbot found a warning caused by hid_submit_ctrl() submitting a
    control request to transfer a 0-length input report:
    
            usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType a1
    
    (The warning message is a little difficult to understand.  It means
    that the control request claims to be for an IN transfer but this
    contradicts the USB spec, which requires 0-length control transfers
    always to be in the OUT direction.)
    
    Now, a zero-length report isn't good for anything and there's no
    reason for a device to have one, but the fuzzer likes to pick out
    these weird edge cases.  In the future, perhaps we will decide to
    reject 0-length reports at probe time.  For now, the simplest approach
    for avoiding these warnings is to pretend that the report actually has
    length 1.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+9b57a46bf1801ce2a2ca@syzkaller.appspotmail.com
    Tested-by: Oleksandr Natalenko &lt;oleksandr@natalenko.name&gt;
    Tested-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Acked-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 6b8690878435..c56cb03c1551 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -389,6 +389,7 @@ static int hid_submit_ctrl(struct hid_device *hid)
 		maxpacket = usb_maxpacket(hid_to_usb_dev(hid),
 					  usbhid-&gt;urbctrl-&gt;pipe, 0);
 		if (maxpacket &gt; 0) {
+			len += (len == 0);    /* Don't allow 0-length reports */
 			len = DIV_ROUND_UP(len, maxpacket);
 			len *= maxpacket;
 			if (len &gt; usbhid-&gt;bufsize)</pre><hr><pre>commit b0863f1927323110e3d0d69f6adb6a91018a9a3c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 12 14:54:36 2021 -0400

    USB: core: Fix incorrect pipe calculation in do_proc_control()
    
    When the user submits a control URB via usbfs, the user supplies the
    bRequestType value and the kernel uses it to compute the pipe value.
    However, do_proc_control() performs this computation incorrectly in
    the case where the bRequestType direction bit is set to USB_DIR_IN and
    the URB's transfer length is 0: The pipe's direction is also set to IN
    but it should be OUT, which is the direction the actual transfer will
    use regardless of bRequestType.
    
    Commit 5cc59c418fde ("USB: core: WARN if pipe direction != setup
    packet direction") added a check to compare the direction bit in the
    pipe value to a control URB's actual direction and to WARN if they are
    different.  This can be triggered by the incorrect computation
    mentioned above, as found by syzbot.
    
    This patch fixes the computation, thus avoiding the WARNing.
    
    Reported-and-tested-by: syzbot+72af3105289dcb4c055b@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210712185436.GB326369@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b97464498763..9618ba622a2d 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1133,7 +1133,7 @@ static int do_proc_control(struct usb_dev_state *ps,
 		"wIndex=%04x wLength=%04x\n",
 		ctrl-&gt;bRequestType, ctrl-&gt;bRequest, ctrl-&gt;wValue,
 		ctrl-&gt;wIndex, ctrl-&gt;wLength);
-	if (ctrl-&gt;bRequestType &amp; 0x80) {
+	if ((ctrl-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; ctrl-&gt;wLength) {
 		pipe = usb_rcvctrlpipe(dev, 0);
 		snoop_urb(dev, NULL, pipe, ctrl-&gt;wLength, tmo, SUBMIT, NULL, 0);
 </pre><hr><pre>commit 60dfe484cef45293e631b3a6e8995f1689818172
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 7 11:23:07 2021 -0400

    USB: core: Avoid WARNings for 0-length descriptor requests
    
    The USB core has utility routines to retrieve various types of
    descriptors.  These routines will now provoke a WARN if they are asked
    to retrieve 0 bytes (USB "receive" requests must not have zero
    length), so avert this by checking the size argument at the start.
    
    CC: Johan Hovold &lt;johan@kernel.org&gt;
    Reported-and-tested-by: syzbot+7dbcd9ff34dc4ed45240@syzkaller.appspotmail.com
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210607152307.GD1768031@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 30e9e680c74c..4d59d927ae3e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -783,6 +783,9 @@ int usb_get_descriptor(struct usb_device *dev, unsigned char type,
 	int i;
 	int result;
 
+	if (size &lt;= 0)		/* No point in asking for no data */
+		return -EINVAL;
+
 	memset(buf, 0, size);	/* Make sure we parse really received data */
 
 	for (i = 0; i &lt; 3; ++i) {
@@ -832,6 +835,9 @@ static int usb_get_string(struct usb_device *dev, unsigned short langid,
 	int i;
 	int result;
 
+	if (size &lt;= 0)		/* No point in asking for no data */
+		return -EINVAL;
+
 	for (i = 0; i &lt; 3; ++i) {
 		/* retry on length 0 or stall; some devices are flakey */
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),</pre><hr><pre>commit 87191ca9f90244d4e003fbe5c77390b5e585a5ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:22:06 2021 -0400

    USB: UDC: Implement udc_async_callbacks in net2272
    
    This patch adds a udc_async_callbacks handler to the net2272 UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The net2272 driver is sufficiently complicated that I didn't want to
    mess around with IRQ settings.  Instead, the patch simply adds a new
    flag to control async callbacks, and checks the flag before issuing
    any of them.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202206.GF1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/net2272.c b/drivers/usb/gadget/udc/net2272.c
index 89f479b78d80..7c38057dcb4a 100644
--- a/drivers/usb/gadget/udc/net2272.c
+++ b/drivers/usb/gadget/udc/net2272.c
@@ -1150,6 +1150,7 @@ net2272_pullup(struct usb_gadget *_gadget, int is_on)
 static int net2272_start(struct usb_gadget *_gadget,
 		struct usb_gadget_driver *driver);
 static int net2272_stop(struct usb_gadget *_gadget);
+static void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable);
 
 static const struct usb_gadget_ops net2272_ops = {
 	.get_frame	= net2272_get_frame,
@@ -1158,6 +1159,7 @@ static const struct usb_gadget_ops net2272_ops = {
 	.pullup		= net2272_pullup,
 	.udc_start	= net2272_start,
 	.udc_stop	= net2272_stop,
+	.udc_async_callbacks = net2272_async_callbacks,
 };
 
 /*---------------------------------------------------------------------------*/
@@ -1476,7 +1478,7 @@ stop_activity(struct net2272 *dev, struct usb_gadget_driver *driver)
 		net2272_dequeue_all(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
+	if (dev-&gt;async_callbacks &amp;&amp; driver) {
 		spin_unlock(&amp;dev-&gt;lock);
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
 		spin_lock(&amp;dev-&gt;lock);
@@ -1501,6 +1503,15 @@ static int net2272_stop(struct usb_gadget *_gadget)
 	return 0;
 }
 
+static void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct net2272	*dev = container_of(_gadget, struct net2272, gadget);
+
+	spin_lock_irq(&amp;dev-&gt;lock);
+	dev-&gt;async_callbacks = enable;
+	spin_unlock_irq(&amp;dev-&gt;lock);
+}
+
 /*---------------------------------------------------------------------------*/
 /* handle ep-a/ep-b dma completions */
 static void
@@ -1910,9 +1921,11 @@ net2272_handle_stat0_irqs(struct net2272 *dev, u8 stat)
 				u.r.bRequestType, u.r.bRequest,
 				u.r.wValue, u.r.wIndex,
 				net2272_ep_read(ep, EP_CFG));
-			spin_unlock(&amp;dev-&gt;lock);
-			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
-			spin_lock(&amp;dev-&gt;lock);
+			if (dev-&gt;async_callbacks) {
+				spin_unlock(&amp;dev-&gt;lock);
+				tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
+				spin_lock(&amp;dev-&gt;lock);
+			}
 		}
 
 		/* stall ep0 on error */
@@ -1994,14 +2007,14 @@ net2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				net2272_ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
-				if (reset)
-					usb_gadget_udc_reset
-						(&amp;dev-&gt;gadget, dev-&gt;driver);
-				else
-					(dev-&gt;driver-&gt;disconnect)
-						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
+				if (dev-&gt;async_callbacks) {
+					spin_unlock(&amp;dev-&gt;lock);
+					if (reset)
+						usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);
+					else
+						(dev-&gt;driver-&gt;disconnect)(&amp;dev-&gt;gadget);
+					spin_lock(&amp;dev-&gt;lock);
+				}
 				return;
 			}
 		}
@@ -2015,14 +2028,14 @@ net2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)
 	if (stat &amp; tmp) {
 		net2272_write(dev, IRQSTAT1, tmp);
 		if (stat &amp; (1 &lt;&lt; SUSPEND_REQUEST_INTERRUPT)) {
-			if (dev-&gt;driver-&gt;suspend)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;suspend)
 				dev-&gt;driver-&gt;suspend(&amp;dev-&gt;gadget);
 			if (!enable_suspend) {
 				stat &amp;= ~(1 &lt;&lt; SUSPEND_REQUEST_INTERRUPT);
 				dev_dbg(dev-&gt;dev, "Suspend disabled, ignoring\n");
 			}
 		} else {
-			if (dev-&gt;driver-&gt;resume)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;resume)
 				dev-&gt;driver-&gt;resume(&amp;dev-&gt;gadget);
 		}
 		stat &amp;= ~tmp;
diff --git a/drivers/usb/gadget/udc/net2272.h b/drivers/usb/gadget/udc/net2272.h
index c669308111c2..a9994f737588 100644
--- a/drivers/usb/gadget/udc/net2272.h
+++ b/drivers/usb/gadget/udc/net2272.h
@@ -442,6 +442,7 @@ struct net2272 {
 	         softconnect:1,
 	         wakeup:1,
 		 added:1,
+		 async_callbacks:1,
 	         dma_eot_polarity:1,
 	         dma_dack_polarity:1,
 	         dma_dreq_polarity:1,</pre><hr><pre>commit b42e8090ba93526d6063108b25e5fc0f11f58770
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:22:00 2021 -0400

    USB: UDC: Implement udc_async_callbacks in net2280
    
    This patch adds a udc_async_callbacks handler to the net2280 UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The net2280 driver is sufficiently complicated that I didn't want to
    mess around with IRQ settings.  Instead, the patch simply adds a new
    flag to control async callbacks, and checks the flag before issuing
    any of them.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202200.GE1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index fc9f99fe7f37..0e0458e3662b 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -1617,6 +1617,7 @@ static struct usb_ep *net2280_match_ep(struct usb_gadget *_gadget,
 static int net2280_start(struct usb_gadget *_gadget,
 		struct usb_gadget_driver *driver);
 static int net2280_stop(struct usb_gadget *_gadget);
+static void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable);
 
 static const struct usb_gadget_ops net2280_ops = {
 	.get_frame	= net2280_get_frame,
@@ -1625,6 +1626,7 @@ static const struct usb_gadget_ops net2280_ops = {
 	.pullup		= net2280_pullup,
 	.udc_start	= net2280_start,
 	.udc_stop	= net2280_stop,
+	.udc_async_callbacks = net2280_async_callbacks,
 	.match_ep	= net2280_match_ep,
 };
 
@@ -2472,7 +2474,7 @@ static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
+	if (dev-&gt;async_callbacks &amp;&amp; driver) {
 		spin_unlock(&amp;dev-&gt;lock);
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
 		spin_lock(&amp;dev-&gt;lock);
@@ -2502,6 +2504,15 @@ static int net2280_stop(struct usb_gadget *_gadget)
 	return 0;
 }
 
+static void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct net2280	*dev = container_of(_gadget, struct net2280, gadget);
+
+	spin_lock_irq(&amp;dev-&gt;lock);
+	dev-&gt;async_callbacks = enable;
+	spin_unlock_irq(&amp;dev-&gt;lock);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* handle ep0, ep-e, ep-f with 64 byte packets: packet per irq.
@@ -3042,9 +3053,11 @@ static void handle_stat0_irqs_superspeed(struct net2280 *dev,
 				readl(&amp;ep-&gt;cfg-&gt;ep_cfg));
 
 		ep-&gt;responded = 0;
-		spin_unlock(&amp;dev-&gt;lock);
-		tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;r);
-		spin_lock(&amp;dev-&gt;lock);
+		if (dev-&gt;async_callbacks) {
+			spin_unlock(&amp;dev-&gt;lock);
+			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;r);
+			spin_lock(&amp;dev-&gt;lock);
+		}
 	}
 do_stall3:
 	if (tmp &lt; 0) {
@@ -3284,9 +3297,11 @@ static void handle_stat0_irqs(struct net2280 *dev, u32 stat)
 				w_value, w_index, w_length,
 				readl(&amp;ep-&gt;cfg-&gt;ep_cfg));
 			ep-&gt;responded = 0;
-			spin_unlock(&amp;dev-&gt;lock);
-			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
-			spin_lock(&amp;dev-&gt;lock);
+			if (dev-&gt;async_callbacks) {
+				spin_unlock(&amp;dev-&gt;lock);
+				tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
+				spin_lock(&amp;dev-&gt;lock);
+			}
 		}
 
 		/* stall ep0 on error */
@@ -3391,14 +3406,14 @@ __acquires(dev-&gt;lock)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
-				if (reset)
-					usb_gadget_udc_reset
-						(&amp;dev-&gt;gadget, dev-&gt;driver);
-				else
-					(dev-&gt;driver-&gt;disconnect)
-						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
+				if (dev-&gt;async_callbacks) {
+					spin_unlock(&amp;dev-&gt;lock);
+					if (reset)
+						usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);
+					else
+						(dev-&gt;driver-&gt;disconnect)(&amp;dev-&gt;gadget);
+					spin_lock(&amp;dev-&gt;lock);
+				}
 				return;
 			}
 		}
@@ -3419,12 +3434,12 @@ __acquires(dev-&gt;lock)
 		writel(tmp, &amp;dev-&gt;regs-&gt;irqstat1);
 		spin_unlock(&amp;dev-&gt;lock);
 		if (stat &amp; BIT(SUSPEND_REQUEST_INTERRUPT)) {
-			if (dev-&gt;driver-&gt;suspend)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;suspend)
 				dev-&gt;driver-&gt;suspend(&amp;dev-&gt;gadget);
 			if (!enable_suspend)
 				stat &amp;= ~BIT(SUSPEND_REQUEST_INTERRUPT);
 		} else {
-			if (dev-&gt;driver-&gt;resume)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;resume)
 				dev-&gt;driver-&gt;resume(&amp;dev-&gt;gadget);
 			/* at high speed, note erratum 0133 */
 		}
diff --git a/drivers/usb/gadget/udc/net2280.h b/drivers/usb/gadget/udc/net2280.h
index 7da3dc1e9729..34716a9f4926 100644
--- a/drivers/usb/gadget/udc/net2280.h
+++ b/drivers/usb/gadget/udc/net2280.h
@@ -162,6 +162,7 @@ struct net2280 {
 					ltm_enable:1,
 					wakeup_enable:1,
 					addressed_state:1,
+					async_callbacks:1,
 					bug7734_patched:1;
 	u16				chiprev;
 	int enhanced_mode;</pre><hr><pre>commit 04145a03db9d78469e0817ab3a767c76c0fb0947
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:21:52 2021 -0400

    USB: UDC: Implement udc_async_callbacks in dummy-hcd
    
    This patch adds a udc_async_callbacks handler to the dummy-hcd UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The implementation is simple, since dummy-hcd already has a flag to
    keep track of whether emulated IRQs are enabled.  All the handler has
    to do is store the enable value in the flag, and avoid setting the
    flag prematurely.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202152.GD1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index 7db773c87379..a2d956af42a2 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -934,6 +934,15 @@ static void dummy_udc_set_speed(struct usb_gadget *_gadget,
 	dummy_udc_update_ep0(dum);
 }
 
+static void dummy_udc_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct dummy	*dum = gadget_dev_to_dummy(&amp;_gadget-&gt;dev);
+
+	spin_lock_irq(&amp;dum-&gt;lock);
+	dum-&gt;ints_enabled = enable;
+	spin_unlock_irq(&amp;dum-&gt;lock);
+}
+
 static int dummy_udc_start(struct usb_gadget *g,
 		struct usb_gadget_driver *driver);
 static int dummy_udc_stop(struct usb_gadget *g);
@@ -946,6 +955,7 @@ static const struct usb_gadget_ops dummy_ops = {
 	.udc_start	= dummy_udc_start,
 	.udc_stop	= dummy_udc_stop,
 	.udc_set_speed	= dummy_udc_set_speed,
+	.udc_async_callbacks = dummy_udc_async_callbacks,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -1005,7 +1015,6 @@ static int dummy_udc_start(struct usb_gadget *g,
 	spin_lock_irq(&amp;dum-&gt;lock);
 	dum-&gt;devstatus = 0;
 	dum-&gt;driver = driver;
-	dum-&gt;ints_enabled = 1;
 	spin_unlock_irq(&amp;dum-&gt;lock);
 
 	return 0;</pre><hr><pre>commit 7dc0c55e9f302e7048e040ee4437437bbea1e2cd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:21:44 2021 -0400

    USB: UDC core: Add udc_async_callbacks gadget op
    
    The Gadget API has a theoretical race when a gadget driver is unbound.
    Although the pull-up is turned off before the driver's -&gt;unbind
    callback runs, if the USB cable were to be unplugged at just the wrong
    moment there would be nothing to prevent the UDC driver from invoking
    the -&gt;disconnect callback after the unbind has finished.  In theory,
    other asynchronous callbacks could also happen during the time before
    the UDC driver's udc_stop routine is called, and the gadget driver
    would not be prepared to handle any of them.
    
    We need a way to tell UDC drivers to stop issuing asynchronous (that is,
    -&gt;suspend, -&gt;resume, -&gt;disconnect, -&gt;reset, or -&gt;setup) callbacks at
    some point after the pull-up has been turned off and before the
    -&gt;unbind callback runs.  This patch adds a new -&gt;udc_async_callbacks
    callback to the usb_gadget_ops structure for precisely this purpose,
    and it adds the corresponding support to the UDC core.
    
    Later patches in this series add support for udc_async_callbacks to
    several UDC drivers.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202144.GC1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 493ff93f7dda..b7f0b1ebaaa8 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1147,6 +1147,53 @@ static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,
 		gadget-&gt;ops-&gt;udc_set_speed(gadget, s);
 }
 
+/**
+ * usb_gadget_enable_async_callbacks - tell usb device controller to enable asynchronous callbacks
+ * @udc: The UDC which should enable async callbacks
+ *
+ * This routine is used when binding gadget drivers.  It undoes the effect
+ * of usb_gadget_disable_async_callbacks(); the UDC driver should enable IRQs
+ * (if necessary) and resume issuing callbacks.
+ *
+ * This routine will always be called in process context.
+ */
+static inline void usb_gadget_enable_async_callbacks(struct usb_udc *udc)
+{
+	struct usb_gadget *gadget = udc-&gt;gadget;
+
+	if (gadget-&gt;ops-&gt;udc_async_callbacks)
+		gadget-&gt;ops-&gt;udc_async_callbacks(gadget, true);
+}
+
+/**
+ * usb_gadget_disable_async_callbacks - tell usb device controller to disable asynchronous callbacks
+ * @udc: The UDC which should disable async callbacks
+ *
+ * This routine is used when unbinding gadget drivers.  It prevents a race:
+ * The UDC driver doesn't know when the gadget driver's -&gt;unbind callback
+ * runs, so unless it is told to disable asynchronous callbacks, it might
+ * issue a callback (such as -&gt;disconnect) after the unbind has completed.
+ *
+ * After this function runs, the UDC driver must suppress all -&gt;suspend,
+ * -&gt;resume, -&gt;disconnect, -&gt;reset, and -&gt;setup callbacks to the gadget driver
+ * until async callbacks are again enabled.  A simple-minded but effective
+ * way to accomplish this is to tell the UDC hardware not to generate any
+ * more IRQs.
+ *
+ * Request completion callbacks must still be issued.  However, it's okay
+ * to defer them until the request is cancelled, since the pull-up will be
+ * turned off during the time period when async callbacks are disabled.
+ *
+ * This routine will always be called in process context.
+ */
+static inline void usb_gadget_disable_async_callbacks(struct usb_udc *udc)
+{
+	struct usb_gadget *gadget = udc-&gt;gadget;
+
+	if (gadget-&gt;ops-&gt;udc_async_callbacks)
+		gadget-&gt;ops-&gt;udc_async_callbacks(gadget, false);
+}
+
 /**
  * usb_udc_release - release the usb_udc struct
  * @dev: the dev member within usb_udc
@@ -1361,6 +1408,7 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 
 	usb_gadget_disconnect(udc-&gt;gadget);
+	usb_gadget_disable_async_callbacks(udc);
 	if (udc-&gt;gadget-&gt;irq)
 		synchronize_irq(udc-&gt;gadget-&gt;irq);
 	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
@@ -1442,6 +1490,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 		driver-&gt;unbind(udc-&gt;gadget);
 		goto err1;
 	}
+	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 8811eb96e5cc..75c7538e350a 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -325,6 +325,7 @@ struct usb_gadget_ops {
 	void	(*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
 	void	(*udc_set_ssp_rate)(struct usb_gadget *gadget,
 			enum usb_ssp_rate rate);
+	void	(*udc_async_callbacks)(struct usb_gadget *gadget, bool enable);
 	struct usb_ep *(*match_ep)(struct usb_gadget *,
 			struct usb_endpoint_descriptor *,
 			struct usb_ss_ep_comp_descriptor *);</pre><hr><pre>commit 7652dd2c5cb7b656471cc801d619fe24120643a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 26 11:32:44 2021 -0400

    USB: core: Check buffer length matches wLength for control transfers
    
    A type of inconsistency that can show up in control URBs is when the
    setup packet's wLength value does not match the URB's
    transfer_buffer_length field.  The two should always be equal;
    differences could lead to information leaks or undefined behavior for
    OUT transfers or overruns for IN transfers.
    
    This patch adds a test for such mismatches during URB submission.  If
    the test fails, the submission is rejected with a -EBADR error code
    (which is not used elsewhere in the USB core), and a debugging message
    is logged for people interested in tracking down these errors.
    
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210526153244.GA1400430@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/driver-api/usb/error-codes.rst b/Documentation/driver-api/usb/error-codes.rst
index a3e84bfac776..8f9790c2d6f8 100644
--- a/Documentation/driver-api/usb/error-codes.rst
+++ b/Documentation/driver-api/usb/error-codes.rst
@@ -61,6 +61,9 @@ USB-specific:
 			(c) requested data transfer length is invalid: negative
 			    or too large for the host controller.
 
+``-EBADR``		The wLength value in a control URB's setup packet does
+			not match the URB's transfer_buffer_length.
+
 ``-ENOSPC``		This request would overcommit the usb bandwidth reserved
 			for periodic transfers (interrupt, isochronous).
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 279b3921ff8f..30727729a44c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -410,6 +410,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		dev_WARN_ONCE(&amp;dev-&gt;dev, (usb_pipeout(urb-&gt;pipe) != is_out),
 				"BOGUS control dir, pipe %x doesn't match bRequestType %x\n",
 				urb-&gt;pipe, setup-&gt;bRequestType);
+		if (le16_to_cpu(setup-&gt;wLength) != urb-&gt;transfer_buffer_length) {
+			dev_dbg(&amp;dev-&gt;dev, "BOGUS control len %d doesn't match transfer length %d\n",
+					le16_to_cpu(setup-&gt;wLength),
+					urb-&gt;transfer_buffer_length);
+			return -EBADR;
+		}
 	} else {
 		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	}</pre><hr><pre>commit 5cc59c418fde9d02859996707b9d5dfd2941c50b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 21 22:16:23 2021 -0400

    USB: core: WARN if pipe direction != setup packet direction
    
    When a control URB is submitted, the direction indicated by URB's pipe
    member is supposed to match the direction indicated by the setup
    packet's bRequestType member.  A mismatch could lead to trouble,
    depending on which field the host controller drivers use for
    determining the actual direction.
    
    This shouldn't ever happen; it would represent a careless bug in a
    kernel driver somewhere.  This patch adds a dev_WARN_ONCE to let
    people know about the potential problem.
    
    Suggested-by: "Geoffrey D. Bennett" &lt;g@b4.vu&gt;
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210522021623.GB1260282@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 357b149b20d3..279b3921ff8f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -407,6 +407,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			return -ENOEXEC;
 		is_out = !(setup-&gt;bRequestType &amp; USB_DIR_IN) ||
 				!setup-&gt;wLength;
+		dev_WARN_ONCE(&amp;dev-&gt;dev, (usb_pipeout(urb-&gt;pipe) != is_out),
+				"BOGUS control dir, pipe %x doesn't match bRequestType %x\n",
+				urb-&gt;pipe, setup-&gt;bRequestType);
 	} else {
 		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	}</pre>
    <div class="pagination">
        <a href='2_6.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><span>[7]</span><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_8.html'>Next&gt;&gt;</a>
    <div>
</body>
