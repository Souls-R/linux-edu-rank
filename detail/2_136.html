<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_135.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><span>[136]</span><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_137.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 541950027f8b7c96a639bc16e48930c590f1b98a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 15 21:52:51 2005 -0400

    [SCSI] fix use after potential free in scsi_remove_device
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index b8052d5206cc..83f87c41b18d 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -707,9 +707,11 @@ void __scsi_remove_device(struct scsi_device *sdev)
  **/
 void scsi_remove_device(struct scsi_device *sdev)
 {
-	down(&amp;sdev-&gt;host-&gt;scan_mutex);
+	struct Scsi_Host *shost = sdev-&gt;host;
+
+	down(&amp;shost-&gt;scan_mutex);
 	__scsi_remove_device(sdev);
-	up(&amp;sdev-&gt;host-&gt;scan_mutex);
+	up(&amp;shost-&gt;scan_mutex);
 }
 EXPORT_SYMBOL(scsi_remove_device);
 </pre><hr><pre>commit 1f09df8bfe358994fcb5f3dc4f890694c4069621
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 5 13:59:51 2005 -0400

    [PATCH] USB UHCI: remove the FSBR kernel timer
    
    This patch (as558) removes from the UHCI driver a kernel timer used for
    checking Full Speed Bandwidth Reclamation (FSBR).  The checking can be
    done during normal root-hub polling; it doesn't need a separate timer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 0d5d2545bf07..0c024898cbea 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -97,14 +97,9 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
-static inline void restart_timer(struct uhci_hcd *uhci)
-{
-	mod_timer(&amp;uhci-&gt;stall_timer, jiffies + msecs_to_jiffies(100));
-}
-
-#include "uhci-hub.c"
 #include "uhci-debug.c"
 #include "uhci-q.c"
+#include "uhci-hub.c"
 
 /*
  * Make sure the controller is completely inactive, unable to
@@ -160,7 +155,6 @@ static void hc_died(struct uhci_hcd *uhci)
 {
 	reset_hc(uhci);
 	uhci-&gt;hc_inaccessible = 1;
-	del_timer(&amp;uhci-&gt;stall_timer);
 }
 
 /*
@@ -287,8 +281,11 @@ __acquires(uhci-&gt;lock)
 	/* Enable resume-detect interrupts if they work.
 	 * Then enter Global Suspend mode, still configured.
 	 */
-	int_enable = (resume_detect_interrupts_are_broken(uhci) ?
-			0 : USBINTR_RESUME);
+	uhci-&gt;working_RD = 1;
+	int_enable = USBINTR_RESUME;
+	if (resume_detect_interrupts_are_broken(uhci)) {
+		uhci-&gt;working_RD = int_enable = 0;
+	}
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
 	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
 	mb();
@@ -315,7 +312,6 @@ __acquires(uhci-&gt;lock)
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	del_timer(&amp;uhci-&gt;stall_timer);
 	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
@@ -335,7 +331,6 @@ static void start_rh(struct uhci_hcd *uhci)
 	mb();
 	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	uhci_to_hcd(uhci)-&gt;poll_rh = 1;
-	restart_timer(uhci);
 }
 
 static void wakeup_rh(struct uhci_hcd *uhci)
@@ -374,20 +369,6 @@ __acquires(uhci-&gt;lock)
 	mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 }
 
-static void stall_callback(unsigned long _uhci)
-{
-	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, NULL);
-	check_fsbr(uhci);
-
-	if (!uhci-&gt;is_stopped)
-		restart_timer(uhci);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-}
-
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
@@ -418,8 +399,10 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 					"host controller halted, "
 					"very bad!\n");
 				hc_died(uhci);
-				spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-				return IRQ_HANDLED;
+
+				/* Force a callback in case there are
+				 * pending unlinks */
+				mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 			}
 			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 		}
@@ -427,10 +410,11 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 
 	if (status &amp; USBSTS_RD)
 		usb_hcd_poll_rh_status(hcd);
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, regs);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	else {
+		spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+		uhci_scan_schedule(uhci, regs);
+		spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	}
 
 	return IRQ_HANDLED;
 }
@@ -595,10 +579,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long) uhci;
-
 	uhci-&gt;fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			&amp;dma_handle, 0);
 	if (!uhci-&gt;fl) {
@@ -745,11 +725,11 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	reset_hc(uhci);
+	if (!uhci-&gt;hc_inaccessible)
+		reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	release_uhci(uhci);
 }
 
@@ -811,13 +791,12 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
 	uhci-&gt;hc_inaccessible = 1;
+	hcd-&gt;poll_rh = 0;
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	if (rc == 0)
-		del_timer_sync(&amp;hcd-&gt;rh_timer);
 	return rc;
 }
 
@@ -850,8 +829,11 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
-	if (hcd-&gt;poll_rh)
+	if (!uhci-&gt;working_RD) {
+		/* Suspended root hub needs to be polled */
+		hcd-&gt;poll_rh = 1;
 		usb_hcd_poll_rh_status(hcd);
+	}
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index bf9c5f9b508b..282f40b75881 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -345,9 +345,6 @@ enum uhci_rh_state {
 
 /*
  * This describes the full uhci information.
- *
- * Note how the "proper" USB information is just
- * a subset of what the full implementation needs.
  */
 struct uhci_hcd {
 
@@ -360,8 +357,6 @@ struct uhci_hcd {
 	struct dma_pool *qh_pool;
 	struct dma_pool *td_pool;
 
-	struct usb_bus *bus;
-
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
 	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
 
@@ -380,6 +375,8 @@ struct uhci_hcd {
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
+	unsigned int working_RD:1;		/* Suspended root hub doesn't
+						   need to be polled */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
@@ -405,9 +402,7 @@ struct uhci_hcd {
 	/* List of URB's awaiting completion callback */
 	struct list_head complete_list;		/* P: uhci-&gt;lock */
 
-	int rh_numports;
-
-	struct timer_list stall_timer;
+	int rh_numports;			/* Number of root-hub ports */
 
 	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
 };
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 4eace2b19ddb..a71e48a66805 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -145,15 +145,16 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	int status;
+	int status = 0;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	if (uhci-&gt;hc_inaccessible) {
-		status = 0;
-		goto done;
-	}
 
+	uhci_scan_schedule(uhci, NULL);
+	if (uhci-&gt;hc_inaccessible)
+		goto done;
+	check_fsbr(uhci);
 	uhci_check_ports(uhci);
+
 	status = get_hub_status_data(uhci, buf);
 
 	switch (uhci-&gt;rh_state) {
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bbb36cd6ed61..ea0d168a8c67 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -33,7 +33,7 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
 	if (uhci-&gt;is_stopped)
-		mod_timer(&amp;uhci-&gt;stall_timer, jiffies);
+		mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 	uhci-&gt;term_td-&gt;status |= cpu_to_le32(TD_CTRL_IOC); 
 }
 </pre><hr><pre>commit f1a15606d5be8490a122f1c94c554bd0f07d8d26
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 5 13:55:23 2005 -0400

    [PATCH] usbcore: small changes to HCD glue layer
    
    This patch (as549) introduces two small changes in the HCD glue layer.
    The first simply removes a redundant test.  The second allows root-hub
    polling to continue for a single iteration after a host controller dies;
    this is needed for the patch that follows.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 12ecdb03ee5f..1017a97a418b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1606,7 +1606,7 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd, struct pt_regs * r)
 		return IRQ_NONE;
 
 	hcd-&gt;saw_irq = 1;
-	if (hcd-&gt;state != start &amp;&amp; hcd-&gt;state == HC_STATE_HALT)
+	if (hcd-&gt;state == HC_STATE_HALT)
 		usb_hc_died (hcd);
 	return IRQ_HANDLED;
 }
@@ -1630,7 +1630,6 @@ void usb_hc_died (struct usb_hcd *hcd)
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered) {
 		hcd-&gt;poll_rh = 0;
-		del_timer(&amp;hcd-&gt;rh_timer);
 
 		/* make khubd clean up old urbs and devices */
 		usb_set_device_state (hcd-&gt;self.root_hub,</pre><hr><pre>commit b70d37bf61f278f9d9adf17c52af6b2d0ae7800c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:30:40 2005 -0400

    [SCSI] Fix module removal/device add race
    
    This patch (as546) fixes an oops-causing failure to check the return code
    from scsi_device_get.  The call can return an error if the LLD is being
    unloaded from memory.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 76577fae60fa..a0975c78b968 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -870,8 +870,12 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
  out_free_sdev:
 	if (res == SCSI_SCAN_LUN_PRESENT) {
 		if (sdevp) {
-			scsi_device_get(sdev);
-			*sdevp = sdev;
+			if (scsi_device_get(sdev) == 0) {
+				*sdevp = sdev;
+			} else {
+				__scsi_remove_device(sdev);
+				res = SCSI_SCAN_NO_RESPONSE;
+			}
 		}
 	} else {
 		if (sdev-&gt;host-&gt;hostt-&gt;slave_destroy)</pre><hr><pre>commit 903f4fed858a7b56b260cbd55d174fe54d188fb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:20:53 2005 -0400

    [SCSI] fix callers of scsi_remove_device() who already hold the scan muted
    
    This patch (as544) adds a private entry point to scsi_remove_device, for
    use when callers already own the scan_mutex.  The appropriate callers are
    modified to use the new entry point.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index ee6de1768e53..d05f778d31a8 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -124,6 +124,7 @@ extern void scsi_sysfs_unregister(void);
 extern void scsi_sysfs_device_initialize(struct scsi_device *);
 extern int scsi_sysfs_target_initialize(struct scsi_device *);
 extern struct scsi_transport_template blank_transport_template;
+extern void __scsi_remove_device(struct scsi_device *);
 
 extern struct bus_type scsi_bus_type;
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index dae59d1da07a..b8052d5206cc 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -653,7 +653,7 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 			error = attr_add(&amp;sdev-&gt;sdev_gendev,
 					sdev-&gt;host-&gt;hostt-&gt;sdev_attrs[i]);
 			if (error) {
-				scsi_remove_device(sdev);
+				__scsi_remove_device(sdev);
 				goto out;
 			}
 		}
@@ -667,7 +667,7 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 							scsi_sysfs_sdev_attrs[i]);
 			error = device_create_file(&amp;sdev-&gt;sdev_gendev, attr);
 			if (error) {
-				scsi_remove_device(sdev);
+				__scsi_remove_device(sdev);
 				goto out;
 			}
 		}
@@ -687,17 +687,10 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	return error;
 }
 
-/**
- * scsi_remove_device - unregister a device from the scsi bus
- * @sdev:	scsi_device to unregister
- **/
-void scsi_remove_device(struct scsi_device *sdev)
+void __scsi_remove_device(struct scsi_device *sdev)
 {
-	struct Scsi_Host *shost = sdev-&gt;host;
-
-	down(&amp;shost-&gt;scan_mutex);
 	if (scsi_device_set_state(sdev, SDEV_CANCEL) != 0)
-		goto out;
+		return;
 
 	class_device_unregister(&amp;sdev-&gt;sdev_classdev);
 	device_del(&amp;sdev-&gt;sdev_gendev);
@@ -706,8 +699,17 @@ void scsi_remove_device(struct scsi_device *sdev)
 		sdev-&gt;host-&gt;hostt-&gt;slave_destroy(sdev);
 	transport_unregister_device(&amp;sdev-&gt;sdev_gendev);
 	put_device(&amp;sdev-&gt;sdev_gendev);
-out:
-	up(&amp;shost-&gt;scan_mutex);
+}
+
+/**
+ * scsi_remove_device - unregister a device from the scsi bus
+ * @sdev:	scsi_device to unregister
+ **/
+void scsi_remove_device(struct scsi_device *sdev)
+{
+	down(&amp;sdev-&gt;host-&gt;scan_mutex);
+	__scsi_remove_device(sdev);
+	up(&amp;sdev-&gt;host-&gt;scan_mutex);
 }
 EXPORT_SYMBOL(scsi_remove_device);
 </pre><hr><pre>commit e517d3133f62c27b211f305a6dbd6f6ccac0db1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:18:45 2005 -0400

    [SCSI] add missing scan mutex to scsi_scan_target()
    
    This patch (as543) adds a private entry point to scsi_scan_target, for use
    when the caller already owns the scan_mutex, and updates the kerneldoc for
    that routine (which was badly out-of-date).  It converts scsi_scan_channel
    to use the new entry point.  Lastly, it modifies scsi_get_host_dev to make
    it acquire the scan_mutex, necessary since the routine adds a new
    scsi_device even if it doesn't do any actual scanning.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 19c9a232a754..76577fae60fa 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1276,27 +1276,8 @@ void scsi_rescan_device(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_rescan_device);
 
-/**
- * scsi_scan_target - scan a target id, possibly including all LUNs on the
- *     target.
- * @sdevsca:	Scsi_Device handle for scanning
- * @shost:	host to scan
- * @channel:	channel to scan
- * @id:		target id to scan
- *
- * Description:
- *     Scan the target id on @shost, @channel, and @id. Scan at least LUN
- *     0, and possibly all LUNs on the target id.
- *
- *     Use the pre-allocated @sdevscan as a handle for the scanning. This
- *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the
- *     scanning functions modify sdevscan-&gt;lun.
- *
- *     First try a REPORT LUN scan, if that does not scan the target, do a
- *     sequential scan of LUNs on the target id.
- **/
-void scsi_scan_target(struct device *parent, unsigned int channel,
-		      unsigned int id, unsigned int lun, int rescan)
+static void __scsi_scan_target(struct device *parent, unsigned int channel,
+		unsigned int id, unsigned int lun, int rescan)
 {
 	struct Scsi_Host *shost = dev_to_shost(parent);
 	int bflags = 0;
@@ -1310,9 +1291,7 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 		 */
 		return;
 
-
 	starget = scsi_alloc_target(parent, channel, id);
-
 	if (!starget)
 		return;
 
@@ -1358,6 +1337,33 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 
 	put_device(&amp;starget-&gt;dev);
 }
+
+/**
+ * scsi_scan_target - scan a target id, possibly including all LUNs on the
+ *     target.
+ * @parent:	host to scan
+ * @channel:	channel to scan
+ * @id:		target id to scan
+ * @lun:	Specific LUN to scan or SCAN_WILD_CARD
+ * @rescan:	passed to LUN scanning routines
+ *
+ * Description:
+ *     Scan the target id on @parent, @channel, and @id. Scan at least LUN 0,
+ *     and possibly all LUNs on the target id.
+ *
+ *     First try a REPORT LUN scan, if that does not scan the target, do a
+ *     sequential scan of LUNs on the target id.
+ **/
+void scsi_scan_target(struct device *parent, unsigned int channel,
+		      unsigned int id, unsigned int lun, int rescan)
+{
+	struct Scsi_Host *shost = dev_to_shost(parent);
+
+	down(&amp;shost-&gt;scan_mutex);
+	if (scsi_host_scan_allowed(shost))
+		__scsi_scan_target(parent, channel, id, lun, rescan);
+	up(&amp;shost-&gt;scan_mutex);
+}
 EXPORT_SYMBOL(scsi_scan_target);
 
 static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
@@ -1383,10 +1389,12 @@ static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 				order_id = shost-&gt;max_id - id - 1;
 			else
 				order_id = id;
-			scsi_scan_target(&amp;shost-&gt;shost_gendev, channel, order_id, lun, rescan);
+			__scsi_scan_target(&amp;shost-&gt;shost_gendev, channel,
+					order_id, lun, rescan);
 		}
 	else
-		scsi_scan_target(&amp;shost-&gt;shost_gendev, channel, id, lun, rescan);
+		__scsi_scan_target(&amp;shost-&gt;shost_gendev, channel,
+				id, lun, rescan);
 }
 
 int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
@@ -1484,12 +1492,15 @@ void scsi_forget_host(struct Scsi_Host *shost)
  */
 struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 {
-	struct scsi_device *sdev;
+	struct scsi_device *sdev = NULL;
 	struct scsi_target *starget;
 
+	down(&amp;shost-&gt;scan_mutex);
+	if (!scsi_host_scan_allowed(shost))
+		goto out;
 	starget = scsi_alloc_target(&amp;shost-&gt;shost_gendev, 0, shost-&gt;this_id);
 	if (!starget)
-		return NULL;
+		goto out;
 
 	sdev = scsi_alloc_sdev(starget, 0, NULL);
 	if (sdev) {
@@ -1497,6 +1508,8 @@ struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 		sdev-&gt;borken = 0;
 	}
 	put_device(&amp;starget-&gt;dev);
+ out:
+	up(&amp;shost-&gt;scan_mutex);
 	return sdev;
 }
 EXPORT_SYMBOL(scsi_get_host_dev);</pre><hr><pre>commit 3b4d7f79164853e10342d707e32307e0c8054982
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 11 15:50:32 2005 -0400

    [PATCH] USB: Support unbinding of the usb_generic driver
    
    This patch (as556) adds support for unbinding the usb_generic "driver".
    That driver only binds to USB devices, as opposed to interfaces, and it
    does nothing much besides marking which struct device's go with an
    overall USB device plus providing suspend/resume methods.  Now that
    users can unbind drivers at will using the sysfs "unbind" attribute, we
    need a rational way of dealing with USB devices that are no longer under
    full control of the USB stack.  The patch handles this by unconfiguring
    the device, thereby removing all the interfaces and their associated
    drivers and children.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 109f7558167a..087af73a59dd 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -65,6 +65,16 @@ static int generic_probe (struct device *dev)
 }
 static int generic_remove (struct device *dev)
 {
+	struct usb_device *udev = to_usb_device(dev);
+
+	/* if this is only an unbind, not a physical disconnect, then
+	 * unconfigure the device */
+	if (udev-&gt;state == USB_STATE_CONFIGURED)
+		usb_set_configuration(udev, 0);
+
+	/* in case the call failed or the device was suspended */
+	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
+		usb_disable_device(udev, 0);
 	return 0;
 }
 </pre><hr><pre>commit 3ea15966ed59f2bc20928c7b0496b4585f6de206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 11 10:15:39 2005 -0400

    [PATCH] USB: Add timeout to usb_lock_device_for_reset
    
    This patch (as555) modifies the already-awkward
    usb_lock_device_for_reset routine in usbcore by adding a timeout.  The
    whole point of the routine is that the caller wants to acquire some
    semaphores in the wrong order; protecting against the possibility of
    deadlock by timing out seems only prudent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index bc966dbc6021..109f7558167a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -912,7 +912,7 @@ int usb_trylock_device(struct usb_device *udev)
  * is neither BINDING nor BOUND.  Rather than sleeping to wait for the
  * lock, the routine polls repeatedly.  This is to prevent deadlock with
  * disconnect; in some drivers (such as usb-storage) the disconnect()
- * callback will block waiting for a device reset to complete.
+ * or suspend() method will block waiting for a device reset to complete.
  *
  * Returns a negative error code for failure, otherwise 1 or 0 to indicate
  * that the device will or will not have to be unlocked.  (0 can be
@@ -922,6 +922,8 @@ int usb_trylock_device(struct usb_device *udev)
 int usb_lock_device_for_reset(struct usb_device *udev,
 		struct usb_interface *iface)
 {
+	unsigned long jiffies_expire = jiffies + HZ;
+
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
 	if (udev-&gt;state == USB_STATE_SUSPENDED)
@@ -938,6 +940,12 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 	}
 
 	while (!usb_trylock_device(udev)) {
+
+		/* If we can't acquire the lock after waiting one second,
+		 * we're probably deadlocked */
+		if (time_after(jiffies, jiffies_expire))
+			return -EBUSY;
+
 		msleep(15);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return -ENODEV;</pre><hr><pre>commit bf193d3cd2a3b73f2df74f57106114867946c09c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 17:12:31 2005 -0400

    [PATCH] USB: Disconnect children when unbinding the hub driver
    
    This patch (as554) makes the hub driver disconnect any child USB devices
    when it is unbound from a hub.  Normally this will never happen, but
    there are a few oddball ways to unbind the hub driver while leaving the
    children intact.  For example, the new "unbind" sysfs attribute can be
    used for this purpose.
    
    Given that unbinding hubs with children is now safe, the patch also
    removes the code that prevented people from doing so using usbfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 56c082f34927..b4265aa7d45e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1238,7 +1238,6 @@ static int proc_ioctl (struct dev_state *ps, void __user *arg)
 	int			retval = 0;
 	struct usb_interface    *intf = NULL;
 	struct usb_driver       *driver = NULL;
-	int			i;
 
 	/* get input parameters and alloc buffer */
 	if (copy_from_user(&amp;ctrl, arg, sizeof (ctrl)))
@@ -1270,15 +1269,6 @@ static int proc_ioctl (struct dev_state *ps, void __user *arg)
 	/* disconnect kernel driver from interface */
 	case USBDEVFS_DISCONNECT:
 
-		/* don't allow the user to unbind the hub driver from
-		 * a hub with children to manage */
-		for (i = 0; i &lt; ps-&gt;dev-&gt;maxchild; ++i) {
-			if (ps-&gt;dev-&gt;children[i])
-				retval = -EBUSY;
-		}
-		if (retval)
-			break;
-
 		down_write(&amp;usb_bus_type.subsys.rwsem);
 		if (intf-&gt;dev.driver) {
 			driver = to_usb_driver(intf-&gt;dev.driver);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4a4b41f2665a..9f54e8330f78 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -729,10 +729,29 @@ static int hub_configure(struct usb_hub *hub,
 
 static unsigned highspeed_hubs;
 
+/* Called after the hub driver is unbound from a hub with children */
+static void hub_remove_children_work(void *__hub)
+{
+	struct usb_hub		*hub = __hub;
+	struct usb_device	*hdev = hub-&gt;hdev;
+	int			i;
+
+	kfree(hub);
+
+	usb_lock_device(hdev);
+	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
+		if (hdev-&gt;children[i])
+			usb_disconnect(&amp;hdev-&gt;children[i]);
+	}
+	usb_unlock_device(hdev);
+	usb_put_dev(hdev);
+}
+
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
+	int n, port1;
 
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
@@ -760,8 +779,27 @@ static void hub_disconnect(struct usb_interface *intf)
 		hub-&gt;buffer = NULL;
 	}
 
-	/* Free the memory */
-	kfree(hub);
+	/* If there are any children then this is an unbind only, not a
+	 * physical disconnection.  The active ports must be disabled
+	 * and later on we must call usb_disconnect().  We can't call
+	 * it now because we may not hold the hub's device lock.
+	 */
+	n = 0;
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		if (hdev-&gt;children[port1 - 1]) {
+			++n;
+			hub_port_disable(hub, port1, 1);
+		}
+	}
+
+	if (n == 0)
+		kfree(hub);
+	else {
+		/* Reuse the hub-&gt;leds work_struct for our own purposes */
+		INIT_WORK(&amp;hub-&gt;leds, hub_remove_children_work, hub);
+		schedule_work(&amp;hub-&gt;leds);
+		usb_get_dev(hdev);
+	}
 }
 
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)</pre><hr><pre>commit 8b28c7526a302bbfa618f7eab4ef961edd68c9a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 17:04:13 2005 -0400

    [PATCH] USB: Code motion in the hub driver
    
    This patch (as553) merely moves some code and deletes an unneeded test in
    the hub driver.  This is in preparation for the patch that follows.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a220a5e7f4a5..4a4b41f2665a 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -492,6 +492,23 @@ static int hub_hub_status(struct usb_hub *hub,
 	return ret;
 }
 
+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int ret;
+
+	if (hdev-&gt;children[port1-1] &amp;&amp; set_state) {
+		usb_set_device_state(hdev-&gt;children[port1-1],
+				USB_STATE_NOTATTACHED);
+	}
+	ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
+	if (ret)
+		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
+			port1, ret);
+
+	return ret;
+}
+
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -717,15 +734,12 @@ static void hub_disconnect(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
 
-	if (!hub)
-		return;
+	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	usb_set_intfdata (intf, NULL);
-
 	hub_quiesce(hub);
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
@@ -1430,23 +1444,6 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 	return status;
 }
 
-static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int ret;
-
-	if (hdev-&gt;children[port1-1] &amp;&amp; set_state) {
-		usb_set_device_state(hdev-&gt;children[port1-1],
-				USB_STATE_NOTATTACHED);
-	}
-	ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
-	if (ret)
-		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
-			port1, ret);
-
-	return ret;
-}
-
 /*
  * Disable a port and mark a logical connnect-change event, so that some
  * time later khubd will disconnect() any existing usb_device on the port</pre>
    <div class="pagination">
        <a href='2_135.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><span>[136]</span><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_137.html'>Next&gt;&gt;</a>
    <div>
</body>
