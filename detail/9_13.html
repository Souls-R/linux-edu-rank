<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by State University of New York at Stony Brook</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by State University of New York at Stony Brook</h1>
    <div class="pagination">
        <a href='9_12.html'>&lt;&lt;Prev</a><a href='9.html'>1</a><a href='9_2.html'>2</a><a href='9_3.html'>3</a><a href='9_4.html'>4</a><a href='9_5.html'>5</a><a href='9_6.html'>6</a><a href='9_7.html'>7</a><a href='9_8.html'>8</a><a href='9_9.html'>9</a><a href='9_10.html'>10</a><a href='9_11.html'>11</a><a href='9_12.html'>12</a><span>[13]</span><a href='9_14.html'>14</a><a href='9_14.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7eaa36e2d470ed63bf0c4e4dd8b09cc4a9e1c481
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:41 2006 -0800

    [PATCH] nfsd: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the nfs
    server code.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 640c92b2a9f7..b7179bd45a1e 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1310,7 +1310,7 @@ static inline void
 nfs4_file_downgrade(struct file *filp, unsigned int share_access)
 {
 	if (share_access &amp; NFS4_SHARE_ACCESS_WRITE) {
-		put_write_access(filp-&gt;f_dentry-&gt;d_inode);
+		put_write_access(filp-&gt;f_path.dentry-&gt;d_inode);
 		filp-&gt;f_mode = (filp-&gt;f_mode | FMODE_READ) &amp; ~FMODE_WRITE;
 	}
 }
@@ -1623,7 +1623,7 @@ static __be32
 nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_stateid *stp, struct nfsd4_open *open)
 {
 	struct file *filp = stp-&gt;st_vfs_file;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	unsigned int share_access, new_writer;
 	__be32 status;
 
@@ -1965,7 +1965,7 @@ search_close_lru(u32 st_id, int flags)
 static inline int
 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stateid *stp)
 {
-	return fhp-&gt;fh_dentry-&gt;d_inode != stp-&gt;st_vfs_file-&gt;f_dentry-&gt;d_inode;
+	return fhp-&gt;fh_dentry-&gt;d_inode != stp-&gt;st_vfs_file-&gt;f_path.dentry-&gt;d_inode;
 }
 
 static int
@@ -2862,7 +2862,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 	 * only the dentry:inode set.
 	 */
 	memset(&amp;file, 0, sizeof (struct file));
-	file.f_dentry = current_fh-&gt;fh_dentry;
+	file.f_path.dentry = current_fh-&gt;fh_dentry;
 
 	status = nfs_ok;
 	if (posix_test_lock(&amp;file, &amp;file_lock, &amp;conflock)) {
@@ -2952,7 +2952,7 @@ static int
 check_for_locks(struct file *filp, struct nfs4_stateowner *lowner)
 {
 	struct file_lock **flpp;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int status = 0;
 
 	lock_kernel();
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 39aed901514b..eedf2e3990a9 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -111,7 +111,7 @@ static ssize_t (*write_op[])(struct file *, char *, size_t) = {
 
 static ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
 {
-	ino_t ino =  file-&gt;f_dentry-&gt;d_inode-&gt;i_ino;
+	ino_t ino =  file-&gt;f_path.dentry-&gt;d_inode-&gt;i_ino;
 	char *data;
 	ssize_t rv;
 
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index bb4d926e4487..d610edde9386 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -736,10 +736,10 @@ static int
 nfsd_sync(struct file *filp)
 {
         int err;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
-	dprintk("nfsd: sync file %s\n", filp-&gt;f_dentry-&gt;d_name.name);
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
+	dprintk("nfsd: sync file %s\n", filp-&gt;f_path.dentry-&gt;d_name.name);
 	mutex_lock(&amp;inode-&gt;i_mutex);
-	err=nfsd_dosync(filp, filp-&gt;f_dentry, filp-&gt;f_op);
+	err=nfsd_dosync(filp, filp-&gt;f_path.dentry, filp-&gt;f_op);
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 
 	return err;
@@ -845,7 +845,7 @@ nfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	int		host_err;
 
 	err = nfserr_perm;
-	inode = file-&gt;f_dentry-&gt;d_inode;
+	inode = file-&gt;f_path.dentry-&gt;d_inode;
 #ifdef MSNFS
 	if ((fhp-&gt;fh_export-&gt;ex_flags &amp; NFSEXP_MSNFS) &amp;&amp;
 		(!lock_may_read(inode, offset, *count)))
@@ -883,7 +883,7 @@ nfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 		nfsdstats.io_read += host_err;
 		*count = host_err;
 		err = 0;
-		fsnotify_access(file-&gt;f_dentry);
+		fsnotify_access(file-&gt;f_path.dentry);
 	} else 
 		err = nfserrno(host_err);
 out:
@@ -917,11 +917,11 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	err = nfserr_perm;
 
 	if ((fhp-&gt;fh_export-&gt;ex_flags &amp; NFSEXP_MSNFS) &amp;&amp;
-		(!lock_may_write(file-&gt;f_dentry-&gt;d_inode, offset, cnt)))
+		(!lock_may_write(file-&gt;f_path.dentry-&gt;d_inode, offset, cnt)))
 		goto out;
 #endif
 
-	dentry = file-&gt;f_dentry;
+	dentry = file-&gt;f_path.dentry;
 	inode = dentry-&gt;d_inode;
 	exp   = fhp-&gt;fh_export;
 
@@ -950,7 +950,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	set_fs(oldfs);
 	if (host_err &gt;= 0) {
 		nfsdstats.io_write += cnt;
-		fsnotify_modify(file-&gt;f_dentry);
+		fsnotify_modify(file-&gt;f_path.dentry);
 	}
 
 	/* clear setuid/setgid flag after write */</pre><hr><pre>commit 01cce933d8b524d9312f5098c70fa1b6ac190572
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:40 2006 -0800

    [PATCH] nfs: change uses of f_{dentry,vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the nfs
    client code.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index b34cd16f472f..dee3d6c0f194 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -172,7 +172,7 @@ static
 int nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page *page)
 {
 	struct file	*file = desc-&gt;file;
-	struct inode	*inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode	*inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct rpc_cred	*cred = nfs_file_cred(file);
 	unsigned long	timestamp;
 	int		error;
@@ -183,7 +183,7 @@ int nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page *page)
 
  again:
 	timestamp = jiffies;
-	error = NFS_PROTO(inode)-&gt;readdir(file-&gt;f_dentry, cred, desc-&gt;entry-&gt;cookie, page,
+	error = NFS_PROTO(inode)-&gt;readdir(file-&gt;f_path.dentry, cred, desc-&gt;entry-&gt;cookie, page,
 					  NFS_SERVER(inode)-&gt;dtsize, desc-&gt;plus);
 	if (error &lt; 0) {
 		/* We requested READDIRPLUS, but the server doesn't grok it */
@@ -308,7 +308,7 @@ int find_dirent_index(nfs_readdir_descriptor_t *desc)
 static inline
 int find_dirent_page(nfs_readdir_descriptor_t *desc)
 {
-	struct inode	*inode = desc-&gt;file-&gt;f_dentry-&gt;d_inode;
+	struct inode	*inode = desc-&gt;file-&gt;f_path.dentry-&gt;d_inode;
 	struct page	*page;
 	int		status;
 
@@ -464,7 +464,7 @@ int uncached_readdir(nfs_readdir_descriptor_t *desc, void *dirent,
 		     filldir_t filldir)
 {
 	struct file	*file = desc-&gt;file;
-	struct inode	*inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode	*inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct rpc_cred	*cred = nfs_file_cred(file);
 	struct page	*page = NULL;
 	int		status;
@@ -477,7 +477,7 @@ int uncached_readdir(nfs_readdir_descriptor_t *desc, void *dirent,
 		status = -ENOMEM;
 		goto out;
 	}
-	desc-&gt;error = NFS_PROTO(inode)-&gt;readdir(file-&gt;f_dentry, cred, *desc-&gt;dir_cookie,
+	desc-&gt;error = NFS_PROTO(inode)-&gt;readdir(file-&gt;f_path.dentry, cred, *desc-&gt;dir_cookie,
 						page,
 						NFS_SERVER(inode)-&gt;dtsize,
 						desc-&gt;plus);
@@ -516,7 +516,7 @@ int uncached_readdir(nfs_readdir_descriptor_t *desc, void *dirent,
  */
 static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct dentry	*dentry = filp-&gt;f_dentry;
+	struct dentry	*dentry = filp-&gt;f_path.dentry;
 	struct inode	*inode = dentry-&gt;d_inode;
 	nfs_readdir_descriptor_t my_desc,
 			*desc = &amp;my_desc;
@@ -599,7 +599,7 @@ static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 
 loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int origin)
 {
-	mutex_lock(&amp;filp-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+	mutex_lock(&amp;filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 	switch (origin) {
 		case 1:
 			offset += filp-&gt;f_pos;
@@ -615,7 +615,7 @@ loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int origin)
 		((struct nfs_open_context *)filp-&gt;private_data)-&gt;dir_cookie = 0;
 	}
 out:
-	mutex_unlock(&amp;filp-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+	mutex_unlock(&amp;filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 	return offset;
 }
 
@@ -1102,7 +1102,7 @@ static int nfs_open_revalidate(struct dentry *dentry, struct nameidata *nd)
 
 static struct dentry *nfs_readdir_lookup(nfs_readdir_descriptor_t *desc)
 {
-	struct dentry *parent = desc-&gt;file-&gt;f_dentry;
+	struct dentry *parent = desc-&gt;file-&gt;f_path.dentry;
 	struct inode *dir = parent-&gt;d_inode;
 	struct nfs_entry *entry = desc-&gt;entry;
 	struct dentry *dentry, *alias;
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index f9d678f4ae06..bd21d7fde650 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -116,7 +116,7 @@ static inline int put_dreq(struct nfs_direct_req *dreq)
 ssize_t nfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov, loff_t pos, unsigned long nr_segs)
 {
 	dprintk("NFS: nfs_direct_IO (%s) off/no(%Ld/%lu) EINVAL\n",
-			iocb-&gt;ki_filp-&gt;f_dentry-&gt;d_name.name,
+			iocb-&gt;ki_filp-&gt;f_path.dentry-&gt;d_name.name,
 			(long long) pos, nr_segs);
 
 	return -EINVAL;
@@ -734,8 +734,8 @@ ssize_t nfs_file_direct_read(struct kiocb *iocb, const struct iovec *iov,
 	size_t count = iov[0].iov_len;
 
 	dprintk("nfs: direct read(%s/%s, %lu@%Ld)\n",
-		file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name,
-		file-&gt;f_dentry-&gt;d_name.name,
+		file-&gt;f_path.dentry-&gt;d_parent-&gt;d_name.name,
+		file-&gt;f_path.dentry-&gt;d_name.name,
 		(unsigned long) count, (long long) pos);
 
 	if (nr_segs != 1)
@@ -798,8 +798,8 @@ ssize_t nfs_file_direct_write(struct kiocb *iocb, const struct iovec *iov,
 	size_t count = iov[0].iov_len;
 
 	dfprintk(VFS, "nfs: direct write(%s/%s, %lu@%Ld)\n",
-		file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name,
-		file-&gt;f_dentry-&gt;d_name.name,
+		file-&gt;f_path.dentry-&gt;d_parent-&gt;d_name.name,
+		file-&gt;f_path.dentry-&gt;d_name.name,
 		(unsigned long) count, (long long) pos);
 
 	if (nr_segs != 1)
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 8e28bffc35a0..0dd6be346aa7 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -176,7 +176,7 @@ static int
 nfs_file_flush(struct file *file, fl_owner_t id)
 {
 	struct nfs_open_context *ctx = (struct nfs_open_context *)file-&gt;private_data;
-	struct inode	*inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode	*inode = file-&gt;f_path.dentry-&gt;d_inode;
 	int		status;
 
 	dfprintk(VFS, "nfs: flush(%s/%ld)\n", inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino);
@@ -201,7 +201,7 @@ static ssize_t
 nfs_file_read(struct kiocb *iocb, const struct iovec *iov,
 		unsigned long nr_segs, loff_t pos)
 {
-	struct dentry * dentry = iocb-&gt;ki_filp-&gt;f_dentry;
+	struct dentry * dentry = iocb-&gt;ki_filp-&gt;f_path.dentry;
 	struct inode * inode = dentry-&gt;d_inode;
 	ssize_t result;
 	size_t count = iov_length(iov, nr_segs);
@@ -226,7 +226,7 @@ static ssize_t
 nfs_file_sendfile(struct file *filp, loff_t *ppos, size_t count,
 		read_actor_t actor, void *target)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	ssize_t res;
 
@@ -243,7 +243,7 @@ nfs_file_sendfile(struct file *filp, loff_t *ppos, size_t count,
 static int
 nfs_file_mmap(struct file * file, struct vm_area_struct * vma)
 {
-	struct dentry *dentry = file-&gt;f_dentry;
+	struct dentry *dentry = file-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	int	status;
 
@@ -343,7 +343,7 @@ const struct address_space_operations nfs_file_aops = {
 static ssize_t nfs_file_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos)
 {
-	struct dentry * dentry = iocb-&gt;ki_filp-&gt;f_dentry;
+	struct dentry * dentry = iocb-&gt;ki_filp-&gt;f_path.dentry;
 	struct inode * inode = dentry-&gt;d_inode;
 	ssize_t result;
 	size_t count = iov_length(iov, nr_segs);
@@ -535,8 +535,8 @@ static int nfs_lock(struct file *filp, int cmd, struct file_lock *fl)
 static int nfs_flock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	dprintk("NFS: nfs_flock(f=%s/%ld, t=%x, fl=%x)\n",
-			filp-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;s_id,
-			filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino,
+			filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb-&gt;s_id,
+			filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_ino,
 			fl-&gt;fl_type, fl-&gt;fl_flags);
 
 	/*
diff --git a/fs/nfs/idmap.c b/fs/nfs/idmap.c
index 82ad7110a1c0..9d4a6b2d1996 100644
--- a/fs/nfs/idmap.c
+++ b/fs/nfs/idmap.c
@@ -377,7 +377,7 @@ idmap_pipe_upcall(struct file *filp, struct rpc_pipe_msg *msg,
 static ssize_t
 idmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)
 {
-        struct rpc_inode *rpci = RPC_I(filp-&gt;f_dentry-&gt;d_inode);
+        struct rpc_inode *rpci = RPC_I(filp-&gt;f_path.dentry-&gt;d_inode);
 	struct idmap *idmap = (struct idmap *)rpci-&gt;private;
 	struct idmap_msg im_in, *im = &amp;idmap-&gt;idmap_im;
 	struct idmap_hashtable *h;
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 36680d1061b0..63e470279309 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -496,7 +496,7 @@ void put_nfs_open_context(struct nfs_open_context *ctx)
  */
 static void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct nfs_inode *nfsi = NFS_I(inode);
 
 	filp-&gt;private_data = get_nfs_open_context(ctx);
@@ -528,7 +528,7 @@ struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_c
 
 static void nfs_file_clear_open_context(struct file *filp)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct nfs_open_context *ctx = (struct nfs_open_context *)filp-&gt;private_data;
 
 	if (ctx) {
@@ -551,7 +551,7 @@ int nfs_open(struct inode *inode, struct file *filp)
 	cred = rpcauth_lookupcred(NFS_CLIENT(inode)-&gt;cl_auth, 0);
 	if (IS_ERR(cred))
 		return PTR_ERR(cred);
-	ctx = alloc_nfs_open_context(filp-&gt;f_vfsmnt, filp-&gt;f_dentry, cred);
+	ctx = alloc_nfs_open_context(filp-&gt;f_path.mnt, filp-&gt;f_path.dentry, cred);
 	put_rpccred(cred);
 	if (ctx == NULL)
 		return -ENOMEM;
diff --git a/fs/nfs/nfs3proc.c b/fs/nfs/nfs3proc.c
index 510ae524f3fd..acd8fe9762d3 100644
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -841,7 +841,7 @@ static void nfs3_proc_commit_setup(struct nfs_write_data *data, int how)
 static int
 nfs3_proc_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
-	return nlmclnt_proc(filp-&gt;f_dentry-&gt;d_inode, cmd, fl);
+	return nlmclnt_proc(filp-&gt;f_path.dentry-&gt;d_inode, cmd, fl);
 }
 
 const struct nfs_rpc_ops nfs_v3_clientops = {
diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index 10f5e80ca157..560536ad74a4 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -651,7 +651,7 @@ nfs_proc_commit_setup(struct nfs_write_data *data, int how)
 static int
 nfs_proc_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
-	return nlmclnt_proc(filp-&gt;f_dentry-&gt;d_inode, cmd, fl);
+	return nlmclnt_proc(filp-&gt;f_path.dentry-&gt;d_inode, cmd, fl);
 }
 
 
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 594eb16879ef..345492e78643 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -754,8 +754,8 @@ int nfs_updatepage(struct file *file, struct page *page,
 	nfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);
 
 	dprintk("NFS:      nfs_updatepage(%s/%s %d@%Ld)\n",
-		file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name,
-		file-&gt;f_dentry-&gt;d_name.name, count,
+		file-&gt;f_path.dentry-&gt;d_parent-&gt;d_name.name,
+		file-&gt;f_path.dentry-&gt;d_name.name, count,
 		(long long)(page_offset(page) +offset));
 
 	/* If we're not using byte range locks, and we know the page</pre><hr><pre>commit 2485822d51f8b338d289abe00eb7ce5249794a08
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:40 2006 -0800

    [PATCH] isofs: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the isofs
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/isofs/compress.c b/fs/isofs/compress.c
index 731816332b12..6bbbdb53581d 100644
--- a/fs/isofs/compress.c
+++ b/fs/isofs/compress.c
@@ -42,7 +42,7 @@ static struct semaphore zisofs_zlib_semaphore;
  */
 static int zisofs_readpage(struct file *file, struct page *page)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct address_space *mapping = inode-&gt;i_mapping;
 	unsigned int maxpage, xpage, fpage, blockindex;
 	unsigned long offset;
diff --git a/fs/isofs/dir.c b/fs/isofs/dir.c
index 27e276987fd2..4af2548f97a9 100644
--- a/fs/isofs/dir.c
+++ b/fs/isofs/dir.c
@@ -183,7 +183,7 @@ static int do_isofs_readdir(struct inode *inode, struct file *filp,
 
 		/* Handle the case of the '..' directory */
 		if (de-&gt;name_len[0] == 1 &amp;&amp; de-&gt;name[0] == 1) {
-			inode_number = parent_ino(filp-&gt;f_dentry);
+			inode_number = parent_ino(filp-&gt;f_path.dentry);
 			if (filldir(dirent, "..", 2, filp-&gt;f_pos, inode_number, DT_DIR) &lt; 0)
 				break;
 			filp-&gt;f_pos += de_len;
@@ -255,8 +255,7 @@ static int isofs_readdir(struct file *filp,
 	int result;
 	char * tmpname;
 	struct iso_directory_record * tmpde;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
-
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 
 	tmpname = (char *)__get_free_page(GFP_KERNEL);
 	if (tmpname == NULL)</pre><hr><pre>commit dba32306099d6155b773ebe8fc5bcfab60d075d6
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:39 2006 -0800

    [PATCH] fat: change uses of f_{dentry,vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the fat
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index 69c439f44387..c16af246d245 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -579,7 +579,7 @@ static int __fat_readdir(struct inode *inode, struct file *filp, void *dirent,
 	if (!memcmp(de-&gt;name, MSDOS_DOT, MSDOS_NAME))
 		inum = inode-&gt;i_ino;
 	else if (!memcmp(de-&gt;name, MSDOS_DOTDOT, MSDOS_NAME)) {
-		inum = parent_ino(filp-&gt;f_dentry);
+		inum = parent_ino(filp-&gt;f_path.dentry);
 	} else {
 		loff_t i_pos = fat_make_i_pos(sb, bh, de);
 		struct inode *tmp = fat_iget(sb, i_pos);
@@ -643,7 +643,7 @@ static int __fat_readdir(struct inode *inode, struct file *filp, void *dirent,
 
 static int fat_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	return __fat_readdir(inode, filp, dirent, filldir, 0, 0);
 }
 
@@ -782,7 +782,7 @@ static long fat_compat_dir_ioctl(struct file *file, unsigned cmd,
 
 	set_fs(KERNEL_DS);
 	lock_kernel();
-	ret = fat_dir_ioctl(file-&gt;f_dentry-&gt;d_inode, file,
+	ret = fat_dir_ioctl(file-&gt;f_path.dentry-&gt;d_inode, file,
 			    cmd, (unsigned long) &amp;d);
 	unlock_kernel();
 	set_fs(oldfs);
diff --git a/fs/fat/file.c b/fs/fat/file.c
index 0aa813d944a6..c1237b70c1fe 100644
--- a/fs/fat/file.c
+++ b/fs/fat/file.c
@@ -92,7 +92,7 @@ int fat_generic_ioctl(struct inode *inode, struct file *filp,
 		}
 
 		/* This MUST be done before doing anything irreversible... */
-		err = notify_change(filp-&gt;f_dentry, &amp;ia);
+		err = notify_change(filp-&gt;f_path.dentry, &amp;ia);
 		if (err)
 			goto up;
 </pre><hr><pre>commit 9d549890e69156800878a486f832e92d8f3d7c97
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:38 2006 -0800

    [PATCH] ext4: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the ext4
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index f2ed3e7fb9f5..da80368b66f0 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -103,7 +103,7 @@ static int ext4_readdir(struct file * filp,
 	struct ext4_dir_entry_2 *de;
 	struct super_block *sb;
 	int err;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int ret = 0;
 
 	sb = inode-&gt;i_sb;
@@ -122,7 +122,7 @@ static int ext4_readdir(struct file * filp,
 		 * We don't set the inode dirty flag since it's not
 		 * critical that it get flushed back to the disk.
 		 */
-		EXT4_I(filp-&gt;f_dentry-&gt;d_inode)-&gt;i_flags &amp;= ~EXT4_INDEX_FL;
+		EXT4_I(filp-&gt;f_path.dentry-&gt;d_inode)-&gt;i_flags &amp;= ~EXT4_INDEX_FL;
 	}
 #endif
 	stored = 0;
@@ -402,7 +402,7 @@ static int call_filldir(struct file * filp, void * dirent,
 {
 	struct dir_private_info *info = filp-&gt;private_data;
 	loff_t	curr_pos;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct super_block * sb;
 	int error;
 
@@ -432,7 +432,7 @@ static int ext4_dx_readdir(struct file * filp,
 			 void * dirent, filldir_t filldir)
 {
 	struct dir_private_info *info = filp-&gt;private_data;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct fname *fname;
 	int	ret;
 
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 0b622c0624b7..3bbc24b58785 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -52,7 +52,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		unsigned long nr_segs, loff_t pos)
 {
 	struct file *file = iocb-&gt;ki_filp;
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	ssize_t ret;
 	int err;
 
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 22a737c306c7..500567dd53b6 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -256,7 +256,7 @@ int ext4_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 #ifdef CONFIG_COMPAT
 long ext4_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	int ret;
 
 	/* These are just misnamed, they actually get/put from/to user an int */
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 859990eac504..e5a74a5ac261 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -602,7 +602,7 @@ int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 
 	dxtrace(printk("In htree_fill_tree, start hash: %x:%x\n", start_hash,
 		       start_minor_hash));
-	dir = dir_file-&gt;f_dentry-&gt;d_inode;
+	dir = dir_file-&gt;f_path.dentry-&gt;d_inode;
 	if (!(EXT4_I(dir)-&gt;i_flags &amp; EXT4_INDEX_FL)) {
 		hinfo.hash_version = EXT4_SB(dir-&gt;i_sb)-&gt;s_def_hash_version;
 		hinfo.seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
@@ -613,7 +613,7 @@ int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 	}
 	hinfo.hash = start_hash;
 	hinfo.minor_hash = 0;
-	frame = dx_probe(NULL, dir_file-&gt;f_dentry-&gt;d_inode, &amp;hinfo, frames, &amp;err);
+	frame = dx_probe(NULL, dir_file-&gt;f_path.dentry-&gt;d_inode, &amp;hinfo, frames, &amp;err);
 	if (!frame)
 		return err;
 </pre><hr><pre>commit fe21a69389165b9641a8d0b89e00a71c4e5f5d59
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:38 2006 -0800

    [PATCH] ext3: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the ext3
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/ext3/dir.c b/fs/ext3/dir.c
index 5a9313ecd4ef..665adee99b31 100644
--- a/fs/ext3/dir.c
+++ b/fs/ext3/dir.c
@@ -103,7 +103,7 @@ static int ext3_readdir(struct file * filp,
 	struct ext3_dir_entry_2 *de;
 	struct super_block *sb;
 	int err;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int ret = 0;
 
 	sb = inode-&gt;i_sb;
@@ -122,7 +122,7 @@ static int ext3_readdir(struct file * filp,
 		 * We don't set the inode dirty flag since it's not
 		 * critical that it get flushed back to the disk.
 		 */
-		EXT3_I(filp-&gt;f_dentry-&gt;d_inode)-&gt;i_flags &amp;= ~EXT3_INDEX_FL;
+		EXT3_I(filp-&gt;f_path.dentry-&gt;d_inode)-&gt;i_flags &amp;= ~EXT3_INDEX_FL;
 	}
 #endif
 	stored = 0;
@@ -402,7 +402,7 @@ static int call_filldir(struct file * filp, void * dirent,
 {
 	struct dir_private_info *info = filp-&gt;private_data;
 	loff_t	curr_pos;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct super_block * sb;
 	int error;
 
@@ -432,7 +432,7 @@ static int ext3_dx_readdir(struct file * filp,
 			 void * dirent, filldir_t filldir)
 {
 	struct dir_private_info *info = filp-&gt;private_data;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct fname *fname;
 	int	ret;
 
diff --git a/fs/ext3/file.c b/fs/ext3/file.c
index e96c388047e0..881f6365c41a 100644
--- a/fs/ext3/file.c
+++ b/fs/ext3/file.c
@@ -52,7 +52,7 @@ ext3_file_write(struct kiocb *iocb, const struct iovec *iov,
 		unsigned long nr_segs, loff_t pos)
 {
 	struct file *file = iocb-&gt;ki_filp;
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	ssize_t ret;
 	int err;
 
diff --git a/fs/ext3/ioctl.c b/fs/ext3/ioctl.c
index 12daa6869572..9b8090d94e6c 100644
--- a/fs/ext3/ioctl.c
+++ b/fs/ext3/ioctl.c
@@ -257,7 +257,7 @@ int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 #ifdef CONFIG_COMPAT
 long ext3_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	int ret;
 
 	/* These are just misnamed, they actually get/put from/to user an int */
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index 60d2f9dbdb00..4df39c4315e1 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -602,7 +602,7 @@ int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 
 	dxtrace(printk("In htree_fill_tree, start hash: %x:%x\n", start_hash,
 		       start_minor_hash));
-	dir = dir_file-&gt;f_dentry-&gt;d_inode;
+	dir = dir_file-&gt;f_path.dentry-&gt;d_inode;
 	if (!(EXT3_I(dir)-&gt;i_flags &amp; EXT3_INDEX_FL)) {
 		hinfo.hash_version = EXT3_SB(dir-&gt;i_sb)-&gt;s_def_hash_version;
 		hinfo.seed = EXT3_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
@@ -613,7 +613,7 @@ int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 	}
 	hinfo.hash = start_hash;
 	hinfo.minor_hash = 0;
-	frame = dx_probe(NULL, dir_file-&gt;f_dentry-&gt;d_inode, &amp;hinfo, frames, &amp;err);
+	frame = dx_probe(NULL, dir_file-&gt;f_path.dentry-&gt;d_inode, &amp;hinfo, frames, &amp;err);
 	if (!frame)
 		return err;
 </pre><hr><pre>commit c29c6934304a05781c9bd1611bd98870689f34e7
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:37 2006 -0800

    [PATCH] ext2: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the ext2
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/ext2/dir.c b/fs/ext2/dir.c
index 3e7a84a1e509..0b02ba9642d2 100644
--- a/fs/ext2/dir.c
+++ b/fs/ext2/dir.c
@@ -248,7 +248,7 @@ static int
 ext2_readdir (struct file * filp, void * dirent, filldir_t filldir)
 {
 	loff_t pos = filp-&gt;f_pos;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct super_block *sb = inode-&gt;i_sb;
 	unsigned int offset = pos &amp; ~PAGE_CACHE_MASK;
 	unsigned long n = pos &gt;&gt; PAGE_CACHE_SHIFT;
diff --git a/fs/ext2/ioctl.c b/fs/ext2/ioctl.c
index e3cf8c81507f..4b099d310712 100644
--- a/fs/ext2/ioctl.c
+++ b/fs/ext2/ioctl.c
@@ -90,7 +90,7 @@ int ext2_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 #ifdef CONFIG_COMPAT
 long ext2_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	int ret;
 
 	/* These are just misnamed, they actually get/put from/to user an int */</pre><hr><pre>commit 2fddfeefeed703b7638af97aa3048f82a2d53b03
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:36 2006 -0800

    [PATCH] proc: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the proc
    filesystem code.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/proc/base.c b/fs/proc/base.c
index b859fc749c07..a71f1755bb57 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -472,7 +472,7 @@ static struct file_operations proc_mountstats_operations = {
 static ssize_t proc_info_read(struct file * file, char __user * buf,
 			  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	unsigned long page;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -512,7 +512,7 @@ static int mem_open(struct inode* inode, struct file* file)
 static ssize_t mem_read(struct file * file, char __user * buf,
 			size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file-&gt;f_dentry-&gt;d_inode);
+	struct task_struct *task = get_proc_task(file-&gt;f_path.dentry-&gt;d_inode);
 	char *page;
 	unsigned long src = *ppos;
 	int ret = -ESRCH;
@@ -584,7 +584,7 @@ static ssize_t mem_write(struct file * file, const char * buf,
 {
 	int copied;
 	char *page;
-	struct task_struct *task = get_proc_task(file-&gt;f_dentry-&gt;d_inode);
+	struct task_struct *task = get_proc_task(file-&gt;f_path.dentry-&gt;d_inode);
 	unsigned long dst = *ppos;
 
 	copied = -ESRCH;
@@ -654,7 +654,7 @@ static struct file_operations proc_mem_operations = {
 static ssize_t oom_adjust_read(struct file *file, char __user *buf,
 				size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file-&gt;f_dentry-&gt;d_inode);
+	struct task_struct *task = get_proc_task(file-&gt;f_path.dentry-&gt;d_inode);
 	char buffer[PROC_NUMBUF];
 	size_t len;
 	int oom_adjust;
@@ -694,7 +694,7 @@ static ssize_t oom_adjust_write(struct file *file, const char __user *buf,
 		return -EINVAL;
 	if (*end == '\n')
 		end++;
-	task = get_proc_task(file-&gt;f_dentry-&gt;d_inode);
+	task = get_proc_task(file-&gt;f_path.dentry-&gt;d_inode);
 	if (!task)
 		return -ESRCH;
 	if (oom_adjust &lt; task-&gt;oomkilladj &amp;&amp; !capable(CAP_SYS_RESOURCE)) {
@@ -718,7 +718,7 @@ static struct file_operations proc_oom_adjust_operations = {
 static ssize_t proc_loginuid_read(struct file * file, char __user * buf,
 				  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct task_struct *task = get_proc_task(inode);
 	ssize_t length;
 	char tmpbuf[TMPBUFLEN];
@@ -734,7 +734,7 @@ static ssize_t proc_loginuid_read(struct file * file, char __user * buf,
 static ssize_t proc_loginuid_write(struct file * file, const char __user * buf,
 				   size_t count, loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	char *page, *tmp;
 	ssize_t length;
 	uid_t loginuid;
@@ -1078,7 +1078,7 @@ static int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
 	char *name, int len,
 	instantiate_t instantiate, struct task_struct *task, void *ptr)
 {
-	struct dentry *child, *dir = filp-&gt;f_dentry;
+	struct dentry *child, *dir = filp-&gt;f_path.dentry;
 	struct inode *inode;
 	struct qstr qname;
 	ino_t ino = 0;
@@ -1157,8 +1157,8 @@ static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsm
 		spin_lock(&amp;files-&gt;file_lock);
 		file = fcheck_files(files, fd);
 		if (file) {
-			*mnt = mntget(file-&gt;f_vfsmnt);
-			*dentry = dget(file-&gt;f_dentry);
+			*mnt = mntget(file-&gt;f_path.mnt);
+			*dentry = dget(file-&gt;f_path.dentry);
 			spin_unlock(&amp;files-&gt;file_lock);
 			put_files_struct(files);
 			return 0;
@@ -1293,7 +1293,7 @@ static int proc_fd_fill_cache(struct file *filp, void *dirent, filldir_t filldir
 
 static int proc_readfd(struct file * filp, void * dirent, filldir_t filldir)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	struct task_struct *p = get_proc_task(inode);
 	unsigned int fd, tid, ino;
@@ -1440,7 +1440,7 @@ static int proc_pident_readdir(struct file *filp,
 {
 	int i;
 	int pid;
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	struct task_struct *task = get_proc_task(inode);
 	struct pid_entry *p, *last;
@@ -1496,7 +1496,7 @@ static int proc_pident_readdir(struct file *filp,
 static ssize_t proc_pid_attr_read(struct file * file, char __user * buf,
 				  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	unsigned long page;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -1512,7 +1512,7 @@ static ssize_t proc_pid_attr_read(struct file * file, char __user * buf,
 		goto out;
 
 	length = security_getprocattr(task,
-				      (char*)file-&gt;f_dentry-&gt;d_name.name,
+				      (char*)file-&gt;f_path.dentry-&gt;d_name.name,
 				      (void*)page, count);
 	if (length &gt;= 0)
 		length = simple_read_from_buffer(buf, count, ppos, (char *)page, length);
@@ -1526,7 +1526,7 @@ static ssize_t proc_pid_attr_read(struct file * file, char __user * buf,
 static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,
 				   size_t count, loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	char *page;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -1552,7 +1552,7 @@ static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,
 		goto out_free;
 
 	length = security_setprocattr(task,
-				      (char*)file-&gt;f_dentry-&gt;d_name.name,
+				      (char*)file-&gt;f_path.dentry-&gt;d_name.name,
 				      (void*)page, count);
 out_free:
 	free_page((unsigned long) page);
@@ -1994,7 +1994,7 @@ static int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldi
 int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	unsigned int nr = filp-&gt;f_pos - FIRST_PROCESS_ENTRY;
-	struct task_struct *reaper = get_proc_task(filp-&gt;f_dentry-&gt;d_inode);
+	struct task_struct *reaper = get_proc_task(filp-&gt;f_path.dentry-&gt;d_inode);
 	struct task_struct *task;
 	int tgid;
 
@@ -2235,7 +2235,7 @@ static int proc_task_fill_cache(struct file *filp, void *dirent, filldir_t filld
 /* for the /proc/TGID/task/ directories */
 static int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	struct task_struct *leader = get_proc_task(inode);
 	struct task_struct *task;
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 4ba03009cf72..853cb877d5f3 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -52,7 +52,7 @@ static ssize_t
 proc_file_read(struct file *file, char __user *buf, size_t nbytes,
 	       loff_t *ppos)
 {
-	struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = file-&gt;f_path.dentry-&gt;d_inode;
 	char 	*page;
 	ssize_t	retval=0;
 	int	eof=0;
@@ -203,7 +203,7 @@ static ssize_t
 proc_file_write(struct file *file, const char __user *buffer,
 		size_t count, loff_t *ppos)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct proc_dir_entry * dp;
 	
 	dp = PDE(inode);
@@ -432,7 +432,7 @@ int proc_readdir(struct file * filp,
 	struct proc_dir_entry * de;
 	unsigned int ino;
 	int i;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int ret = 0;
 
 	lock_kernel();
@@ -453,7 +453,7 @@ int proc_readdir(struct file * filp,
 			/* fall through */
 		case 1:
 			if (filldir(dirent, "..", 2, i,
-				    parent_ino(filp-&gt;f_dentry),
+				    parent_ino(filp-&gt;f_path.dentry),
 				    DT_DIR) &lt; 0)
 				goto out;
 			i++;
@@ -558,7 +558,7 @@ static void proc_kill_inodes(struct proc_dir_entry *de)
 	file_list_lock();
 	list_for_each(p, &amp;sb-&gt;s_files) {
 		struct file * filp = list_entry(p, struct file, f_u.fu_list);
-		struct dentry * dentry = filp-&gt;f_dentry;
+		struct dentry * dentry = filp-&gt;f_path.dentry;
 		struct inode * inode;
 		const struct file_operations *fops;
 
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index d7dbdf9e0f49..5ec67257e5f9 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -46,7 +46,7 @@ int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)
 	file = vma-&gt;vm_file;
 
 	if (file) {
-		struct inode *inode = vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode;
+		struct inode *inode = vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode;
 		dev = inode-&gt;i_sb-&gt;s_dev;
 		ino = inode-&gt;i_ino;
 	}
@@ -67,7 +67,7 @@ int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)
 		if (len &lt; 1)
 			len = 1;
 		seq_printf(m, "%*c", len, ' ');
-		seq_path(m, file-&gt;f_vfsmnt, file-&gt;f_dentry, "");
+		seq_path(m, file-&gt;f_path.mnt, file-&gt;f_path.dentry, "");
 	}
 
 	seq_putc(m, '\n');
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 6b769afac55a..55ade0d15621 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -94,8 +94,8 @@ int proc_exe_link(struct inode *inode, struct dentry **dentry, struct vfsmount *
 	}
 
 	if (vma) {
-		*mnt = mntget(vma-&gt;vm_file-&gt;f_vfsmnt);
-		*dentry = dget(vma-&gt;vm_file-&gt;f_dentry);
+		*mnt = mntget(vma-&gt;vm_file-&gt;f_path.mnt);
+		*dentry = dget(vma-&gt;vm_file-&gt;f_path.dentry);
 		result = 0;
 	}
 
@@ -135,7 +135,7 @@ static int show_map_internal(struct seq_file *m, void *v, struct mem_size_stats
 	int len;
 
 	if (file) {
-		struct inode *inode = vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode;
+		struct inode *inode = vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode;
 		dev = inode-&gt;i_sb-&gt;s_dev;
 		ino = inode-&gt;i_ino;
 	}
@@ -156,7 +156,7 @@ static int show_map_internal(struct seq_file *m, void *v, struct mem_size_stats
 	 */
 	if (file) {
 		pad_len_spaces(m, len);
-		seq_path(m, file-&gt;f_vfsmnt, file-&gt;f_dentry, "\n");
+		seq_path(m, file-&gt;f_path.mnt, file-&gt;f_path.dentry, "\n");
 	} else {
 		const char *name = arch_vma_name(vma);
 		if (!name) {
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index 091aa8e48e02..fcc5caf93f55 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -126,8 +126,8 @@ int proc_exe_link(struct inode *inode, struct dentry **dentry, struct vfsmount *
 	}
 
 	if (vma) {
-		*mnt = mntget(vma-&gt;vm_file-&gt;f_vfsmnt);
-		*dentry = dget(vma-&gt;vm_file-&gt;f_dentry);
+		*mnt = mntget(vma-&gt;vm_file-&gt;f_path.mnt);
+		*dentry = dget(vma-&gt;vm_file-&gt;f_path.dentry);
 		result = 0;
 	}
 </pre><hr><pre>commit f427f5d5d6b0eb729505a2d9c0a6cad22734a74c
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:36 2006 -0800

    [PATCH] sysfs: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the sysfs
    filesystem code.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/sysfs/bin.c b/fs/sysfs/bin.c
index 98022e41cda1..e8f540d38d48 100644
--- a/fs/sysfs/bin.c
+++ b/fs/sysfs/bin.c
@@ -35,7 +35,7 @@ static ssize_t
 read(struct file * file, char __user * userbuf, size_t count, loff_t * off)
 {
 	char *buffer = file-&gt;private_data;
-	struct dentry *dentry = file-&gt;f_dentry;
+	struct dentry *dentry = file-&gt;f_path.dentry;
 	int size = dentry-&gt;d_inode-&gt;i_size;
 	loff_t offs = *off;
 	int ret;
@@ -81,7 +81,7 @@ static ssize_t write(struct file * file, const char __user * userbuf,
 		     size_t count, loff_t * off)
 {
 	char *buffer = file-&gt;private_data;
-	struct dentry *dentry = file-&gt;f_dentry;
+	struct dentry *dentry = file-&gt;f_path.dentry;
 	int size = dentry-&gt;d_inode-&gt;i_size;
 	loff_t offs = *off;
 
@@ -105,7 +105,7 @@ static ssize_t write(struct file * file, const char __user * userbuf,
 
 static int mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct dentry *dentry = file-&gt;f_dentry;
+	struct dentry *dentry = file-&gt;f_path.dentry;
 	struct bin_attribute *attr = to_bin_attr(dentry);
 	struct kobject *kobj = to_kobj(dentry-&gt;d_parent);
 
@@ -117,8 +117,8 @@ static int mmap(struct file *file, struct vm_area_struct *vma)
 
 static int open(struct inode * inode, struct file * file)
 {
-	struct kobject *kobj = sysfs_get_kobject(file-&gt;f_dentry-&gt;d_parent);
-	struct bin_attribute * attr = to_bin_attr(file-&gt;f_dentry);
+	struct kobject *kobj = sysfs_get_kobject(file-&gt;f_path.dentry-&gt;d_parent);
+	struct bin_attribute * attr = to_bin_attr(file-&gt;f_path.dentry);
 	int error = -EINVAL;
 
 	if (!kobj || !attr)
@@ -153,8 +153,8 @@ static int open(struct inode * inode, struct file * file)
 
 static int release(struct inode * inode, struct file * file)
 {
-	struct kobject * kobj = to_kobj(file-&gt;f_dentry-&gt;d_parent);
-	struct bin_attribute * attr = to_bin_attr(file-&gt;f_dentry);
+	struct kobject * kobj = to_kobj(file-&gt;f_path.dentry-&gt;d_parent);
+	struct bin_attribute * attr = to_bin_attr(file-&gt;f_path.dentry);
 	u8 * buffer = file-&gt;private_data;
 
 	if (kobj) 
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index a5782e8c7f07..511edef8b321 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -419,7 +419,7 @@ int sysfs_move_dir(struct kobject *kobj, struct kobject *new_parent)
 
 static int sysfs_dir_open(struct inode *inode, struct file *file)
 {
-	struct dentry * dentry = file-&gt;f_dentry;
+	struct dentry * dentry = file-&gt;f_path.dentry;
 	struct sysfs_dirent * parent_sd = dentry-&gt;d_fsdata;
 
 	mutex_lock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
@@ -432,7 +432,7 @@ static int sysfs_dir_open(struct inode *inode, struct file *file)
 
 static int sysfs_dir_close(struct inode *inode, struct file *file)
 {
-	struct dentry * dentry = file-&gt;f_dentry;
+	struct dentry * dentry = file-&gt;f_path.dentry;
 	struct sysfs_dirent * cursor = file-&gt;private_data;
 
 	mutex_lock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
@@ -452,7 +452,7 @@ static inline unsigned char dt_type(struct sysfs_dirent *sd)
 
 static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct sysfs_dirent * parent_sd = dentry-&gt;d_fsdata;
 	struct sysfs_dirent *cursor = filp-&gt;private_data;
 	struct list_head *p, *q = &amp;cursor-&gt;s_sibling;
@@ -509,7 +509,7 @@ static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
 
 static loff_t sysfs_dir_lseek(struct file * file, loff_t offset, int origin)
 {
-	struct dentry * dentry = file-&gt;f_dentry;
+	struct dentry * dentry = file-&gt;f_path.dentry;
 
 	mutex_lock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
 	switch (origin) {
@@ -519,7 +519,7 @@ static loff_t sysfs_dir_lseek(struct file * file, loff_t offset, int origin)
 			if (offset &gt;= 0)
 				break;
 		default:
-			mutex_unlock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+			mutex_unlock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 			return -EINVAL;
 	}
 	if (offset != file-&gt;f_pos) {
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 95c165101c98..9cfe53e1e00d 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -154,7 +154,7 @@ sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 
 	down(&amp;buffer-&gt;sem);
 	if (buffer-&gt;needs_read_fill) {
-		if ((retval = fill_read_buffer(file-&gt;f_dentry,buffer)))
+		if ((retval = fill_read_buffer(file-&gt;f_path.dentry,buffer)))
 			goto out;
 	}
 	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
@@ -245,7 +245,7 @@ sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t
 	down(&amp;buffer-&gt;sem);
 	len = fill_write_buffer(buffer, buf, count);
 	if (len &gt; 0)
-		len = flush_write_buffer(file-&gt;f_dentry, buffer, len);
+		len = flush_write_buffer(file-&gt;f_path.dentry, buffer, len);
 	if (len &gt; 0)
 		*ppos += len;
 	up(&amp;buffer-&gt;sem);
@@ -254,8 +254,8 @@ sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t
 
 static int check_perm(struct inode * inode, struct file * file)
 {
-	struct kobject *kobj = sysfs_get_kobject(file-&gt;f_dentry-&gt;d_parent);
-	struct attribute * attr = to_attr(file-&gt;f_dentry);
+	struct kobject *kobj = sysfs_get_kobject(file-&gt;f_path.dentry-&gt;d_parent);
+	struct attribute * attr = to_attr(file-&gt;f_path.dentry);
 	struct sysfs_buffer * buffer;
 	struct sysfs_ops * ops = NULL;
 	int error = 0;
@@ -337,8 +337,8 @@ static int sysfs_open_file(struct inode * inode, struct file * filp)
 
 static int sysfs_release(struct inode * inode, struct file * filp)
 {
-	struct kobject * kobj = to_kobj(filp-&gt;f_dentry-&gt;d_parent);
-	struct attribute * attr = to_attr(filp-&gt;f_dentry);
+	struct kobject * kobj = to_kobj(filp-&gt;f_path.dentry-&gt;d_parent);
+	struct attribute * attr = to_attr(filp-&gt;f_path.dentry);
 	struct module * owner = attr-&gt;owner;
 	struct sysfs_buffer * buffer = filp-&gt;private_data;
 
@@ -372,8 +372,8 @@ static int sysfs_release(struct inode * inode, struct file * filp)
 static unsigned int sysfs_poll(struct file *filp, poll_table *wait)
 {
 	struct sysfs_buffer * buffer = filp-&gt;private_data;
-	struct kobject * kobj = to_kobj(filp-&gt;f_dentry-&gt;d_parent);
-	struct sysfs_dirent * sd = filp-&gt;f_dentry-&gt;d_fsdata;
+	struct kobject * kobj = to_kobj(filp-&gt;f_path.dentry-&gt;d_parent);
+	struct sysfs_dirent * sd = filp-&gt;f_path.dentry-&gt;d_fsdata;
 	int res = 0;
 
 	poll_wait(filp, &amp;kobj-&gt;poll, wait);</pre><hr><pre>commit 0f7fc9e4d03987fe29f6dd4aa67e4c56eb7ecb05
Author: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:35 2006 -0800

    [PATCH] VFS: change struct file to use struct path
    
    This patch changes struct file to use struct path instead of having
    independent pointers to struct dentry and struct vfsmount, and converts all
    users of f_{dentry,vfsmnt} in fs/ to use f_path.{dentry,mnt}.
    
    Additionally, it adds two #define's to make the transition easier for users of
    the f_dentry and f_vfsmnt.
    
    Signed-off-by: Josef "Jeff" Sipek &lt;jsipek@cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/binfmt_aout.c b/fs/binfmt_aout.c
index 517e111bb7ef..813a887cd2b3 100644
--- a/fs/binfmt_aout.c
+++ b/fs/binfmt_aout.c
@@ -274,7 +274,7 @@ static int load_aout_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 	if ((N_MAGIC(ex) != ZMAGIC &amp;&amp; N_MAGIC(ex) != OMAGIC &amp;&amp;
 	     N_MAGIC(ex) != QMAGIC &amp;&amp; N_MAGIC(ex) != NMAGIC) ||
 	    N_TRSIZE(ex) || N_DRSIZE(ex) ||
-	    i_size_read(bprm-&gt;file-&gt;f_dentry-&gt;d_inode) &lt; ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {
+	    i_size_read(bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode) &lt; ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {
 		return -ENOEXEC;
 	}
 
@@ -389,7 +389,7 @@ static int load_aout_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 		{
 			printk(KERN_WARNING 
 			       "fd_offset is not page aligned. Please convert program: %s\n",
-			       bprm-&gt;file-&gt;f_dentry-&gt;d_name.name);
+			       bprm-&gt;file-&gt;f_path.dentry-&gt;d_name.name);
 			error_time = jiffies;
 		}
 
@@ -469,7 +469,7 @@ static int load_aout_library(struct file *file)
 	int retval;
 	struct exec ex;
 
-	inode = file-&gt;f_dentry-&gt;d_inode;
+	inode = file-&gt;f_path.dentry-&gt;d_inode;
 
 	retval = -ENOEXEC;
 	error = kernel_read(file, 0, (char *) &amp;ex, sizeof(ex));
@@ -506,7 +506,7 @@ static int load_aout_library(struct file *file)
 		{
 			printk(KERN_WARNING 
 			       "N_TXTOFF is not page aligned. Please convert library: %s\n",
-			       file-&gt;f_dentry-&gt;d_name.name);
+			       file-&gt;f_path.dentry-&gt;d_name.name);
 			error_time = jiffies;
 		}
 		down_write(&amp;current-&gt;mm-&gt;mmap_sem);
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index be5869d34999..c6dbb4a7ec78 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -1190,7 +1190,7 @@ static int maydump(struct vm_area_struct *vma)
 
 	/* Dump shared memory only if mapped from an anonymous file. */
 	if (vma-&gt;vm_flags &amp; VM_SHARED)
-		return vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_nlink == 0;
+		return vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode-&gt;i_nlink == 0;
 
 	/* If it hasn't been written to, don't write it out */
 	if (!vma-&gt;anon_vma)
diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
index ed9a61c6beb3..9f0b7efc3df5 100644
--- a/fs/binfmt_elf_fdpic.c
+++ b/fs/binfmt_elf_fdpic.c
@@ -855,7 +855,7 @@ static int elf_fdpic_map_file(struct elf_fdpic_params *params,
 
 dynamic_error:
 	printk("ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\n",
-	       what, file-&gt;f_dentry-&gt;d_inode-&gt;i_ino);
+	       what, file-&gt;f_path.dentry-&gt;d_inode-&gt;i_ino);
 	return -ELIBBAD;
 }
 
@@ -1186,7 +1186,7 @@ static int maydump(struct vm_area_struct *vma)
 
 	/* Dump shared memory only if mapped from an anonymous file. */
 	if (vma-&gt;vm_flags &amp; VM_SHARED) {
-		if (vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_nlink == 0) {
+		if (vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode-&gt;i_nlink == 0) {
 			kdcore("%08lx: %08lx: no (share)", vma-&gt;vm_start, vma-&gt;vm_flags);
 			return 1;
 		}
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index a62fd4018a20..ae8595d49856 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -429,7 +429,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 	int ret;
 
 	hdr = ((struct flat_hdr *) bprm-&gt;buf);		/* exec-header */
-	inode = bprm-&gt;file-&gt;f_dentry-&gt;d_inode;
+	inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;
 
 	text_len  = ntohl(hdr-&gt;data_start);
 	data_len  = ntohl(hdr-&gt;data_end) - ntohl(hdr-&gt;data_start);
diff --git a/fs/binfmt_misc.c b/fs/binfmt_misc.c
index 1713c48fef54..00687ea62738 100644
--- a/fs/binfmt_misc.c
+++ b/fs/binfmt_misc.c
@@ -542,7 +542,7 @@ static void kill_node(Node *e)
 static ssize_t
 bm_entry_read(struct file * file, char __user * buf, size_t nbytes, loff_t *ppos)
 {
-	Node *e = file-&gt;f_dentry-&gt;d_inode-&gt;i_private;
+	Node *e = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;
 	loff_t pos = *ppos;
 	ssize_t res;
 	char *page;
@@ -576,7 +576,7 @@ static ssize_t bm_entry_write(struct file *file, const char __user *buffer,
 				size_t count, loff_t *ppos)
 {
 	struct dentry *root;
-	Node *e = file-&gt;f_dentry-&gt;d_inode-&gt;i_private;
+	Node *e = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;
 	int res = parse_command(buffer, count);
 
 	switch (res) {
@@ -584,7 +584,7 @@ static ssize_t bm_entry_write(struct file *file, const char __user *buffer,
 			break;
 		case 2: set_bit(Enabled, &amp;e-&gt;flags);
 			break;
-		case 3: root = dget(file-&gt;f_vfsmnt-&gt;mnt_sb-&gt;s_root);
+		case 3: root = dget(file-&gt;f_path.mnt-&gt;mnt_sb-&gt;s_root);
 			mutex_lock(&amp;root-&gt;d_inode-&gt;i_mutex);
 
 			kill_node(e);
@@ -610,7 +610,7 @@ static ssize_t bm_register_write(struct file *file, const char __user *buffer,
 	Node *e;
 	struct inode *inode;
 	struct dentry *root, *dentry;
-	struct super_block *sb = file-&gt;f_vfsmnt-&gt;mnt_sb;
+	struct super_block *sb = file-&gt;f_path.mnt-&gt;mnt_sb;
 	int err = 0;
 
 	e = create_entry(buffer, count);
@@ -699,7 +699,7 @@ static ssize_t bm_status_write(struct file * file, const char __user * buffer,
 	switch (res) {
 		case 1: enabled = 0; break;
 		case 2: enabled = 1; break;
-		case 3: root = dget(file-&gt;f_vfsmnt-&gt;mnt_sb-&gt;s_root);
+		case 3: root = dget(file-&gt;f_path.mnt-&gt;mnt_sb-&gt;s_root);
 			mutex_lock(&amp;root-&gt;d_inode-&gt;i_mutex);
 
 			while (!list_empty(&amp;entries))
diff --git a/fs/block_dev.c b/fs/block_dev.c
index f3c3a44dd8b6..197f93921847 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -190,7 +190,7 @@ static int blkdev_commit_write(struct file *file, struct page *page, unsigned fr
 
 /*
  * private llseek:
- * for a block special file file-&gt;f_dentry-&gt;d_inode-&gt;i_size is zero
+ * for a block special file file-&gt;f_path.dentry-&gt;d_inode-&gt;i_size is zero
  * so we compute the size by hand (just as in block_read/write above)
  */
 static loff_t block_llseek(struct file *file, loff_t offset, int origin)
@@ -1013,7 +1013,7 @@ static int __blkdev_get(struct block_device *bdev, mode_t mode, unsigned flags,
 	struct dentry fake_dentry = {};
 	fake_file.f_mode = mode;
 	fake_file.f_flags = flags;
-	fake_file.f_dentry = &amp;fake_dentry;
+	fake_file.f_path.dentry = &amp;fake_dentry;
 	fake_dentry.d_inode = bdev-&gt;bd_inode;
 
 	return do_open(bdev, &amp;fake_file, for_part);
diff --git a/fs/compat.c b/fs/compat.c
index a7e3f162fb15..b766964a625c 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -232,7 +232,7 @@ asmlinkage long compat_sys_fstatfs(unsigned int fd, struct compat_statfs __user
 	file = fget(fd);
 	if (!file)
 		goto out;
-	error = vfs_statfs(file-&gt;f_dentry, &amp;tmp);
+	error = vfs_statfs(file-&gt;f_path.dentry, &amp;tmp);
 	if (!error)
 		error = put_compat_statfs(buf, &amp;tmp);
 	fput(file);
@@ -303,7 +303,7 @@ asmlinkage long compat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct c
 	file = fget(fd);
 	if (!file)
 		goto out;
-	error = vfs_statfs(file-&gt;f_dentry, &amp;tmp);
+	error = vfs_statfs(file-&gt;f_path.dentry, &amp;tmp);
 	if (!error)
 		error = put_compat_statfs64(buf, &amp;tmp);
 	fput(file);
@@ -365,7 +365,7 @@ static void compat_ioctl_error(struct file *filp, unsigned int fd,
 	/* find the name of the device. */
 	path = (char *)__get_free_page(GFP_KERNEL);
 	if (path) {
-		fn = d_path(filp-&gt;f_dentry, filp-&gt;f_vfsmnt, path, PAGE_SIZE);
+		fn = d_path(filp-&gt;f_path.dentry, filp-&gt;f_path.mnt, path, PAGE_SIZE);
 		if (IS_ERR(fn))
 			fn = "?";
 	}
@@ -416,7 +416,7 @@ asmlinkage long compat_sys_ioctl(unsigned int fd, unsigned int cmd,
 	case FIBMAP:
 	case FIGETBSZ:
 	case FIONREAD:
-		if (S_ISREG(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode))
+		if (S_ISREG(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode))
 			break;
 		/*FALL THROUGH*/
 
@@ -438,7 +438,7 @@ asmlinkage long compat_sys_ioctl(unsigned int fd, unsigned int cmd,
 			goto found_handler;
 	}
 
-	if (S_ISSOCK(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode) &amp;&amp;
+	if (S_ISSOCK(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode) &amp;&amp;
 	    cmd &gt;= SIOCDEVPRIVATE &amp;&amp; cmd &lt;= (SIOCDEVPRIVATE + 15)) {
 		error = siocdevprivate_ioctl(fd, cmd, arg);
 	} else {
@@ -1259,7 +1259,7 @@ static ssize_t compat_do_readv_writev(int type, struct file *file,
 	if (iov != iovstack)
 		kfree(iov);
 	if ((ret + (type == READ)) &gt; 0) {
-		struct dentry *dentry = file-&gt;f_dentry;
+		struct dentry *dentry = file-&gt;f_path.dentry;
 		if (type == READ)
 			fsnotify_access(dentry);
 		else
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index bcc3caf5d820..c81c958b3e1d 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -1177,7 +1177,7 @@ static int cdrom_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long ar
 static int vt_check(struct file *file)
 {
 	struct tty_struct *tty;
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	
 	if (file-&gt;f_op-&gt;ioctl != tty_ioctl)
 		return -EINVAL;
diff --git a/fs/dnotify.c b/fs/dnotify.c
index 1f26a2b9eee1..936409fcd939 100644
--- a/fs/dnotify.c
+++ b/fs/dnotify.c
@@ -42,7 +42,7 @@ void dnotify_flush(struct file *filp, fl_owner_t id)
 	struct dnotify_struct **prev;
 	struct inode *inode;
 
-	inode = filp-&gt;f_dentry-&gt;d_inode;
+	inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	if (!S_ISDIR(inode-&gt;i_mode))
 		return;
 	spin_lock(&amp;inode-&gt;i_lock);
@@ -74,7 +74,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 	}
 	if (!dir_notify_enable)
 		return -EINVAL;
-	inode = filp-&gt;f_dentry-&gt;d_inode;
+	inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	if (!S_ISDIR(inode-&gt;i_mode))
 		return -ENOTDIR;
 	dn = kmem_cache_alloc(dn_cache, GFP_KERNEL);
diff --git a/fs/dquot.c b/fs/dquot.c
index 89066b19124d..0952cc474d9a 100644
--- a/fs/dquot.c
+++ b/fs/dquot.c
@@ -694,9 +694,9 @@ static void add_dquot_ref(struct super_block *sb, int type)
 	file_list_lock();
 	list_for_each(p, &amp;sb-&gt;s_files) {
 		struct file *filp = list_entry(p, struct file, f_u.fu_list);
-		struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+		struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 		if (filp-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; dqinit_needed(inode, type)) {
-			struct dentry *dentry = dget(filp-&gt;f_dentry);
+			struct dentry *dentry = dget(filp-&gt;f_path.dentry);
 			file_list_unlock();
 			sb-&gt;dq_op-&gt;initialize(inode, type);
 			dput(dentry);
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 88a6f8d0b88e..3ae644e7e860 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -795,8 +795,8 @@ static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
 		goto eexit_4;
 	dentry-&gt;d_op = &amp;eventpollfs_dentry_operations;
 	d_add(dentry, inode);
-	file-&gt;f_vfsmnt = mntget(eventpoll_mnt);
-	file-&gt;f_dentry = dentry;
+	file-&gt;f_path.mnt = mntget(eventpoll_mnt);
+	file-&gt;f_path.dentry = dentry;
 	file-&gt;f_mapping = inode-&gt;i_mapping;
 
 	file-&gt;f_pos = 0;
diff --git a/fs/exec.c b/fs/exec.c
index add0e03c3ea9..60433e2254a4 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -912,7 +912,7 @@ EXPORT_SYMBOL(flush_old_exec);
 int prepare_binprm(struct linux_binprm *bprm)
 {
 	int mode;
-	struct inode * inode = bprm-&gt;file-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;
 	int retval;
 
 	mode = inode-&gt;i_mode;
@@ -922,7 +922,7 @@ int prepare_binprm(struct linux_binprm *bprm)
 	bprm-&gt;e_uid = current-&gt;euid;
 	bprm-&gt;e_gid = current-&gt;egid;
 
-	if(!(bprm-&gt;file-&gt;f_vfsmnt-&gt;mnt_flags &amp; MNT_NOSUID)) {
+	if(!(bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)) {
 		/* Set-uid? */
 		if (mode &amp; S_ISUID) {
 			current-&gt;personality &amp;= ~PER_CLEAR_ON_SETID;
@@ -1519,10 +1519,10 @@ int do_coredump(long signr, int exit_code, struct pt_regs * regs)
 				 0600);
 	if (IS_ERR(file))
 		goto fail_unlock;
-	inode = file-&gt;f_dentry-&gt;d_inode;
+	inode = file-&gt;f_path.dentry-&gt;d_inode;
 	if (inode-&gt;i_nlink &gt; 1)
 		goto close_fail;	/* multiple links - don't dump */
-	if (!ispipe &amp;&amp; d_unhashed(file-&gt;f_dentry))
+	if (!ispipe &amp;&amp; d_unhashed(file-&gt;f_path.dentry))
 		goto close_fail;
 
 	/* AK: actually i see no reason to not allow this for named pipes etc.,
@@ -1533,7 +1533,7 @@ int do_coredump(long signr, int exit_code, struct pt_regs * regs)
 		goto close_fail;
 	if (!file-&gt;f_op-&gt;write)
 		goto close_fail;
-	if (!ispipe &amp;&amp; do_truncate(file-&gt;f_dentry, 0, 0, file) != 0)
+	if (!ispipe &amp;&amp; do_truncate(file-&gt;f_path.dentry, 0, 0, file) != 0)
 		goto close_fail;
 
 	retval = binfmt-&gt;core_dump(signr, regs, file);
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 4740d35e52cd..2bdaef35da54 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -204,7 +204,7 @@ asmlinkage long sys_dup(unsigned int fildes)
 
 static int setfl(int fd, struct file * filp, unsigned long arg)
 {
-	struct inode * inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int error = 0;
 
 	/*
diff --git a/fs/file_table.c b/fs/file_table.c
index 24f25a057d9c..4c17a18d8c10 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -152,8 +152,8 @@ EXPORT_SYMBOL(fput);
  */
 void fastcall __fput(struct file *file)
 {
-	struct dentry *dentry = file-&gt;f_dentry;
-	struct vfsmount *mnt = file-&gt;f_vfsmnt;
+	struct dentry *dentry = file-&gt;f_path.dentry;
+	struct vfsmount *mnt = file-&gt;f_path.mnt;
 	struct inode *inode = dentry-&gt;d_inode;
 
 	might_sleep();
@@ -176,8 +176,8 @@ void fastcall __fput(struct file *file)
 		put_write_access(inode);
 	put_pid(file-&gt;f_owner.pid);
 	file_kill(file);
-	file-&gt;f_dentry = NULL;
-	file-&gt;f_vfsmnt = NULL;
+	file-&gt;f_path.dentry = NULL;
+	file-&gt;f_path.mnt = NULL;
 	file_free(file);
 	dput(dentry);
 	mntput(mnt);
@@ -271,7 +271,7 @@ int fs_may_remount_ro(struct super_block *sb)
 	file_list_lock();
 	list_for_each(p, &amp;sb-&gt;s_files) {
 		struct file *file = list_entry(p, struct file, f_u.fu_list);
-		struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+		struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 
 		/* File with pending delete? */
 		if (inode-&gt;i_nlink == 0)
diff --git a/fs/inode.c b/fs/inode.c
index 9ecccab7326d..d00de182ecb9 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -1200,7 +1200,7 @@ EXPORT_SYMBOL(touch_atime);
 
 void file_update_time(struct file *file)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	struct timespec now;
 	int sync_it = 0;
 
diff --git a/fs/inotify_user.c b/fs/inotify_user.c
index e1956e6f116c..55f6da55b7c0 100644
--- a/fs/inotify_user.c
+++ b/fs/inotify_user.c
@@ -570,9 +570,9 @@ asmlinkage long sys_inotify_init(void)
 	dev-&gt;ih = ih;
 
 	filp-&gt;f_op = &amp;inotify_fops;
-	filp-&gt;f_vfsmnt = mntget(inotify_mnt);
-	filp-&gt;f_dentry = dget(inotify_mnt-&gt;mnt_root);
-	filp-&gt;f_mapping = filp-&gt;f_dentry-&gt;d_inode-&gt;i_mapping;
+	filp-&gt;f_path.mnt = mntget(inotify_mnt);
+	filp-&gt;f_path.dentry = dget(inotify_mnt-&gt;mnt_root);
+	filp-&gt;f_mapping = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mapping;
 	filp-&gt;f_mode = FMODE_READ;
 	filp-&gt;f_flags = O_RDONLY;
 	filp-&gt;private_data = dev;
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 4b7660b09ac0..ff61772ceedd 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -31,7 +31,7 @@ static long do_ioctl(struct file *filp, unsigned int cmd,
 		goto out;
 	} else if (filp-&gt;f_op-&gt;ioctl) {
 		lock_kernel();
-		error = filp-&gt;f_op-&gt;ioctl(filp-&gt;f_dentry-&gt;d_inode,
+		error = filp-&gt;f_op-&gt;ioctl(filp-&gt;f_path.dentry-&gt;d_inode,
 					  filp, cmd, arg);
 		unlock_kernel();
 	}
@@ -45,7 +45,7 @@ static int file_ioctl(struct file *filp, unsigned int cmd,
 {
 	int error;
 	int block;
-	struct inode * inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int __user *p = (int __user *)arg;
 
 	switch (cmd) {
@@ -137,17 +137,17 @@ int vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd, unsigned lon
 			break;
 
 		case FIOQSIZE:
-			if (S_ISDIR(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode) ||
-			    S_ISREG(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode) ||
-			    S_ISLNK(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode)) {
-				loff_t res = inode_get_bytes(filp-&gt;f_dentry-&gt;d_inode);
+			if (S_ISDIR(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode) ||
+			    S_ISREG(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode) ||
+			    S_ISLNK(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode)) {
+				loff_t res = inode_get_bytes(filp-&gt;f_path.dentry-&gt;d_inode);
 				error = copy_to_user((loff_t __user *)arg, &amp;res, sizeof(res)) ? -EFAULT : 0;
 			}
 			else
 				error = -ENOTTY;
 			break;
 		default:
-			if (S_ISREG(filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode))
+			if (S_ISREG(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode))
 				error = file_ioctl(filp, cmd, arg);
 			else
 				error = do_ioctl(filp, cmd, arg);
diff --git a/fs/libfs.c b/fs/libfs.c
index bd08e0e64a8c..503898d5c4a7 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -63,7 +63,7 @@ int dcache_dir_open(struct inode *inode, struct file *file)
 {
 	static struct qstr cursor_name = {.len = 1, .name = "."};
 
-	file-&gt;private_data = d_alloc(file-&gt;f_dentry, &amp;cursor_name);
+	file-&gt;private_data = d_alloc(file-&gt;f_path.dentry, &amp;cursor_name);
 
 	return file-&gt;private_data ? 0 : -ENOMEM;
 }
@@ -76,7 +76,7 @@ int dcache_dir_close(struct inode *inode, struct file *file)
 
 loff_t dcache_dir_lseek(struct file *file, loff_t offset, int origin)
 {
-	mutex_lock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+	mutex_lock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 	switch (origin) {
 		case 1:
 			offset += file-&gt;f_pos;
@@ -84,7 +84,7 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int origin)
 			if (offset &gt;= 0)
 				break;
 		default:
-			mutex_unlock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+			mutex_unlock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 			return -EINVAL;
 	}
 	if (offset != file-&gt;f_pos) {
@@ -96,8 +96,8 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int origin)
 
 			spin_lock(&amp;dcache_lock);
 			list_del(&amp;cursor-&gt;d_u.d_child);
-			p = file-&gt;f_dentry-&gt;d_subdirs.next;
-			while (n &amp;&amp; p != &amp;file-&gt;f_dentry-&gt;d_subdirs) {
+			p = file-&gt;f_path.dentry-&gt;d_subdirs.next;
+			while (n &amp;&amp; p != &amp;file-&gt;f_path.dentry-&gt;d_subdirs) {
 				struct dentry *next;
 				next = list_entry(p, struct dentry, d_u.d_child);
 				if (!d_unhashed(next) &amp;&amp; next-&gt;d_inode)
@@ -108,7 +108,7 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int origin)
 			spin_unlock(&amp;dcache_lock);
 		}
 	}
-	mutex_unlock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
+	mutex_unlock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
 	return offset;
 }
 
@@ -126,7 +126,7 @@ static inline unsigned char dt_type(struct inode *inode)
 
 int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct dentry *cursor = filp-&gt;private_data;
 	struct list_head *p, *q = &amp;cursor-&gt;d_u.d_child;
 	ino_t ino;
diff --git a/fs/locks.c b/fs/locks.c
index 1cb0c57fedbd..52a81005dab4 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -321,7 +321,7 @@ static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,
 		start = filp-&gt;f_pos;
 		break;
 	case SEEK_END:
-		start = i_size_read(filp-&gt;f_dentry-&gt;d_inode);
+		start = i_size_read(filp-&gt;f_path.dentry-&gt;d_inode);
 		break;
 	default:
 		return -EINVAL;
@@ -371,7 +371,7 @@ static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,
 		start = filp-&gt;f_pos;
 		break;
 	case SEEK_END:
-		start = i_size_read(filp-&gt;f_dentry-&gt;d_inode);
+		start = i_size_read(filp-&gt;f_path.dentry-&gt;d_inode);
 		break;
 	default:
 		return -EINVAL;
@@ -672,7 +672,7 @@ posix_test_lock(struct file *filp, struct file_lock *fl,
 	struct file_lock *cfl;
 
 	lock_kernel();
-	for (cfl = filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock; cfl; cfl = cfl-&gt;fl_next) {
+	for (cfl = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_flock; cfl; cfl = cfl-&gt;fl_next) {
 		if (!IS_POSIX(cfl))
 			continue;
 		if (posix_locks_conflict(cfl, fl))
@@ -734,7 +734,7 @@ static int flock_lock_file(struct file *filp, struct file_lock *request)
 {
 	struct file_lock *new_fl = NULL;
 	struct file_lock **before;
-	struct inode * inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode * inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int error = 0;
 	int found = 0;
 
@@ -1018,7 +1018,7 @@ static int __posix_lock_file_conf(struct inode *inode, struct file_lock *request
  */
 int posix_lock_file(struct file *filp, struct file_lock *fl)
 {
-	return __posix_lock_file_conf(filp-&gt;f_dentry-&gt;d_inode, fl, NULL);
+	return __posix_lock_file_conf(filp-&gt;f_path.dentry-&gt;d_inode, fl, NULL);
 }
 EXPORT_SYMBOL(posix_lock_file);
 
@@ -1033,7 +1033,7 @@ EXPORT_SYMBOL(posix_lock_file);
 int posix_lock_file_conf(struct file *filp, struct file_lock *fl,
 			struct file_lock *conflock)
 {
-	return __posix_lock_file_conf(filp-&gt;f_dentry-&gt;d_inode, fl, conflock);
+	return __posix_lock_file_conf(filp-&gt;f_path.dentry-&gt;d_inode, fl, conflock);
 }
 EXPORT_SYMBOL(posix_lock_file_conf);
 
@@ -1333,8 +1333,8 @@ int fcntl_getlease(struct file *filp)
 	int type = F_UNLCK;
 
 	lock_kernel();
-	time_out_leases(filp-&gt;f_dentry-&gt;d_inode);
-	for (fl = filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock; fl &amp;&amp; IS_LEASE(fl);
+	time_out_leases(filp-&gt;f_path.dentry-&gt;d_inode);
+	for (fl = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_flock; fl &amp;&amp; IS_LEASE(fl);
 			fl = fl-&gt;fl_next) {
 		if (fl-&gt;fl_file == filp) {
 			type = fl-&gt;fl_type &amp; ~F_INPROGRESS;
@@ -1359,7 +1359,7 @@ int fcntl_getlease(struct file *filp)
 static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 {
 	struct file_lock *fl, **before, **my_before = NULL, *lease;
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	int error, rdlease_count = 0, wrlease_count = 0;
 
@@ -1448,7 +1448,7 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 
 int setlease(struct file *filp, long arg, struct file_lock **lease)
 {
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
@@ -1482,7 +1482,7 @@ EXPORT_SYMBOL(setlease);
 int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 {
 	struct file_lock fl, *flp = &amp;fl;
-	struct dentry *dentry = filp-&gt;f_dentry;
+	struct dentry *dentry = filp-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
@@ -1692,7 +1692,7 @@ int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,
 	if (copy_from_user(&amp;flock, l, sizeof(flock)))
 		goto out;
 
-	inode = filp-&gt;f_dentry-&gt;d_inode;
+	inode = filp-&gt;f_path.dentry-&gt;d_inode;
 
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
@@ -1835,7 +1835,7 @@ int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,
 	if (copy_from_user(&amp;flock, l, sizeof(flock)))
 		goto out;
 
-	inode = filp-&gt;f_dentry-&gt;d_inode;
+	inode = filp-&gt;f_path.dentry-&gt;d_inode;
 
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
@@ -1922,7 +1922,7 @@ void locks_remove_posix(struct file *filp, fl_owner_t owner)
 	 * posix_lock_file().  Another process could be setting a lock on this
 	 * file at the same time, but we wouldn't remove that lock anyway.
 	 */
-	if (!filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock)
+	if (!filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_flock)
 		return;
 
 	lock.fl_type = F_UNLCK;
@@ -1951,7 +1951,7 @@ EXPORT_SYMBOL(locks_remove_posix);
  */
 void locks_remove_flock(struct file *filp)
 {
-	struct inode * inode = filp-&gt;f_dentry-&gt;d_inode; 
+	struct inode * inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct file_lock *fl;
 	struct file_lock **before;
 
@@ -2020,7 +2020,7 @@ static void lock_get_status(char* out, struct file_lock *fl, int id, char *pfx)
 	struct inode *inode = NULL;
 
 	if (fl-&gt;fl_file != NULL)
-		inode = fl-&gt;fl_file-&gt;f_dentry-&gt;d_inode;
+		inode = fl-&gt;fl_file-&gt;f_path.dentry-&gt;d_inode;
 
 	out += sprintf(out, "%d:%s ", id, pfx);
 	if (IS_POSIX(fl)) {
diff --git a/fs/namei.c b/fs/namei.c
index 8c2db88bb20d..e4f108f08230 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -297,7 +297,7 @@ int vfs_permission(struct nameidata *nd, int mask)
  */
 int file_permission(struct file *file, int mask)
 {
-	return permission(file-&gt;f_dentry-&gt;d_inode, mask, NULL);
+	return permission(file-&gt;f_path.dentry-&gt;d_inode, mask, NULL);
 }
 
 /*
@@ -333,7 +333,7 @@ int get_write_access(struct inode * inode)
 
 int deny_write_access(struct file * file)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 
 	spin_lock(&amp;inode-&gt;i_lock);
 	if (atomic_read(&amp;inode-&gt;i_writecount) &gt; 0) {
@@ -368,7 +368,7 @@ void path_release_on_umount(struct nameidata *nd)
  */
 void release_open_intent(struct nameidata *nd)
 {
-	if (nd-&gt;intent.open.file-&gt;f_dentry == NULL)
+	if (nd-&gt;intent.open.file-&gt;f_path.dentry == NULL)
 		put_filp(nd-&gt;intent.open.file);
 	else
 		fput(nd-&gt;intent.open.file);
@@ -1138,7 +1138,7 @@ static int fastcall do_path_lookup(int dfd, const char *name,
 		if (!file)
 			goto out_fail;
 
-		dentry = file-&gt;f_dentry;
+		dentry = file-&gt;f_path.dentry;
 
 		retval = -ENOTDIR;
 		if (!S_ISDIR(dentry-&gt;d_inode-&gt;i_mode))
@@ -1148,7 +1148,7 @@ static int fastcall do_path_lookup(int dfd, const char *name,
 		if (retval)
 			goto fput_fail;
 
-		nd-&gt;mnt = mntget(file-&gt;f_vfsmnt);
+		nd-&gt;mnt = mntget(file-&gt;f_path.mnt);
 		nd-&gt;dentry = dget(dentry);
 
 		fput_light(file, fput_needed);
diff --git a/fs/open.c b/fs/open.c
index 3b56192816ca..0d94319e8681 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -165,7 +165,7 @@ asmlinkage long sys_fstatfs(unsigned int fd, struct statfs __user * buf)
 	file = fget(fd);
 	if (!file)
 		goto out;
-	error = vfs_statfs_native(file-&gt;f_dentry, &amp;tmp);
+	error = vfs_statfs_native(file-&gt;f_path.dentry, &amp;tmp);
 	if (!error &amp;&amp; copy_to_user(buf, &amp;tmp, sizeof(tmp)))
 		error = -EFAULT;
 	fput(file);
@@ -186,7 +186,7 @@ asmlinkage long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user
 	file = fget(fd);
 	if (!file)
 		goto out;
-	error = vfs_statfs64(file-&gt;f_dentry, &amp;tmp);
+	error = vfs_statfs64(file-&gt;f_path.dentry, &amp;tmp);
 	if (!error &amp;&amp; copy_to_user(buf, &amp;tmp, sizeof(tmp)))
 		error = -EFAULT;
 	fput(file);
@@ -302,7 +302,7 @@ static long do_sys_ftruncate(unsigned int fd, loff_t length, int small)
 	if (file-&gt;f_flags &amp; O_LARGEFILE)
 		small = 0;
 
-	dentry = file-&gt;f_dentry;
+	dentry = file-&gt;f_path.dentry;
 	inode = dentry-&gt;d_inode;
 	error = -EINVAL;
 	if (!S_ISREG(inode-&gt;i_mode) || !(file-&gt;f_mode &amp; FMODE_WRITE))
@@ -448,8 +448,8 @@ asmlinkage long sys_fchdir(unsigned int fd)
 	if (!file)
 		goto out;
 
-	dentry = file-&gt;f_dentry;
-	mnt = file-&gt;f_vfsmnt;
+	dentry = file-&gt;f_path.dentry;
+	mnt = file-&gt;f_path.mnt;
 	inode = dentry-&gt;d_inode;
 
 	error = -ENOTDIR;
@@ -503,7 +503,7 @@ asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
 	if (!file)
 		goto out;
 
-	dentry = file-&gt;f_dentry;
+	dentry = file-&gt;f_path.dentry;
 	inode = dentry-&gt;d_inode;
 
 	audit_inode(NULL, inode);
@@ -662,7 +662,7 @@ asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group)
 	if (!file)
 		goto out;
 
-	dentry = file-&gt;f_dentry;
+	dentry = file-&gt;f_path.dentry;
 	audit_inode(NULL, dentry-&gt;d_inode);
 	error = chown_common(dentry, user, group);
 	fput(file);
@@ -688,8 +688,8 @@ static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt,
 	}
 
 	f-&gt;f_mapping = inode-&gt;i_mapping;
-	f-&gt;f_dentry = dentry;
-	f-&gt;f_vfsmnt = mnt;
+	f-&gt;f_path.dentry = dentry;
+	f-&gt;f_path.mnt = mnt;
 	f-&gt;f_pos = 0;
 	f-&gt;f_op = fops_get(inode-&gt;i_fop);
 	file_move(f, &amp;inode-&gt;i_sb-&gt;s_files);
@@ -723,8 +723,8 @@ static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt,
 	if (f-&gt;f_mode &amp; FMODE_WRITE)
 		put_write_access(inode);
 	file_kill(f);
-	f-&gt;f_dentry = NULL;
-	f-&gt;f_vfsmnt = NULL;
+	f-&gt;f_path.dentry = NULL;
+	f-&gt;f_path.mnt = NULL;
 cleanup_file:
 	put_filp(f);
 	dput(dentry);
@@ -822,7 +822,7 @@ struct file *nameidata_to_filp(struct nameidata *nd, int flags)
 	/* Pick up the filp from the open intent */
 	filp = nd-&gt;intent.open.file;
 	/* Has the filesystem initialised the file for us? */
-	if (filp-&gt;f_dentry == NULL)
+	if (filp-&gt;f_path.dentry == NULL)
 		filp = __dentry_open(nd-&gt;dentry, nd-&gt;mnt, flags, filp, NULL);
 	else
 		path_release(nd);
@@ -965,7 +965,7 @@ long do_sys_open(int dfd, const char __user *filename, int flags, int mode)
 				put_unused_fd(fd);
 				fd = PTR_ERR(f);
 			} else {
-				fsnotify_open(f-&gt;f_dentry);
+				fsnotify_open(f-&gt;f_path.dentry);
 				fd_install(fd, f);
 			}
 		}
diff --git a/fs/pipe.c b/fs/pipe.c
index ae36b89b1a37..f8b6bdcb879a 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -222,7 +222,7 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 	   unsigned long nr_segs, loff_t pos)
 {
 	struct file *filp = iocb-&gt;ki_filp;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct pipe_inode_info *pipe;
 	int do_wakeup;
 	ssize_t ret;
@@ -335,7 +335,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 	    unsigned long nr_segs, loff_t ppos)
 {
 	struct file *filp = iocb-&gt;ki_filp;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct pipe_inode_info *pipe;
 	ssize_t ret;
 	int do_wakeup;
@@ -520,7 +520,7 @@ static int
 pipe_ioctl(struct inode *pino, struct file *filp,
 	   unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct pipe_inode_info *pipe;
 	int count, buf, nrbufs;
 
@@ -548,7 +548,7 @@ static unsigned int
 pipe_poll(struct file *filp, poll_table *wait)
 {
 	unsigned int mask;
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct pipe_inode_info *pipe = inode-&gt;i_pipe;
 	int nrbufs;
 
@@ -601,7 +601,7 @@ pipe_release(struct inode *inode, int decr, int decw)
 static int
 pipe_read_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int retval;
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
@@ -618,7 +618,7 @@ pipe_read_fasync(int fd, struct file *filp, int on)
 static int
 pipe_write_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int retval;
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
@@ -635,7 +635,7 @@ pipe_write_fasync(int fd, struct file *filp, int on)
 static int
 pipe_rdwr_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct pipe_inode_info *pipe = inode-&gt;i_pipe;
 	int retval;
 
@@ -914,8 +914,8 @@ struct file *create_write_pipe(void)
 	 */
 	dentry-&gt;d_flags &amp;= ~DCACHE_UNHASHED;
 	d_instantiate(dentry, inode);
-	f-&gt;f_vfsmnt = mntget(pipe_mnt);
-	f-&gt;f_dentry = dentry;
+	f-&gt;f_path.mnt = mntget(pipe_mnt);
+	f-&gt;f_path.dentry = dentry;
 	f-&gt;f_mapping = inode-&gt;i_mapping;
 
 	f-&gt;f_flags = O_WRONLY;
@@ -935,8 +935,8 @@ struct file *create_write_pipe(void)
 
 void free_write_pipe(struct file *f)
 {
-	mntput(f-&gt;f_vfsmnt);
-	dput(f-&gt;f_dentry);
+	mntput(f-&gt;f_path.mnt);
+	dput(f-&gt;f_path.dentry);
 	put_filp(f);
 }
 
@@ -947,9 +947,9 @@ struct file *create_read_pipe(struct file *wrf)
 		return ERR_PTR(-ENFILE);
 
 	/* Grab pipe from the writer */
-	f-&gt;f_vfsmnt = mntget(wrf-&gt;f_vfsmnt);
-	f-&gt;f_dentry = dget(wrf-&gt;f_dentry);
-	f-&gt;f_mapping = wrf-&gt;f_dentry-&gt;d_inode-&gt;i_mapping;
+	f-&gt;f_path.mnt = mntget(wrf-&gt;f_path.mnt);
+	f-&gt;f_path.dentry = dget(wrf-&gt;f_path.dentry);
+	f-&gt;f_mapping = wrf-&gt;f_path.dentry-&gt;d_inode-&gt;i_mapping;
 
 	f-&gt;f_pos = 0;
 	f-&gt;f_flags = O_RDONLY;
diff --git a/fs/read_write.c b/fs/read_write.c
index f792000a28e6..1d3dda4fa70c 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -64,13 +64,13 @@ loff_t remote_llseek(struct file *file, loff_t offset, int origin)
 	lock_kernel();
 	switch (origin) {
 		case 2:
-			offset += i_size_read(file-&gt;f_dentry-&gt;d_inode);
+			offset += i_size_read(file-&gt;f_path.dentry-&gt;d_inode);
 			break;
 		case 1:
 			offset += file-&gt;f_pos;
 	}
 	retval = -EINVAL;
-	if (offset&gt;=0 &amp;&amp; offset&lt;=file-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;s_maxbytes) {
+	if (offset&gt;=0 &amp;&amp; offset&lt;=file-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb-&gt;s_maxbytes) {
 		if (offset != file-&gt;f_pos) {
 			file-&gt;f_pos = offset;
 			file-&gt;f_version = 0;
@@ -95,7 +95,7 @@ loff_t default_llseek(struct file *file, loff_t offset, int origin)
 	lock_kernel();
 	switch (origin) {
 		case 2:
-			offset += i_size_read(file-&gt;f_dentry-&gt;d_inode);
+			offset += i_size_read(file-&gt;f_path.dentry-&gt;d_inode);
 			break;
 		case 1:
 			offset += file-&gt;f_pos;
@@ -203,7 +203,7 @@ int rw_verify_area(int read_write, struct file *file, loff_t *ppos, size_t count
 	if (unlikely((pos &lt; 0) || (loff_t) (pos + count) &lt; 0))
 		goto Einval;
 
-	inode = file-&gt;f_dentry-&gt;d_inode;
+	inode = file-&gt;f_path.dentry-&gt;d_inode;
 	if (unlikely(inode-&gt;i_flock &amp;&amp; MANDATORY_LOCK(inode))) {
 		int retval = locks_mandatory_area(
 			read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,
@@ -273,7 +273,7 @@ ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 			else
 				ret = do_sync_read(file, buf, count, pos);
 			if (ret &gt; 0) {
-				fsnotify_access(file-&gt;f_dentry);
+				fsnotify_access(file-&gt;f_path.dentry);
 				current-&gt;rchar += ret;
 			}
 			current-&gt;syscr++;
@@ -331,7 +331,7 @@ ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_
 			else
 				ret = do_sync_write(file, buf, count, pos);
 			if (ret &gt; 0) {
-				fsnotify_modify(file-&gt;f_dentry);
+				fsnotify_modify(file-&gt;f_path.dentry);
 				current-&gt;wchar += ret;
 			}
 			current-&gt;syscw++;
@@ -628,9 +628,9 @@ static ssize_t do_readv_writev(int type, struct file *file,
 		kfree(iov);
 	if ((ret + (type == READ)) &gt; 0) {
 		if (type == READ)
-			fsnotify_access(file-&gt;f_dentry);
+			fsnotify_access(file-&gt;f_path.dentry);
 		else
-			fsnotify_modify(file-&gt;f_dentry);
+			fsnotify_modify(file-&gt;f_path.dentry);
 	}
 	return ret;
 }
@@ -722,7 +722,7 @@ static ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,
 	if (!(in_file-&gt;f_mode &amp; FMODE_READ))
 		goto fput_in;
 	retval = -EINVAL;
-	in_inode = in_file-&gt;f_dentry-&gt;d_inode;
+	in_inode = in_file-&gt;f_path.dentry-&gt;d_inode;
 	if (!in_inode)
 		goto fput_in;
 	if (!in_file-&gt;f_op || !in_file-&gt;f_op-&gt;sendfile)
@@ -754,7 +754,7 @@ static ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,
 	retval = -EINVAL;
 	if (!out_file-&gt;f_op || !out_file-&gt;f_op-&gt;sendpage)
 		goto fput_out;
-	out_inode = out_file-&gt;f_dentry-&gt;d_inode;
+	out_inode = out_file-&gt;f_path.dentry-&gt;d_inode;
 	retval = rw_verify_area(WRITE, out_file, &amp;out_file-&gt;f_pos, count);
 	if (retval &lt; 0)
 		goto fput_out;
diff --git a/fs/readdir.c b/fs/readdir.c
index bff3ee58e2f8..f39f5b313252 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -21,7 +21,7 @@
 
 int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 {
-	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 	int res = -ENOTDIR;
 	if (!file-&gt;f_op || !file-&gt;f_op-&gt;readdir)
 		goto out;
diff --git a/fs/seq_file.c b/fs/seq_file.c
index 10690aa401c7..0ac22af7afe5 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -269,7 +269,7 @@ EXPORT_SYMBOL(seq_lseek);
 /**
  *	seq_release -	free the structures associated with sequential file.
  *	@file: file in question
- *	@inode: file-&gt;f_dentry-&gt;d_inode
+ *	@inode: file-&gt;f_path.dentry-&gt;d_inode
  *
  *	Frees the structures associated with sequential file; can be used
  *	as -&gt;f_op-&gt;release() if you don't have private data to destroy.
diff --git a/fs/splice.c b/fs/splice.c
index da74583a00ee..bbd0aeb3f68e 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -844,7 +844,7 @@ generic_file_splice_write_nolock(struct pipe_inode_info *pipe, struct file *out,
 	ssize_t ret;
 	int err;
 
-	err = remove_suid(out-&gt;f_dentry);
+	err = remove_suid(out-&gt;f_path.dentry);
 	if (unlikely(err))
 		return err;
 
@@ -890,10 +890,10 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
 	ssize_t ret;
 	int err;
 
-	err = should_remove_suid(out-&gt;f_dentry);
+	err = should_remove_suid(out-&gt;f_path.dentry);
 	if (unlikely(err)) {
 		mutex_lock(&amp;inode-&gt;i_mutex);
-		err = __remove_suid(out-&gt;f_dentry, err);
+		err = __remove_suid(out-&gt;f_path.dentry, err);
 		mutex_unlock(&amp;inode-&gt;i_mutex);
 		if (err)
 			return err;
@@ -1008,7 +1008,7 @@ long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
 	 * randomly drop data for eg socket -&gt; socket splicing. Use the
 	 * piped splicing for that!
 	 */
-	i_mode = in-&gt;f_dentry-&gt;d_inode-&gt;i_mode;
+	i_mode = in-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode;
 	if (unlikely(!S_ISREG(i_mode) &amp;&amp; !S_ISBLK(i_mode)))
 		return -EINVAL;
 
@@ -1132,7 +1132,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 	loff_t offset, *off;
 	long ret;
 
-	pipe = pipe_info(in-&gt;f_dentry-&gt;d_inode);
+	pipe = pipe_info(in-&gt;f_path.dentry-&gt;d_inode);
 	if (pipe) {
 		if (off_in)
 			return -ESPIPE;
@@ -1153,7 +1153,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 		return ret;
 	}
 
-	pipe = pipe_info(out-&gt;f_dentry-&gt;d_inode);
+	pipe = pipe_info(out-&gt;f_path.dentry-&gt;d_inode);
 	if (pipe) {
 		if (off_out)
 			return -ESPIPE;
@@ -1321,7 +1321,7 @@ static long do_vmsplice(struct file *file, const struct iovec __user *iov,
 		.ops = &amp;user_page_pipe_buf_ops,
 	};
 
-	pipe = pipe_info(file-&gt;f_dentry-&gt;d_inode);
+	pipe = pipe_info(file-&gt;f_path.dentry-&gt;d_inode);
 	if (!pipe)
 		return -EBADF;
 	if (unlikely(nr_segs &gt; UIO_MAXIOV))
@@ -1549,8 +1549,8 @@ static int link_pipe(struct pipe_inode_info *ipipe,
 static long do_tee(struct file *in, struct file *out, size_t len,
 		   unsigned int flags)
 {
-	struct pipe_inode_info *ipipe = pipe_info(in-&gt;f_dentry-&gt;d_inode);
-	struct pipe_inode_info *opipe = pipe_info(out-&gt;f_dentry-&gt;d_inode);
+	struct pipe_inode_info *ipipe = pipe_info(in-&gt;f_path.dentry-&gt;d_inode);
+	struct pipe_inode_info *opipe = pipe_info(out-&gt;f_path.dentry-&gt;d_inode);
 	int ret = -EINVAL;
 
 	/*
diff --git a/fs/stat.c b/fs/stat.c
index a0ebfc7f8a64..38a8cb2a28de 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -102,7 +102,7 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 	int error = -EBADF;
 
 	if (f) {
-		error = vfs_getattr(f-&gt;f_vfsmnt, f-&gt;f_dentry, stat);
+		error = vfs_getattr(f-&gt;f_path.mnt, f-&gt;f_path.dentry, stat);
 		fput(f);
 	}
 	return error;
diff --git a/fs/super.c b/fs/super.c
index 84c320f6ad7e..f961e0307997 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -570,7 +570,7 @@ static void mark_files_ro(struct super_block *sb)
 
 	file_list_lock();
 	list_for_each_entry(f, &amp;sb-&gt;s_files, f_u.fu_list) {
-		if (S_ISREG(f-&gt;f_dentry-&gt;d_inode-&gt;i_mode) &amp;&amp; file_count(f))
+		if (S_ISREG(f-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode) &amp;&amp; file_count(f))
 			f-&gt;f_mode &amp;= ~FMODE_WRITE;
 	}
 	file_list_unlock();
diff --git a/fs/sync.c b/fs/sync.c
index 865f32be386e..d0feff61e6aa 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -94,7 +94,7 @@ long do_fsync(struct file *file, int datasync)
 	 * livelocks in fsync_buffers_list().
 	 */
 	mutex_lock(&amp;mapping-&gt;host-&gt;i_mutex);
-	err = file-&gt;f_op-&gt;fsync(file, file-&gt;f_dentry, datasync);
+	err = file-&gt;f_op-&gt;fsync(file, file-&gt;f_path.dentry, datasync);
 	if (!ret)
 		ret = err;
 	mutex_unlock(&amp;mapping-&gt;host-&gt;i_mutex);
@@ -223,7 +223,7 @@ asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes,
 	if (!file)
 		goto out;
 
-	i_mode = file-&gt;f_dentry-&gt;d_inode-&gt;i_mode;
+	i_mode = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode;
 	ret = -ESPIPE;
 	if (!S_ISREG(i_mode) &amp;&amp; !S_ISBLK(i_mode) &amp;&amp; !S_ISDIR(i_mode) &amp;&amp;
 			!S_ISLNK(i_mode))
diff --git a/fs/xattr.c b/fs/xattr.c
index 0901bdc2ce24..38646132ab0e 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -268,7 +268,7 @@ sys_fsetxattr(int fd, char __user *name, void __user *value,
 	f = fget(fd);
 	if (!f)
 		return error;
-	dentry = f-&gt;f_dentry;
+	dentry = f-&gt;f_path.dentry;
 	audit_inode(NULL, dentry-&gt;d_inode);
 	error = setxattr(dentry, name, value, size, flags);
 	fput(f);
@@ -351,7 +351,7 @@ sys_fgetxattr(int fd, char __user *name, void __user *value, size_t size)
 	f = fget(fd);
 	if (!f)
 		return error;
-	error = getxattr(f-&gt;f_dentry, name, value, size);
+	error = getxattr(f-&gt;f_path.dentry, name, value, size);
 	fput(f);
 	return error;
 }
@@ -423,7 +423,7 @@ sys_flistxattr(int fd, char __user *list, size_t size)
 	f = fget(fd);
 	if (!f)
 		return error;
-	error = listxattr(f-&gt;f_dentry, list, size);
+	error = listxattr(f-&gt;f_path.dentry, list, size);
 	fput(f);
 	return error;
 }
@@ -484,7 +484,7 @@ sys_fremovexattr(int fd, char __user *name)
 	f = fget(fd);
 	if (!f)
 		return error;
-	dentry = f-&gt;f_dentry;
+	dentry = f-&gt;f_path.dentry;
 	audit_inode(NULL, dentry-&gt;d_inode);
 	error = removexattr(dentry, name);
 	fput(f);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45f2cabb8c75..adce6e1d70c2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -269,6 +269,7 @@ extern int dir_notify_enable;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/kdev_t.h&gt;
 #include &lt;linux/dcache.h&gt;
+#include &lt;linux/namei.h&gt;
 #include &lt;linux/stat.h&gt;
 #include &lt;linux/cache.h&gt;
 #include &lt;linux/kobject.h&gt;
@@ -711,8 +712,9 @@ struct file {
 		struct list_head	fu_list;
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
-	struct dentry		*f_dentry;
-	struct vfsmount         *f_vfsmnt;
+	struct path		f_path;
+#define f_dentry	f_path.dentry
+#define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
 	atomic_t		f_count;
 	unsigned int 		f_flags;
@@ -1224,7 +1226,7 @@ extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {
 	if (!(file-&gt;f_flags &amp; O_NOATIME))
-		touch_atime(file-&gt;f_vfsmnt, file-&gt;f_dentry);
+		touch_atime(file-&gt;f_path.mnt, file-&gt;f_path.dentry);
 }
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
@@ -1615,7 +1617,7 @@ static inline void put_write_access(struct inode * inode)
 static inline void allow_write_access(struct file *file)
 {
 	if (file)
-		atomic_inc(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount);
+		atomic_inc(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_writecount);
 }
 extern int do_pipe(int *);
 extern struct file *create_read_pipe(struct file *f);
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index d4f219ffaa5d..dfc4e4f68da4 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -164,7 +164,7 @@ static inline void fsnotify_open(struct dentry *dentry)
  */
 static inline void fsnotify_close(struct file *file)
 {
-	struct dentry *dentry = file-&gt;f_dentry;
+	struct dentry *dentry = file-&gt;f_path.dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	const char *name = dentry-&gt;d_name.name;
 	mode_t mode = file-&gt;f_mode;</pre>
    <div class="pagination">
        <a href='9_12.html'>&lt;&lt;Prev</a><a href='9.html'>1</a><a href='9_2.html'>2</a><a href='9_3.html'>3</a><a href='9_4.html'>4</a><a href='9_5.html'>5</a><a href='9_6.html'>6</a><a href='9_7.html'>7</a><a href='9_8.html'>8</a><a href='9_9.html'>9</a><a href='9_10.html'>10</a><a href='9_11.html'>11</a><a href='9_12.html'>12</a><span>[13]</span><a href='9_14.html'>14</a><a href='9_14.html'>Next&gt;&gt;</a>
    <div>
</body>
