<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_134.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><span>[135]</span><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_136.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 22efcf4adec4262e0f49e6225f6cd070e4a85d20
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 16:12:02 2005 -0400

    [PATCH] USB: File-Storage gadget: use the kthread API
    
    This patch (as566) converts the File-Storage gadget over to the kthread
    API.  The new code doesn't use kthread_stop because the control thread
    needs to terminate asynchronously when it receives a signal.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    
     drivers/usb/gadget/file_storage.c |   32 +++++++++++++-------------------
     1 file changed, 13 insertions(+), 19 deletions(-)

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index a41d9d4baee3..241c570e541c 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -224,6 +224,7 @@
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
+#include &lt;linux/kthread.h&gt;
 #include &lt;linux/limits.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/module.h&gt;
@@ -669,7 +670,6 @@ struct fsg_dev {
 	wait_queue_head_t	thread_wqh;
 	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
-	int			thread_pid;
 	struct task_struct	*thread_task;
 	sigset_t		thread_signal_mask;
 
@@ -1084,7 +1084,6 @@ static void wakeup_thread(struct fsg_dev *fsg)
 static void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)
 {
 	unsigned long		flags;
-	struct task_struct	*thread_task;
 
 	/* Do nothing if a higher-priority exception is already in progress.
 	 * If a lower-or-equal priority exception is in progress, preempt it
@@ -1093,9 +1092,9 @@ static void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)
 	if (fsg-&gt;state &lt;= new_state) {
 		fsg-&gt;exception_req_tag = fsg-&gt;ep0_req_tag;
 		fsg-&gt;state = new_state;
-		thread_task = fsg-&gt;thread_task;
-		if (thread_task)
-			send_sig_info(SIGUSR1, SEND_SIG_FORCED, thread_task);
+		if (fsg-&gt;thread_task)
+			send_sig_info(SIGUSR1, SEND_SIG_FORCED,
+					fsg-&gt;thread_task);
 	}
 	spin_unlock_irqrestore(&amp;fsg-&gt;lock, flags);
 }
@@ -3383,11 +3382,6 @@ static int fsg_main_thread(void *fsg_)
 {
 	struct fsg_dev		*fsg = (struct fsg_dev *) fsg_;
 
-	fsg-&gt;thread_task = current;
-
-	/* Release all our userspace resources */
-	daemonize("file-storage-gadget");
-
 	/* Allow the thread to be killed by a signal, but set the signal mask
 	 * to block everything but INT, TERM, KILL, and USR1. */
 	siginitsetinv(&amp;fsg-&gt;thread_signal_mask, sigmask(SIGINT) |
@@ -3400,9 +3394,6 @@ static int fsg_main_thread(void *fsg_)
 	 * that expects a __user pointer and it will work okay. */
 	set_fs(get_ds());
 
-	/* Wait for the gadget registration to finish up */
-	wait_for_completion(&amp;fsg-&gt;thread_notifier);
-
 	/* The main loop */
 	while (fsg-&gt;state != FSG_STATE_TERMINATED) {
 		if (exception_in_progress(fsg) || signal_pending(current)) {
@@ -3440,8 +3431,9 @@ static int fsg_main_thread(void *fsg_)
 		spin_unlock_irq(&amp;fsg-&gt;lock);
 		}
 
+	spin_lock_irq(&amp;fsg-&gt;lock);
 	fsg-&gt;thread_task = NULL;
-	flush_signals(current);
+	spin_unlock_irq(&amp;fsg-&gt;lock);
 
 	/* In case we are exiting because of a signal, unregister the
 	 * gadget driver and close the backing file. */
@@ -3959,10 +3951,12 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 		sprintf(&amp;serial[i], "%02X", c);
 	}
 
-	if ((rc = kernel_thread(fsg_main_thread, fsg, (CLONE_VM | CLONE_FS |
-			CLONE_FILES))) &lt; 0)
+	fsg-&gt;thread_task = kthread_create(fsg_main_thread, fsg,
+			"file-storage-gadget");
+	if (IS_ERR(fsg-&gt;thread_task)) {
+		rc = PTR_ERR(fsg-&gt;thread_task);
 		goto out;
-	fsg-&gt;thread_pid = rc;
+	}
 
 	INFO(fsg, DRIVER_DESC ", version: " DRIVER_VERSION "\n");
 	INFO(fsg, "Number of LUNs=%d\n", fsg-&gt;nluns);
@@ -3994,7 +3988,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	DBG(fsg, "removable=%d, stall=%d, buflen=%u\n",
 			mod_data.removable, mod_data.can_stall,
 			mod_data.buflen);
-	DBG(fsg, "I/O thread pid: %d\n", fsg-&gt;thread_pid);
+	DBG(fsg, "I/O thread pid: %d\n", fsg-&gt;thread_task-&gt;pid);
 	return 0;
 
 autoconf_fail:
@@ -4093,7 +4087,7 @@ static int __init fsg_init(void)
 	set_bit(REGISTERED, &amp;fsg-&gt;atomic_bitflags);
 
 	/* Tell the thread to start working */
-	complete(&amp;fsg-&gt;thread_notifier);
+	wake_up_process(fsg-&gt;thread_task);
 	return 0;
 }
 module_init(fsg_init);</pre><hr><pre>commit 8b262bd25580e165710e8a27df19cd60c2ef58a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 16:31:15 2005 -0400

    [PATCH] USB: UHCI: Spruce up some comments
    
    This patch (as570) changes some comments in the uhci-hcd header file and
    removes an unused declaration (something I forgot to erase in an earlier
    patch).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    
     drivers/usb/host/uhci-hcd.h |   91 +++++++++++++++++++++++---------------------
     1 file changed, 49 insertions(+), 42 deletions(-)

diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index b04d99df0a0e..e576db57a926 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -7,6 +7,7 @@
 #define usb_packetid(pipe)	(usb_pipein(pipe) ? USB_PID_IN : USB_PID_OUT)
 #define PIPE_DEVEP_MASK		0x0007ff00
 
+
 /*
  * Universal Host Controller Interface data structures and defines
  */
@@ -82,15 +83,10 @@
 #define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
 #define CAN_SCHEDULE_FRAMES	1000	/* how far future frames can be scheduled */
 
-struct uhci_frame_list {
-	__le32 frame[UHCI_NUMFRAMES];
-
-	void *frame_cpu[UHCI_NUMFRAMES];
 
-	dma_addr_t dma_handle;
-};
-
-struct urb_priv;
+/*
+ *	Queue Headers
+ */
 
 /*
  * One role of a QH is to hold a queue of TDs for some endpoint.  Each QH is
@@ -116,13 +112,13 @@ struct uhci_qh {
 
 	struct urb_priv *urbp;
 
-	struct list_head list;		/* P: uhci-&gt;frame_list_lock */
-	struct list_head remove_list;	/* P: uhci-&gt;remove_list_lock */
+	struct list_head list;
+	struct list_head remove_list;
 } __attribute__((aligned(16)));
 
 /*
  * We need a special accessor for the element pointer because it is
- * subject to asynchronous updates by the controller
+ * subject to asynchronous updates by the controller.
  */
 static __le32 inline qh_element(struct uhci_qh *qh) {
 	__le32 element = qh-&gt;element;
@@ -131,6 +127,11 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
 	return element;
 }
 
+
+/*
+ *	Transfer Descriptors
+ */
+
 /*
  * for TD &lt;status&gt;:
  */
@@ -183,17 +184,10 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
  *
  * That's silly, the hardware doesn't care. The hardware only cares that
  * the hardware words are 16-byte aligned, and we can have any amount of
- * sw space after the TD entry as far as I can tell.
- *
- * But let's just go with the documentation, at least for 32-bit machines.
- * On 64-bit machines we probably want to take advantage of the fact that
- * hw doesn't really care about the size of the sw-only area.
- *
- * Alas, not anymore, we have more than 4 words for software, woops.
- * Everything still works tho, surprise! -jerdfelt
+ * sw space after the TD entry.
  *
  * td-&gt;link points to either another TD (not necessarily for the same urb or
- * even the same endpoint), or nothing (PTR_TERM), or a QH (for queued urbs)
+ * even the same endpoint), or nothing (PTR_TERM), or a QH (for queued urbs).
  */
 struct uhci_td {
 	/* Hardware fields */
@@ -205,16 +199,16 @@ struct uhci_td {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct list_head list;		/* P: urb-&gt;lock */
-	struct list_head remove_list;	/* P: uhci-&gt;td_remove_list_lock */
+	struct list_head list;
+	struct list_head remove_list;
 
 	int frame;			/* for iso: what frame? */
-	struct list_head fl_list;	/* P: uhci-&gt;frame_list_lock */
+	struct list_head fl_list;
 } __attribute__((aligned(16)));
 
 /*
  * We need a special accessor for the control/status word because it is
- * subject to asynchronous updates by the controller
+ * subject to asynchronous updates by the controller.
  */
 static u32 inline td_status(struct uhci_td *td) {
 	__le32 status = td-&gt;status;
@@ -224,6 +218,10 @@ static u32 inline td_status(struct uhci_td *td) {
 }
 
 
+/*
+ *	Skeleton Queue Headers
+ */
+
 /*
  * The UHCI driver places Interrupt, Control and Bulk into QH's both
  * to group together TD's for one transfer, and also to faciliate queuing
@@ -254,15 +252,15 @@ static u32 inline td_status(struct uhci_td *td) {
  *
  * The terminating QH is used for 2 reasons:
  * - To place a terminating TD which is used to workaround a PIIX bug
- *   (see Intel errata for explanation)
+ *   (see Intel errata for explanation), and
  * - To loop back to the full-speed control queue for full-speed bandwidth
- *   reclamation
+ *   reclamation.
  *
  * Isochronous transfers are stored before the start of the skeleton
  * schedule and don't use QH's. While the UHCI spec doesn't forbid the
- * use of QH's for Isochronous, it doesn't use them either. Since we don't
- * need to use them either, we follow the spec diagrams in hope that it'll
- * be more compatible with future UHCI implementations.
+ * use of QH's for Isochronous, it doesn't use them either. And the spec
+ * says that queues never advance on an error completion status, which
+ * makes them totally unsuitable for Isochronous transfers.
  */
 
 #define UHCI_NUM_SKELQH		12
@@ -312,8 +310,13 @@ static inline int __interval_to_skel(int interval)
 	return 0;				/* int128 for 128-255 ms (Max.) */
 }
 
+
+/*
+ *	The UHCI controller and root hub
+ */
+
 /*
- * States for the root hub.
+ * States for the root hub:
  *
  * To prevent "bouncing" in the presence of electrical noise,
  * when there are no devices attached we delay for 1 second in the
@@ -324,7 +327,7 @@ static inline int __interval_to_skel(int interval)
  */
 enum uhci_rh_state {
 	/* In the following states the HC must be halted.
-	 * These two must come first */
+	 * These two must come first. */
 	UHCI_RH_RESET,
 	UHCI_RH_SUSPENDED,
 
@@ -336,13 +339,13 @@ enum uhci_rh_state {
 	UHCI_RH_SUSPENDING,
 
 	/* In the following states it's an error if the HC is halted.
-	 * These two must come last */
+	 * These two must come last. */
 	UHCI_RH_RUNNING,		/* The normal state */
 	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
 };
 
 /*
- * This describes the full uhci information.
+ * The full UHCI controller information:
  */
 struct uhci_hcd {
 
@@ -361,7 +364,7 @@ struct uhci_hcd {
 	spinlock_t lock;
 
 	dma_addr_t frame_dma_handle;		/* Hardware frame list */
-	__le32 *frame;				/* P: uhci-&gt;lock */
+	__le32 *frame;
 	void **frame_cpu;			/* CPU's frame list */
 
 	int fsbr;				/* Full-speed bandwidth reclamation */
@@ -387,22 +390,22 @@ struct uhci_hcd {
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
 	/* Main list of URB's currently controlled by this HC */
-	struct list_head urb_list;		/* P: uhci-&gt;lock */
+	struct list_head urb_list;
 
 	/* List of QH's that are done, but waiting to be unlinked (race) */
-	struct list_head qh_remove_list;	/* P: uhci-&gt;lock */
+	struct list_head qh_remove_list;
 	unsigned int qh_remove_age;		/* Age in frames */
 
 	/* List of TD's that are done, but waiting to be freed (race) */
-	struct list_head td_remove_list;	/* P: uhci-&gt;lock */
+	struct list_head td_remove_list;
 	unsigned int td_remove_age;		/* Age in frames */
 
 	/* List of asynchronously unlinked URB's */
-	struct list_head urb_remove_list;	/* P: uhci-&gt;lock */
+	struct list_head urb_remove_list;
 	unsigned int urb_remove_age;		/* Age in frames */
 
 	/* List of URB's awaiting completion callback */
-	struct list_head complete_list;		/* P: uhci-&gt;lock */
+	struct list_head complete_list;
 
 	int rh_numports;			/* Number of root-hub ports */
 
@@ -421,13 +424,17 @@ static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
 
 #define uhci_dev(u)	(uhci_to_hcd(u)-&gt;self.controller)
 
+
+/*
+ *	Private per-URB data
+ */
 struct urb_priv {
 	struct list_head urb_list;
 
 	struct urb *urb;
 
 	struct uhci_qh *qh;		/* QH for this URB */
-	struct list_head td_list;	/* P: urb-&gt;lock */
+	struct list_head td_list;
 
 	unsigned fsbr : 1;		/* URB turned on FSBR */
 	unsigned fsbr_timeout : 1;	/* URB timed out on FSBR */
@@ -438,9 +445,10 @@ struct urb_priv {
 
 	unsigned long fsbrtime;		/* In jiffies */
 
-	struct list_head queue_list;	/* P: uhci-&gt;frame_list_lock */
+	struct list_head queue_list;
 };
 
+
 /*
  * Locking in uhci.c
  *
@@ -460,6 +468,5 @@ struct urb_priv {
 
 #define PCI_VENDOR_ID_GENESYS		0x17a0
 #define PCI_DEVICE_ID_GL880S_UHCI	0x8083
-#define PCI_DEVICE_ID_GL880S_EHCI	0x8084
 
 #endif</pre><hr><pre>commit d09d36a91c70cb3cc609d693bf6a7e7a266ff9e6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 16:22:45 2005 -0400

    [PATCH] USB: usb_bulk_message() handles interrupts endpoints
    
    Because there is no bulk_interrupt_message() routine and no
    USBDEVFS_INTERRUPT ioctl, people have been forced to abuse the
    usb_bulk_message() routine and USBDEVFS_BULK by using them for interrupt
    transfers as well as bulk transfers.
    
    This patch (as567) formalizes this practice and adds code to
    usb_bulk_message() for detecting when the target is really an interrupt
    endpoint.  If it is, the routine submits an interrupt URB (using the
    default interval) instead of a bulk URB.  In theory this should help HCDs
    that don't like it when people try to mix transfer types, queuing both
    periodic and non-periodic types for the same endpoint.
    
    Not fully tested -- I don't have any programs that use USBDEVFS_BULK for
    interrupt transfers -- but it compiles okay and normal bulk messages work
    as well as before.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    
     drivers/usb/core/message.c |   24 ++++++++++++++++++++----
     1 file changed, 20 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index ebf59ea99263..574d0d4b3401 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -187,21 +187,37 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u
  *      If a thread in your driver uses this call, make sure your disconnect()
  *      method can wait for it to complete.  Since you don't have a handle on
  *      the URB used, you can't cancel the request.
+ *
+ *	Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT
+ *	ioctl, users are forced to abuse this routine by using it to submit
+ *	URBs for interrupt endpoints.  We will take the liberty of creating
+ *	an interrupt URB (with the default interval) if the target is an
+ *	interrupt endpoint.
  */
 int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe, 
 			void *data, int len, int *actual_length, int timeout)
 {
 	struct urb *urb;
+	struct usb_host_endpoint *ep;
 
-	if (len &lt; 0)
+	ep = (usb_pipein(pipe) ? usb_dev-&gt;ep_in : usb_dev-&gt;ep_out)
+			[usb_pipeendpoint(pipe)];
+	if (!ep || len &lt; 0)
 		return -EINVAL;
 
-	urb=usb_alloc_urb(0, GFP_KERNEL);
+	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb)
 		return -ENOMEM;
 
-	usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
-			  usb_api_blocking_completion, NULL);
+	if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
+			USB_ENDPOINT_XFER_INT) {
+		pipe = (pipe &amp; ~(3 &lt;&lt; 30)) | (PIPE_INTERRUPT &lt;&lt; 30);
+		usb_fill_int_urb(urb, usb_dev, pipe, data, len,
+				usb_api_blocking_completion, NULL,
+				ep-&gt;desc.bInterval);
+	} else
+		usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
+				usb_api_blocking_completion, NULL);
 
 	return usb_start_wait_urb(urb, timeout, actual_length);
 }</pre><hr><pre>commit a1d59ce842a35b552f22868404e4e7c923242257
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 16 14:22:51 2005 -0400

    [PATCH] USB: UHCI: Split apart the physical and logical framelist arrays
    
    This patch (as563) splits the physical and logical framelist arrays in
    uhci-hcd into two separate pieces.  This will allow slightly better memory
    utilization, since each piece is no larger than a single page whereas
    before the whole thing was a little bigger than two pages.  It also allows
    the logical array to be allocated in non-DMA-coherent memory.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 04eddd7995c3..151154df37fa 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -445,11 +445,11 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "Frame List\n");
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
 		int shown = 0;
-		td = uhci-&gt;fl-&gt;frame_cpu[i];
+		td = uhci-&gt;frame_cpu[i];
 		if (!td)
 			continue;
 
-		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;fl-&gt;frame[i]) {
+		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;frame[i]) {
 			show_frame_num();
 			out += sprintf(out, "    frame list does not match td-&gt;dma_handle!\n");
 		}
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 17de9ee910f6..b44094fcd779 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -212,7 +212,7 @@ static void configure_hc(struct uhci_hcd *uhci)
 	outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
 
 	/* Store the frame list base address */
-	outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
+	outl(uhci-&gt;frame_dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
 
 	/* Set the current frame number */
 	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
@@ -445,8 +445,11 @@ static void release_uhci(struct uhci_hcd *uhci)
 
 	dma_pool_destroy(uhci-&gt;td_pool);
 
-	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
-			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
+	kfree(uhci-&gt;frame_cpu);
+
+	dma_free_coherent(uhci_dev(uhci),
+			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
+			uhci-&gt;frame, uhci-&gt;frame_dma_handle);
 
 	debugfs_remove(uhci-&gt;dentry);
 }
@@ -527,7 +530,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int retval = -EBUSY;
 	int i;
-	dma_addr_t dma_handle;
 	struct dentry *dentry;
 
 	hcd-&gt;uses_new_polling = 1;
@@ -561,17 +563,23 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
-	uhci-&gt;fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
-			&amp;dma_handle, 0);
-	if (!uhci-&gt;fl) {
+	uhci-&gt;frame = dma_alloc_coherent(uhci_dev(uhci),
+			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
+			&amp;uhci-&gt;frame_dma_handle, 0);
+	if (!uhci-&gt;frame) {
 		dev_err(uhci_dev(uhci), "unable to allocate "
 				"consistent memory for frame list\n");
-		goto err_alloc_fl;
+		goto err_alloc_frame;
 	}
+	memset(uhci-&gt;frame, 0, UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame));
 
-	memset((void *)uhci-&gt;fl, 0, sizeof(*uhci-&gt;fl));
-
-	uhci-&gt;fl-&gt;dma_handle = dma_handle;
+	uhci-&gt;frame_cpu = kcalloc(UHCI_NUMFRAMES, sizeof(*uhci-&gt;frame_cpu),
+			GFP_KERNEL);
+	if (!uhci-&gt;frame_cpu) {
+		dev_err(uhci_dev(uhci), "unable to allocate "
+				"memory for frame pointers\n");
+		goto err_alloc_frame_cpu;
+	}
 
 	uhci-&gt;td_pool = dma_pool_create("uhci_td", uhci_dev(uhci),
 			sizeof(struct uhci_td), 16, 0);
@@ -654,7 +662,7 @@ static int uhci_start(struct usb_hcd *hcd)
 			irq = 7;
 
 		/* Only place we don't use the frame list routines */
-		uhci-&gt;fl-&gt;frame[i] = UHCI_PTR_QH |
+		uhci-&gt;frame[i] = UHCI_PTR_QH |
 				cpu_to_le32(uhci-&gt;skelqh[irq]-&gt;dma_handle);
 	}
 
@@ -686,10 +694,14 @@ static int uhci_start(struct usb_hcd *hcd)
 	dma_pool_destroy(uhci-&gt;td_pool);
 
 err_create_td_pool:
-	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
-			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
+	kfree(uhci-&gt;frame_cpu);
+
+err_alloc_frame_cpu:
+	dma_free_coherent(uhci_dev(uhci),
+			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
+			uhci-&gt;frame, uhci-&gt;frame_dma_handle);
 
-err_alloc_fl:
+err_alloc_frame:
 	debugfs_remove(uhci-&gt;dentry);
 
 err_create_debug_entry:
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 1c161b4f5bcf..b04d99df0a0e 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -359,7 +359,11 @@ struct uhci_hcd {
 	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
 
 	spinlock_t lock;
-	struct uhci_frame_list *fl;		/* P: uhci-&gt;lock */
+
+	dma_addr_t frame_dma_handle;		/* Hardware frame list */
+	__le32 *frame;				/* P: uhci-&gt;lock */
+	void **frame_cpu;			/* CPU's frame list */
+
 	int fsbr;				/* Full-speed bandwidth reclamation */
 	unsigned long fsbrtimeout;		/* FSBR delay */
 
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index d54038211ca6..51de06bc438d 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -89,10 +89,10 @@ static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td,
 	td-&gt;frame = framenum;
 
 	/* Is there a TD already mapped there? */
-	if (uhci-&gt;fl-&gt;frame_cpu[framenum]) {
+	if (uhci-&gt;frame_cpu[framenum]) {
 		struct uhci_td *ftd, *ltd;
 
-		ftd = uhci-&gt;fl-&gt;frame_cpu[framenum];
+		ftd = uhci-&gt;frame_cpu[framenum];
 		ltd = list_entry(ftd-&gt;fl_list.prev, struct uhci_td, fl_list);
 
 		list_add_tail(&amp;td-&gt;fl_list, &amp;ftd-&gt;fl_list);
@@ -101,10 +101,10 @@ static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td,
 		wmb();
 		ltd-&gt;link = cpu_to_le32(td-&gt;dma_handle);
 	} else {
-		td-&gt;link = uhci-&gt;fl-&gt;frame[framenum];
+		td-&gt;link = uhci-&gt;frame[framenum];
 		wmb();
-		uhci-&gt;fl-&gt;frame[framenum] = cpu_to_le32(td-&gt;dma_handle);
-		uhci-&gt;fl-&gt;frame_cpu[framenum] = td;
+		uhci-&gt;frame[framenum] = cpu_to_le32(td-&gt;dma_handle);
+		uhci-&gt;frame_cpu[framenum] = td;
 	}
 }
 
@@ -114,16 +114,16 @@ static void uhci_remove_td(struct uhci_hcd *uhci, struct uhci_td *td)
 	if (td-&gt;frame == -1 &amp;&amp; list_empty(&amp;td-&gt;fl_list))
 		return;
 
-	if (td-&gt;frame != -1 &amp;&amp; uhci-&gt;fl-&gt;frame_cpu[td-&gt;frame] == td) {
+	if (td-&gt;frame != -1 &amp;&amp; uhci-&gt;frame_cpu[td-&gt;frame] == td) {
 		if (list_empty(&amp;td-&gt;fl_list)) {
-			uhci-&gt;fl-&gt;frame[td-&gt;frame] = td-&gt;link;
-			uhci-&gt;fl-&gt;frame_cpu[td-&gt;frame] = NULL;
+			uhci-&gt;frame[td-&gt;frame] = td-&gt;link;
+			uhci-&gt;frame_cpu[td-&gt;frame] = NULL;
 		} else {
 			struct uhci_td *ntd;
 
 			ntd = list_entry(td-&gt;fl_list.next, struct uhci_td, fl_list);
-			uhci-&gt;fl-&gt;frame[td-&gt;frame] = cpu_to_le32(ntd-&gt;dma_handle);
-			uhci-&gt;fl-&gt;frame_cpu[td-&gt;frame] = ntd;
+			uhci-&gt;frame[td-&gt;frame] = cpu_to_le32(ntd-&gt;dma_handle);
+			uhci-&gt;frame_cpu[td-&gt;frame] = ntd;
 		}
 	} else {
 		struct uhci_td *ptd;</pre><hr><pre>commit 8b4cd42134fbd3c9a9a5c3467d31717798219b1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 16 14:17:45 2005 -0400

    [PATCH] USB: UHCI: Remove unused fields and unneeded tests for NULL
    
    This patch (as562) removes from the uhci-hcd driver a few unused fields
    and some unnecessary tests against NULL and assignments to NULL.  In fact
    it wasn't until fairly recently that the tests became unnecessary.
    Before last winter it was possible that the driver's stop() routine would
    get called even if the start() routine returned an error, but now that
    can't happen.  Hence there's no longer any need to check for partial
    initialization.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 4538a98b6f9d..04eddd7995c3 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -348,7 +348,6 @@ static int uhci_show_urbp(struct uhci_hcd *uhci, struct urb_priv *urbp, char *bu
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, "Status=%d ", urbp-&gt;urb-&gt;status);
-	//out += sprintf(out, "Inserttime=%lx ",urbp-&gt;inserttime);
 	//out += sprintf(out, "FSBRtime=%lx ",urbp-&gt;fsbrtime);
 
 	count = 0;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 0c024898cbea..17de9ee910f6 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -437,36 +437,18 @@ static void release_uhci(struct uhci_hcd *uhci)
 	int i;
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
-		if (uhci-&gt;skelqh[i]) {
-			uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
-			uhci-&gt;skelqh[i] = NULL;
-		}
+		uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
 
-	if (uhci-&gt;term_td) {
-		uhci_free_td(uhci, uhci-&gt;term_td);
-		uhci-&gt;term_td = NULL;
-	}
+	uhci_free_td(uhci, uhci-&gt;term_td);
 
-	if (uhci-&gt;qh_pool) {
-		dma_pool_destroy(uhci-&gt;qh_pool);
-		uhci-&gt;qh_pool = NULL;
-	}
+	dma_pool_destroy(uhci-&gt;qh_pool);
 
-	if (uhci-&gt;td_pool) {
-		dma_pool_destroy(uhci-&gt;td_pool);
-		uhci-&gt;td_pool = NULL;
-	}
+	dma_pool_destroy(uhci-&gt;td_pool);
 
-	if (uhci-&gt;fl) {
-		dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
-				uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
-		uhci-&gt;fl = NULL;
-	}
+	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
+			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
 
-	if (uhci-&gt;dentry) {
-		debugfs_remove(uhci-&gt;dentry);
-		uhci-&gt;dentry = NULL;
-	}
+	debugfs_remove(uhci-&gt;dentry);
 }
 
 static int uhci_reset(struct usb_hcd *hcd)
@@ -690,31 +672,25 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_alloc_skelqh:
-	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
-		if (uhci-&gt;skelqh[i]) {
+	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
+		if (uhci-&gt;skelqh[i])
 			uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
-			uhci-&gt;skelqh[i] = NULL;
-		}
+	}
 
 	uhci_free_td(uhci, uhci-&gt;term_td);
-	uhci-&gt;term_td = NULL;
 
 err_alloc_term_td:
 	dma_pool_destroy(uhci-&gt;qh_pool);
-	uhci-&gt;qh_pool = NULL;
 
 err_create_qh_pool:
 	dma_pool_destroy(uhci-&gt;td_pool);
-	uhci-&gt;td_pool = NULL;
 
 err_create_td_pool:
 	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
-	uhci-&gt;fl = NULL;
 
 err_alloc_fl:
 	debugfs_remove(uhci-&gt;dentry);
-	uhci-&gt;dentry = NULL;
 
 err_create_debug_entry:
 	return retval;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 282f40b75881..1c161b4f5bcf 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -205,8 +205,6 @@ struct uhci_td {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct urb *urb;
-
 	struct list_head list;		/* P: urb-&gt;lock */
 	struct list_head remove_list;	/* P: uhci-&gt;td_remove_list_lock */
 
@@ -434,7 +432,6 @@ struct urb_priv {
 						/*  a control transfer, retrigger */
 						/*  the status phase */
 
-	unsigned long inserttime;	/* In jiffies */
 	unsigned long fsbrtime;		/* In jiffies */
 
 	struct list_head queue_list;	/* P: uhci-&gt;frame_list_lock */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 4e0fbe2c1a9a..d54038211ca6 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -443,7 +443,6 @@ static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci, struct urb *u
 
 	memset((void *)urbp, 0, sizeof(*urbp));
 
-	urbp-&gt;inserttime = jiffies;
 	urbp-&gt;fsbrtime = jiffies;
 	urbp-&gt;urb = urb;
 	
@@ -462,8 +461,6 @@ static void uhci_add_td_to_urb(struct urb *urb, struct uhci_td *td)
 {
 	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
 
-	td-&gt;urb = urb;
-
 	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
 }
 
@@ -473,8 +470,6 @@ static void uhci_remove_td_from_urb(struct uhci_td *td)
 		return;
 
 	list_del_init(&amp;td-&gt;list);
-
-	td-&gt;urb = NULL;
 }
 
 static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)</pre><hr><pre>commit d1209d049bbc3df66650f8417637be4f7b57b604
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 21:23:51 2005 -0700

    [PATCH] Threads shouldn't inherit PF_NOFREEZE
    
    The PF_NOFREEZE process flag should not be inherited when a thread is
    forked.  This patch (as585) removes the flag from the child.
    
    This problem is starting to show up more and more as drivers turn to the
    kthread API instead of using kernel_thread().  As a result, their kernel
    threads are now children of the kthread worker instead of modprobe, and
    they inherit the PF_NOFREEZE flag.  This can cause problems during system
    suspend; the kernel threads are not getting frozen as they ought to be.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/kernel/fork.c b/kernel/fork.c
index 533ce27f4b2c..280bd44ac441 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -848,7 +848,7 @@ static inline void copy_flags(unsigned long clone_flags, struct task_struct *p)
 {
 	unsigned long new_flags = p-&gt;flags;
 
-	new_flags &amp;= ~PF_SUPERPRIV;
+	new_flags &amp;= ~(PF_SUPERPRIV | PF_NOFREEZE);
 	new_flags |= PF_FORKNOEXEC;
 	if (!(clone_flags &amp; CLONE_PTRACE))
 		p-&gt;ptrace = 0;</pre><hr><pre>commit 7c72ce81870ded9365f4bc5caa98ef1591dd18dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 14 11:23:27 2005 -0400

    [SCSI] Fix leak of Scsi_Cmnds
    
    When a request is deferred in scsi_init_io because the sg table could not
    be allocated, the associated scsi_cmnd is not released and the request is
    not marked with REQ_DONTPREP.  When the command is retried, if
    scsi_prep_fn decides to kill it then the scsi_cmnd will never be released.
    
    This patch (as573) changes scsi_init_io so that it calls scsi_put_command
    before deferring a request.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index dc9c772bc874..0074f28c37b2 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -97,7 +97,6 @@ int scsi_insert_special_req(struct scsi_request *sreq, int at_head)
 }
 
 static void scsi_run_queue(struct request_queue *q);
-static void scsi_release_buffers(struct scsi_cmnd *cmd);
 
 /*
  * Function:	scsi_unprep_request()
@@ -1040,8 +1039,10 @@ static int scsi_init_io(struct scsi_cmnd *cmd)
 	 * if sg table allocation fails, requeue request later.
 	 */
 	sgpnt = scsi_alloc_sgtable(cmd, GFP_ATOMIC);
-	if (unlikely(!sgpnt))
+	if (unlikely(!sgpnt)) {
+		scsi_unprep_request(req);
 		return BLKPREP_DEFER;
+	}
 
 	cmd-&gt;request_buffer = (char *) sgpnt;
 	cmd-&gt;request_bufflen = req-&gt;nr_sectors &lt;&lt; 9;
@@ -1245,8 +1246,8 @@ static int scsi_prep_fn(struct request_queue *q, struct request *req)
 		 */
 		ret = scsi_init_io(cmd);
 		switch(ret) {
+			/* For BLKPREP_KILL/DEFER the cmd was released */
 		case BLKPREP_KILL:
-			/* BLKPREP_KILL return also releases the command */
 			goto kill;
 		case BLKPREP_DEFER:
 			goto defer;</pre><hr><pre>commit 0fc084eaffe0a9a82a0c94da9ee9f7060ade8b04
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 22 00:49:51 2005 -0700

    [PATCH] USB: Update Documentation/usb/URB.txt
    
    This patch (as564) updates Documentation/usb/URB.txt, bringing it roughly
    up to the current level.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/Documentation/usb/URB.txt b/Documentation/usb/URB.txt
index d59b95cc6f1b..a49e5f2c2b46 100644
--- a/Documentation/usb/URB.txt
+++ b/Documentation/usb/URB.txt
@@ -1,5 +1,6 @@
 Revised: 2000-Dec-05.
 Again:   2002-Jul-06
+Again:   2005-Sep-19
 
     NOTE:
 
@@ -18,8 +19,8 @@ called USB Request Block, or URB for short.
   and deliver the data and status back. 
 
 - Execution of an URB is inherently an asynchronous operation, i.e. the 
-  usb_submit_urb(urb) call returns immediately after it has successfully queued 
-  the requested action. 
+  usb_submit_urb(urb) call returns immediately after it has successfully
+  queued the requested action.
 
 - Transfers for one URB can be canceled with usb_unlink_urb(urb) at any time. 
 
@@ -94,8 +95,9 @@ To free an URB, use
 
 	void usb_free_urb(struct urb *urb)
 
-You may not free an urb that you've submitted, but which hasn't yet been
-returned to you in a completion callback.
+You may free an urb that you've submitted, but which hasn't yet been
+returned to you in a completion callback.  It will automatically be
+deallocated when it is no longer in use.
 
 
 1.4. What has to be filled in?
@@ -145,30 +147,36 @@ to get seamless ISO streaming.
 
 1.6. How to cancel an already running URB?
 
-For an URB which you've submitted, but which hasn't been returned to
-your driver by the host controller, call
+There are two ways to cancel an URB you've submitted but which hasn't
+been returned to your driver yet.  For an asynchronous cancel, call
 
 	int usb_unlink_urb(struct urb *urb)
 
 It removes the urb from the internal list and frees all allocated
-HW descriptors. The status is changed to reflect unlinking. After 
-usb_unlink_urb() returns with that status code, you can free the URB
-with usb_free_urb().
+HW descriptors. The status is changed to reflect unlinking.  Note
+that the URB will not normally have finished when usb_unlink_urb()
+returns; you must still wait for the completion handler to be called.
 
-There is also an asynchronous unlink mode.  To use this, set the
-the URB_ASYNC_UNLINK flag in urb-&gt;transfer flags before calling
-usb_unlink_urb().  When using async unlinking, the URB will not
-normally be unlinked when usb_unlink_urb() returns.  Instead, wait
-for the completion handler to be called.
+To cancel an URB synchronously, call
+
+	void usb_kill_urb(struct urb *urb)
+
+It does everything usb_unlink_urb does, and in addition it waits
+until after the URB has been returned and the completion handler
+has finished.  It also marks the URB as temporarily unusable, so
+that if the completion handler or anyone else tries to resubmit it
+they will get a -EPERM error.  Thus you can be sure that when
+usb_kill_urb() returns, the URB is totally idle.
 
 
 1.7. What about the completion handler?
 
 The handler is of the following type:
 
-	typedef void (*usb_complete_t)(struct urb *);
+	typedef void (*usb_complete_t)(struct urb *, struct pt_regs *)
 
-i.e. it gets just the URB that caused the completion call.
+I.e., it gets the URB that caused the completion call, plus the
+register values at the time of the corresponding interrupt (if any).
 In the completion handler, you should have a look at urb-&gt;status to
 detect any USB errors. Since the context parameter is included in the URB,
 you can pass information to the completion handler. 
@@ -176,17 +184,11 @@ you can pass information to the completion handler.
 Note that even when an error (or unlink) is reported, data may have been
 transferred.  That's because USB transfers are packetized; it might take
 sixteen packets to transfer your 1KByte buffer, and ten of them might
-have transferred succesfully before the completion is called.
+have transferred succesfully before the completion was called.
 
 
 NOTE:  ***** WARNING *****
-Don't use urb-&gt;dev field in your completion handler; it's cleared
-as part of giving urbs back to drivers.  (Addressing an issue with
-ownership of periodic URBs, which was otherwise ambiguous.) Instead,
-use urb-&gt;context to hold all the data your driver needs.
-
-NOTE:  ***** WARNING *****
-Also, NEVER SLEEP IN A COMPLETION HANDLER.  These are normally called
+NEVER SLEEP IN A COMPLETION HANDLER.  These are normally called
 during hardware interrupt processing.  If you can, defer substantial
 work to a tasklet (bottom half) to keep system latencies low.  You'll
 probably need to use spinlocks to protect data structures you manipulate
@@ -229,24 +231,10 @@ ISO data with some other event stream.
 Interrupt transfers, like isochronous transfers, are periodic, and happen
 in intervals that are powers of two (1, 2, 4 etc) units.  Units are frames
 for full and low speed devices, and microframes for high speed ones.
-
-Currently, after you submit one interrupt URB, that urb is owned by the
-host controller driver until you cancel it with usb_unlink_urb().  You
-may unlink interrupt urbs in their completion handlers, if you need to.
-
-After a transfer completion is called, the URB is automagically resubmitted.
-THIS BEHAVIOR IS EXPECTED TO BE REMOVED!!
-
-Interrupt transfers may only send (or receive) the "maxpacket" value for
-the given interrupt endpoint; if you need more data, you will need to
-copy that data out of (or into) another buffer.  Similarly, you can't
-queue interrupt transfers.
-THESE RESTRICTIONS ARE EXPECTED TO BE REMOVED!!
-
-Note that this automagic resubmission model does make it awkward to use
-interrupt OUT transfers.  The portable solution involves unlinking those
-OUT urbs after the data is transferred, and perhaps submitting a final
-URB for a short packet.
-
 The usb_submit_urb() call modifies urb-&gt;interval to the implemented interval
 value that is less than or equal to the requested interval value.
+
+In Linux 2.6, unlike earlier versions, interrupt URBs are not automagically
+restarted when they complete.  They end when the completion handler is
+called, just like other URBs.  If you want an interrupt URB to be restarted,
+your completion handler must resubmit it.</pre><hr><pre>commit a64358db1253b35d508a411e80a3ad23b859ec88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:27:10 2005 -0400

    [SCSI] SCSI scanning and removal fixes
    
    This patch (as545) fixes the list traversals in __scsi_remove_target and
    scsi_forget_host.  In each case the existing code list_for_each_entry_safe
    in an _unsafe_ manner, because the list was not protected from outside
    modification while the iteration was running.
    
    The new scsi_forget_host routine takes the moderately controversial step
    of iterating over devices for removal rather than iterating over targets.
    This makes more sense to me because the current scheme treats targets as
    second-class citizens, created and removed on demand, rather than as
    objects corresponding to actual hardware.  (Also I couldn't figure out any
    safe way to iterate over the target list, since it's not so easy to tell
    when a target has already been removed.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index b86f170fa8ed..fcf9f6cbb142 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1466,23 +1466,17 @@ EXPORT_SYMBOL(scsi_scan_single_target);
 
 void scsi_forget_host(struct Scsi_Host *shost)
 {
-	struct scsi_target *starget, *tmp;
+	struct scsi_device *sdev;
 	unsigned long flags;
 
-	/*
-	 * Ok, this look a bit strange.  We always look for the first device
-	 * on the list as scsi_remove_device removes them from it - thus we
-	 * also have to release the lock.
-	 * We don't need to get another reference to the device before
-	 * releasing the lock as we already own the reference from
-	 * scsi_register_device that's release in scsi_remove_device.  And
-	 * after that we don't look at sdev anymore.
-	 */
+ restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
-	list_for_each_entry_safe(starget, tmp, &amp;shost-&gt;__targets, siblings) {
+	list_for_each_entry(sdev, &amp;shost-&gt;__devices, siblings) {
+		if (sdev-&gt;sdev_state == SDEV_DEL)
+			continue;
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-		scsi_remove_target(&amp;starget-&gt;dev);
-		spin_lock_irqsave(shost-&gt;host_lock, flags);
+		__scsi_remove_device(sdev);
+		goto restart;
 	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 }
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 83f87c41b18d..1e47b7eddef4 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -719,17 +719,20 @@ void __scsi_remove_target(struct scsi_target *starget)
 {
 	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);
 	unsigned long flags;
-	struct scsi_device *sdev, *tmp;
+	struct scsi_device *sdev;
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	starget-&gt;reap_ref++;
-	list_for_each_entry_safe(sdev, tmp, &amp;shost-&gt;__devices, siblings) {
+ restart:
+	list_for_each_entry(sdev, &amp;shost-&gt;__devices, siblings) {
 		if (sdev-&gt;channel != starget-&gt;channel ||
-		    sdev-&gt;id != starget-&gt;id)
+		    sdev-&gt;id != starget-&gt;id ||
+		    sdev-&gt;sdev_state == SDEV_DEL)
 			continue;
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 		scsi_remove_device(sdev);
 		spin_lock_irqsave(shost-&gt;host_lock, flags);
+		goto restart;
 	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 	scsi_target_reap(starget);</pre><hr><pre>commit b95be99d52ce4f9db9ff0bd5f10e9e2066da6d2e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 15 13:52:51 2005 -0400

    [SCSI] fix oops in scsi_release_buffers()
    
    I found one other thing that needs to be fixed.  The call to
    scsi_release_buffers in scsi_unprep_request causes an oops, because the
    sgtable has already been freed in scsi_io_completion.  The following patch
    is needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 0c6924eecf59..f065cbc1a6e5 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -118,7 +118,6 @@ static void scsi_unprep_request(struct request *req)
 	req-&gt;flags &amp;= ~REQ_DONTPREP;
 	req-&gt;special = (req-&gt;flags &amp; REQ_SPECIAL) ? cmd-&gt;sc_request : NULL;
 
-	scsi_release_buffers(cmd);
 	scsi_put_command(cmd);
 }
 
@@ -1512,7 +1511,6 @@ static void scsi_request_fn(struct request_queue *q)
 	 * cases (host limits or settings) should run the queue at some
 	 * later time.
 	 */
-	scsi_unprep_request(req);
 	spin_lock_irq(q-&gt;queue_lock);
 	blk_requeue_request(q, req);
 	sdev-&gt;device_busy--;</pre>
    <div class="pagination">
        <a href='2_134.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><span>[135]</span><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_136.html'>Next&gt;&gt;</a>
    <div>
</body>
