<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Johns Hopkins University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Johns Hopkins University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit 53d5864bc673288f03bb7892a3cffa41a173082b
Author: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
Date:   Thu Aug 21 14:10:55 2014 -0400

    kafs: Add more "unified AFS" error codes
    
    This should cover the set emitted by viced and the volume server.
    
    Signed-off-by: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
    Signed-off-by: David Howells &lt;dhowells@redhat.com&gt;

diff --git a/fs/afs/misc.c b/fs/afs/misc.c
index 0dd4dafee10b..91ea1aa0d8b3 100644
--- a/fs/afs/misc.c
+++ b/fs/afs/misc.c
@@ -22,9 +22,12 @@
 int afs_abort_to_error(u32 abort_code)
 {
 	switch (abort_code) {
+	/* low errno codes inserted into abort namespace */
 	case 13:		return -EACCES;
 	case 27:		return -EFBIG;
 	case 30:		return -EROFS;
+
+	/* VICE "special error" codes; 101 - 111 */
 	case VSALVAGE:		return -EIO;
 	case VNOVNODE:		return -ENOENT;
 	case VNOVOL:		return -ENOMEDIUM;
@@ -36,11 +39,18 @@ int afs_abort_to_error(u32 abort_code)
 	case VOVERQUOTA:	return -EDQUOT;
 	case VBUSY:		return -EBUSY;
 	case VMOVED:		return -ENXIO;
-	case 0x2f6df0a:		return -EWOULDBLOCK;
+
+	/* Unified AFS error table; ET "uae" == 0x2f6df00 */
+	case 0x2f6df00:		return -EPERM;
+	case 0x2f6df01:		return -ENOENT;
+	case 0x2f6df04:		return -EIO;
+	case 0x2f6df0a:		return -EAGAIN;
+	case 0x2f6df0b:		return -ENOMEM;
 	case 0x2f6df0c:		return -EACCES;
 	case 0x2f6df0f:		return -EBUSY;
 	case 0x2f6df10:		return -EEXIST;
 	case 0x2f6df11:		return -EXDEV;
+	case 0x2f6df12:		return -ENODEV;
 	case 0x2f6df13:		return -ENOTDIR;
 	case 0x2f6df14:		return -EISDIR;
 	case 0x2f6df15:		return -EINVAL;
@@ -54,8 +64,12 @@ int afs_abort_to_error(u32 abort_code)
 	case 0x2f6df23:		return -ENAMETOOLONG;
 	case 0x2f6df24:		return -ENOLCK;
 	case 0x2f6df26:		return -ENOTEMPTY;
+	case 0x2f6df28:		return -EWOULDBLOCK;
+	case 0x2f6df69:		return -ENOTCONN;
+	case 0x2f6df6c:		return -ETIMEDOUT;
 	case 0x2f6df78:		return -EDQUOT;
 
+	/* RXKAD abort codes; from include/rxrpc/packet.h.  ET "RXK" == 0x1260B00 */
 	case RXKADINCONSISTENCY: return -EPROTO;
 	case RXKADPACKETSHORT:	return -EPROTO;
 	case RXKADLEVELFAIL:	return -EKEYREJECTED;</pre><hr><pre>commit 5e71fc8629cefae5f3c1a4f498de3fe4f631924a
Author: Nathaniel W Filardo &lt;nwf@cs.jhu.edu&gt;
Date:   Mon Mar 16 11:19:55 2015 -0400

    USB: keyspan_pda: add new device id
    
    Add USB VID/PID for Xircom PGMFHUB USB/serial component.  (The hub and SCSI
    bridge on that hardware are recognized out of the box by existing drivers.)
    Tested VID/PID using new_id and loopback connection and was met with
    success, but that's all the testing done.
    
    Signed-off-by: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/keyspan_pda.c b/drivers/usb/serial/keyspan_pda.c
index dd97d8b572c3..4f7e072e4e00 100644
--- a/drivers/usb/serial/keyspan_pda.c
+++ b/drivers/usb/serial/keyspan_pda.c
@@ -61,6 +61,7 @@ struct keyspan_pda_private {
 /* For Xircom PGSDB9 and older Entrega version of the same device */
 #define XIRCOM_VENDOR_ID		0x085a
 #define XIRCOM_FAKE_ID			0x8027
+#define XIRCOM_FAKE_ID_2		0x8025 /* "PGMFHUB" serial */
 #define ENTREGA_VENDOR_ID		0x1645
 #define ENTREGA_FAKE_ID			0x8093
 
@@ -70,6 +71,7 @@ static const struct usb_device_id id_table_combined[] = {
 #endif
 #ifdef XIRCOM
 	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },
+	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },
 	{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },
 #endif
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_ID) },
@@ -93,6 +95,7 @@ static const struct usb_device_id id_table_fake[] = {
 #ifdef XIRCOM
 static const struct usb_device_id id_table_fake_xircom[] = {
 	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },
+	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },
 	{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },
 	{ }
 };</pre><hr><pre>commit 150a6b478982475c60fa25b7060ab990ece5483d
Author: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
Date:   Wed May 21 14:58:26 2014 +0100

    AFS: Fix kafs module unloading
    
    At present, it is not possible to successfully unload the kafs module if there
    are outstanding async outgoing calls (those made with afs_make_call()).  This
    appears to be due to the changes introduced by:
    
            commit 059499453a9abd1857d442b44da8b4c126dc72a8
            Author: Tejun Heo &lt;tj@kernel.org&gt;
            Date:   Fri Mar 7 10:24:50 2014 -0500
            Subject: afs: don't use PREPARE_WORK
    
    which didn't go far enough.  The problem is due to:
    
     (1) The aforementioned commit introduced a separate handler function pointer
         in the call, call-&gt;async_workfn, in addition to the original workqueue
         item, call-&gt;async_work, for asynchronous operations because workqueues
         subsystem cannot handle the workqueue item pointer being changed whilst
         the item is queued or being processed.
    
     (2) afs_async_workfn() was introduced in that commit to be the callback for
         call-&gt;async_work.  Its sole purpose is to run whatever call-&gt;async_workfn
         points to.
    
     (3) call-&gt;async_workfn is only used from afs_async_workfn(), which is only
         set on async_work by afs_collect_incoming_call() - ie. for incoming
         calls.
    
     (4) call-&gt;async_workfn is *not* set by afs_make_call() when outgoing calls are
         made, and call-&gt;async_work is set afs_process_async_call() - and not
         afs_async_workfn().
    
     (5) afs_process_async_call() now changes call-&gt;async_workfn rather than
         call-&gt;async_work to point to afs_delete_async_call() to clean up, but this
         is only effective for incoming calls because call-&gt;async_work does not
         point to afs_async_workfn() for outgoing calls.
    
     (6) Because, for incoming calls, call-&gt;async_work remains pointing to
         afs_process_async_call() this results in an infinite loop.
    
    Instead, make the workqueue uniformly vector through call-&gt;async_workfn, via
    afs_async_workfn() and simply initialise call-&gt;async_workfn to point to
    afs_process_async_call() in afs_make_call().
    
    Signed-off-by: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
    Signed-off-by: David Howells &lt;dhowells@redhat.com&gt;
    Reviewed-by: Tejun Heo &lt;tj@kernel.org&gt;

diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.c
index 1a1110b1a7ff..5a05014ea7b0 100644
--- a/fs/afs/rxrpc.c
+++ b/fs/afs/rxrpc.c
@@ -58,6 +58,13 @@ static void afs_collect_incoming_call(struct work_struct *);
 static struct sk_buff_head afs_incoming_calls;
 static DECLARE_WORK(afs_collect_incoming_call_work, afs_collect_incoming_call);
 
+static void afs_async_workfn(struct work_struct *work)
+{
+	struct afs_call *call = container_of(work, struct afs_call, async_work);
+
+	call-&gt;async_workfn(work);
+}
+
 /*
  * open an RxRPC socket and bind it to be a server for callback notifications
  * - the socket is left in blocking mode and non-blocking ops use MSG_DONTWAIT
@@ -348,7 +355,8 @@ int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,
 	       atomic_read(&amp;afs_outstanding_calls));
 
 	call-&gt;wait_mode = wait_mode;
-	INIT_WORK(&amp;call-&gt;async_work, afs_process_async_call);
+	call-&gt;async_workfn = afs_process_async_call;
+	INIT_WORK(&amp;call-&gt;async_work, afs_async_workfn);
 
 	memset(&amp;srx, 0, sizeof(srx));
 	srx.srx_family = AF_RXRPC;
@@ -672,13 +680,6 @@ void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)
 	call-&gt;reply_size += len;
 }
 
-static void afs_async_workfn(struct work_struct *work)
-{
-	struct afs_call *call = container_of(work, struct afs_call, async_work);
-
-	call-&gt;async_workfn(work);
-}
-
 /*
  * accept the backlog of incoming calls
  */</pre><hr><pre>commit 6cf12869f5c1a837f18af5f8b2308fa243772735
Author: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
Date:   Wed May 21 16:04:11 2014 +0100

    AFS: Part of afs_end_call() is identical to code elsewhere, so split it
    
    Split afs_end_call() into two pieces, one of which is identical to code in
    afs_process_async_call().  Replace the latter with a call to the first part of
    afs_end_call().
    
    Signed-off-by: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
    Signed-off-by: David Howells &lt;dhowells@redhat.com&gt;

diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.c
index 9226a6674d7f..1a1110b1a7ff 100644
--- a/fs/afs/rxrpc.c
+++ b/fs/afs/rxrpc.c
@@ -184,15 +184,24 @@ static void afs_free_call(struct afs_call *call)
 }
 
 /*
- * End a call
+ * End a call but do not free it
  */
-static void afs_end_call(struct afs_call *call)
+static void afs_end_call_nofree(struct afs_call *call)
 {
 	if (call-&gt;rxcall) {
 		rxrpc_kernel_end_call(call-&gt;rxcall);
 		call-&gt;rxcall = NULL;
 	}
-	call-&gt;type-&gt;destructor(call);
+	if (call-&gt;type-&gt;destructor)
+		call-&gt;type-&gt;destructor(call);
+}
+
+/*
+ * End a call and free it
+ */
+static void afs_end_call(struct afs_call *call)
+{
+	afs_end_call_nofree(call);
 	afs_free_call(call);
 }
 
@@ -640,10 +649,7 @@ static void afs_process_async_call(struct work_struct *work)
 		call-&gt;reply = NULL;
 
 		/* kill the call */
-		rxrpc_kernel_end_call(call-&gt;rxcall);
-		call-&gt;rxcall = NULL;
-		if (call-&gt;type-&gt;destructor)
-			call-&gt;type-&gt;destructor(call);
+		afs_end_call_nofree(call);
 
 		/* we can't just delete the call because the work item may be
 		 * queued */</pre><hr><pre>commit fde0133b9cfa4e01b275e942ffc32fd78e27d27c
Author: Nathaniel W Filardo &lt;nwf@cs.jhu.edu&gt;
Date:   Thu May 15 15:51:22 2014 +0100

    af_rxrpc: Fix XDR length check in rxrpc key demarshalling.
    
    There may be padding on the ticket contained in the key payload, so just ensure
    that the claimed token length is large enough, rather than exactly the right
    size.
    
    Signed-off-by: Nathaniel Wesley Filardo &lt;nwf@cs.jhu.edu&gt;
    Signed-off-by: David Howells &lt;dhowells@redhat.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/rxrpc/ar-key.c b/net/rxrpc/ar-key.c
index 7633a752c65e..0ad080790a32 100644
--- a/net/rxrpc/ar-key.c
+++ b/net/rxrpc/ar-key.c
@@ -99,7 +99,7 @@ static int rxrpc_instantiate_xdr_rxkad(struct key *key, const __be32 *xdr,
 	_debug("tktlen: %x", tktlen);
 	if (tktlen &gt; AFSTOKEN_RK_TIX_MAX)
 		return -EKEYREJECTED;
-	if (8 * 4 + tktlen != toklen)
+	if (toklen &lt; 8 * 4 + tktlen)
 		return -EKEYREJECTED;
 
 	plen = sizeof(*token) + sizeof(*token-&gt;kad) + tktlen;</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
