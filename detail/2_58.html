<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_57.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><span>[58]</span><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_59.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1e12c910eed82da6971f1c0421a069c680faba2e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 17 10:40:51 2011 -0400

    EHCI: don't rescan interrupt QHs needlessly
    
    This patch (as1466) speeds up processing of ehci-hcd's periodic list.
    The existing code will pointlessly rescan an interrupt endpoint queue
    each time it encounters the queue's QH in the periodic list, which can
    happen quite a few times if the endpoint's period is low.  On some
    embedded systems, this useless overhead can waste so much time that
    the driver falls hopelessly behind and loses events.
    
    The patch introduces a "periodic_stamp" variable, which gets
    incremented each time scan_periodic() runs and each time the scan
    advances to a new frame.  If the corresponding stamp in an interrupt
    QH is equal to the current periodic_stamp, we assume the QH has
    already been scanned and skip over it.  Otherwise we scan the QH as
    usual, and if none of its URBs have completed then we store the
    current periodic_stamp in the QH's stamp, preventing it from being
    scanned again.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a46d6a1388c9..5d6bc624c961 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -826,6 +826,7 @@ qh_make (
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
 		qh-&gt;start = NO_FRAME;
+		qh-&gt;stamp = ehci-&gt;periodic_stamp;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
 			qh-&gt;c_usecs = 0;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1543c838b3d1..a7408d88fda0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -2287,6 +2287,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	}
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
+	++ehci-&gt;periodic_stamp;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2315,10 +2316,14 @@ scan_periodic (struct ehci_hcd *ehci)
 				temp.qh = qh_get (q.qh);
 				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
 				q = q.qh-&gt;qh_next;
-				modified = qh_completions (ehci, temp.qh);
-				if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
-						temp.qh-&gt;needs_rescan))
-					intr_deschedule (ehci, temp.qh);
+				if (temp.qh-&gt;stamp != ehci-&gt;periodic_stamp) {
+					modified = qh_completions(ehci, temp.qh);
+					if (!modified)
+						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
+					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
+							temp.qh-&gt;needs_rescan))
+						intr_deschedule(ehci, temp.qh);
+				}
 				qh_put (temp.qh);
 				break;
 			case Q_TYPE_FSTN:
@@ -2460,6 +2465,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			if (ehci-&gt;clock_frame != clock_frame) {
 				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
+				++ehci-&gt;periodic_stamp;
 			}
 		} else {
 			now_uframe++;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 829213423dea..f68e419cae87 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -118,6 +118,7 @@ struct ehci_hcd {			/* one per controller */
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		stamp;
+	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;</pre><hr><pre>commit 2b7aaf503d56216b847c8265421d2a7d9b42df3e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 16 12:15:19 2011 -0400

    OHCI: fix regression caused by nVidia shutdown workaround
    
    This patch (as1463) fixes a regression caused by commit
    3df7169e73fc1d71a39cffeacc969f6840cdf52b (OHCI: work around for nVidia
    shutdown problem).
    
    The original problem encountered by people using NVIDIA chipsets was
    that USB devices were not turning off when the system shut down.  For
    example, the LED on an optical mouse would remain on, draining a
    laptop's battery.  The problem was caused by a bug in the chipset; an
    OHCI controller in the Reset state would continue to drive a bus reset
    signal even after system shutdown.  The workaround was to put the
    controllers into the Suspend state instead.
    
    It turns out that later NVIDIA chipsets do not suffer from this bug.
    Instead some have the opposite bug: If a system is shut down while an
    OHCI controller is in the Suspend state, USB devices remain powered!
    On other systems, shutting down with a Suspended controller causes the
    system to reboot immediately.  Thus, working around the original bug
    on some machines exposes other bugs on other machines.
    
    The best solution seems to be to limit the workaround to OHCI
    controllers with a low-numbered PCI product ID.  I don't know exactly
    at what point NVIDIA changed their chipsets; the value used here is a
    guess.  So far it was worked out okay for all the people who have
    tested it.
    
    This fixes Bugzilla #35032.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andre "Osku" Schmidt &lt;andre.osku.schmidt@googlemail.com&gt;
    Tested-by: Yury Siamashka &lt;yurand2@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d84d6f0314f9..ad8166c681e2 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -181,10 +181,18 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
  */
 static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 {
+	struct pci_dev *pdev = to_pci_dev(hcd-&gt;self.controller);
 	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
-	ohci-&gt;flags |= OHCI_QUIRK_SHUTDOWN;
-	ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	/* Evidently nVidia fixed their later hardware; this is a guess at
+	 * the changeover point.
+	 */
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB		0x026d
+
+	if (pdev-&gt;device &lt; PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {
+		ohci-&gt;flags |= OHCI_QUIRK_SHUTDOWN;
+		ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	}
 
 	return 0;
 }</pre><hr><pre>commit cee6a262550f53a13acfefbc1e3e5ff35c96182c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 2 14:21:44 2011 -0400

    USB: fix regression in usbip by setting has_tt flag
    
    This patch (as1460) fixes a regression in the usbip driver caused by
    the new check for Transaction Translators in USB-2 hubs.  The root hub
    registered by vhci_hcd needs to have the has_tt flag set, because it
    can connect to low- and full-speed devices as well as high-speed
    devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Nikola Ciprich &lt;nikola.ciprich@linuxbox.cz&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/usbip/vhci_hcd.c b/drivers/staging/usbip/vhci_hcd.c
index 0f02a4b12ae4..5d0caa8648e2 100644
--- a/drivers/staging/usbip/vhci_hcd.c
+++ b/drivers/staging/usbip/vhci_hcd.c
@@ -1139,7 +1139,7 @@ static int vhci_hcd_probe(struct platform_device *pdev)
 		usbip_uerr("create hcd failed\n");
 		return -ENOMEM;
 	}
-
+	hcd-&gt;has_tt = 1;
 
 	/* this is private data for vhci_hcd */
 	the_controller = hcd_to_vhci(hcd);</pre><hr><pre>commit 869410f82cbbb1464772046d87de8d18a916e706
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 14 11:21:04 2011 -0400

    USB: add queued-unlinks test case to usbtest driver
    
    This patch (as1452b) adds a new test case to the usbtest driver.  Test
    24 exercises the unlink-from-queue pathways in the host.  It queues a
    user-specified number of bulk-OUT URBs of user-specified size, unlinks
    the fourth- and second-from-last URBs in the queue, and then waits to
    see if all the URBs complete in the expected way (except of course
    that the unlinked URBs might complete normally, if they weren't
    unlinked soon enough).
    
    This new test has confirmed the existence of a bug in the ehci-hcd
    driver, to be fixed by a separate patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 388cc128072a..58a5685fb7d1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1195,6 +1195,104 @@ static int unlink_simple(struct usbtest_dev *dev, int pipe, int len)
 
 /*-------------------------------------------------------------------------*/
 
+struct queued_ctx {
+	struct completion	complete;
+	atomic_t		pending;
+	unsigned		num;
+	int			status;
+	struct urb		**urbs;
+};
+
+static void unlink_queued_callback(struct urb *urb)
+{
+	int			status = urb-&gt;status;
+	struct queued_ctx	*ctx = urb-&gt;context;
+
+	if (ctx-&gt;status)
+		goto done;
+	if (urb == ctx-&gt;urbs[ctx-&gt;num - 4] || urb == ctx-&gt;urbs[ctx-&gt;num - 2]) {
+		if (status == -ECONNRESET)
+			goto done;
+		/* What error should we report if the URB completed normally? */
+	}
+	if (status != 0)
+		ctx-&gt;status = status;
+
+ done:
+	if (atomic_dec_and_test(&amp;ctx-&gt;pending))
+		complete(&amp;ctx-&gt;complete);
+}
+
+static int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,
+		unsigned size)
+{
+	struct queued_ctx	ctx;
+	struct usb_device	*udev = testdev_to_usbdev(dev);
+	void			*buf;
+	dma_addr_t		buf_dma;
+	int			i;
+	int			retval = -ENOMEM;
+
+	init_completion(&amp;ctx.complete);
+	atomic_set(&amp;ctx.pending, 1);	/* One more than the actual value */
+	ctx.num = num;
+	ctx.status = 0;
+
+	buf = usb_alloc_coherent(udev, size, GFP_KERNEL, &amp;buf_dma);
+	if (!buf)
+		return retval;
+	memset(buf, 0, size);
+
+	/* Allocate and init the urbs we'll queue */
+	ctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);
+	if (!ctx.urbs)
+		goto free_buf;
+	for (i = 0; i &lt; num; i++) {
+		ctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ctx.urbs[i])
+			goto free_urbs;
+		usb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,
+				unlink_queued_callback, &amp;ctx);
+		ctx.urbs[i]-&gt;transfer_dma = buf_dma;
+		ctx.urbs[i]-&gt;transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	}
+
+	/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */
+	for (i = 0; i &lt; num; i++) {
+		atomic_inc(&amp;ctx.pending);
+		retval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);
+		if (retval != 0) {
+			dev_err(&amp;dev-&gt;intf-&gt;dev, "submit urbs[%d] fail %d\n",
+					i, retval);
+			atomic_dec(&amp;ctx.pending);
+			ctx.status = retval;
+			break;
+		}
+	}
+	if (i == num) {
+		usb_unlink_urb(ctx.urbs[num - 4]);
+		usb_unlink_urb(ctx.urbs[num - 2]);
+	} else {
+		while (--i &gt;= 0)
+			usb_unlink_urb(ctx.urbs[i]);
+	}
+
+	if (atomic_dec_and_test(&amp;ctx.pending))		/* The extra count */
+		complete(&amp;ctx.complete);
+	wait_for_completion(&amp;ctx.complete);
+	retval = ctx.status;
+
+ free_urbs:
+	for (i = 0; i &lt; num; i++)
+		usb_free_urb(ctx.urbs[i]);
+	kfree(ctx.urbs);
+ free_buf:
+	usb_free_coherent(udev, size, buf, buf_dma);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
 static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
@@ -1970,8 +2068,6 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev-&gt;in_iso_pipe, dev-&gt;iso_in, 0);
 		break;
 
-	/* FIXME unlink from queue (ring with N urbs) */
-
 	/* FIXME scatterlist cancel (needs helper thread) */
 
 	/* Tests for bulk I/O using DMA mapping by core and odd address */
@@ -2064,6 +2160,26 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev-&gt;in_iso_pipe, dev-&gt;iso_in, 1);
 		break;
 
+	/* unlink URBs from a bulk-OUT queue */
+	case 24:
+		if (dev-&gt;out_pipe == 0 || !param-&gt;length || param-&gt;sglen &lt; 4)
+			break;
+		retval = 0;
+		dev_info(&amp;intf-&gt;dev, "TEST 17:  unlink from %d queues of "
+				"%d %d-byte writes\n",
+				param-&gt;iterations, param-&gt;sglen, param-&gt;length);
+		for (i = param-&gt;iterations; retval == 0 &amp;&amp; i &gt; 0; --i) {
+			retval = unlink_queued(dev, dev-&gt;out_pipe,
+						param-&gt;sglen, param-&gt;length);
+			if (retval) {
+				dev_err(&amp;intf-&gt;dev,
+					"unlink queued writes failed %d, "
+					"iterations left %d\n", retval, i);
+				break;
+			}
+		}
+		break;
+
 	}
 	do_gettimeofday(&amp;param-&gt;duration);
 	param-&gt;duration.tv_sec -= start.tv_sec;</pre><hr><pre>commit 6498d9db6d2dad4cf5deb2dd09e0816904f41ca5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 28 10:45:24 2011 -0400

    USB: documentation update for the pre_reset method
    
    This patch (as1459) updates the documentation for the pre_reset method
    in struct usb_driver.  When a driver is notified of an impending
    reset, it must cancel all outstanding I/O and not start any new I/O
    until it has been notified that the reset is complete.
    
    As far as I know, most existing drivers that implement pre_reset do
    this now.  The major exceptions appear to be the SpeedTouch and
    CDC-WDM drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/callbacks.txt b/Documentation/usb/callbacks.txt
index bfb36b34b79e..9e85846bdb98 100644
--- a/Documentation/usb/callbacks.txt
+++ b/Documentation/usb/callbacks.txt
@@ -95,9 +95,11 @@ pre_reset
 
 int (*pre_reset)(struct usb_interface *intf);
 
-Another driver or user space is triggering a reset on the device which
-contains the interface passed as an argument. Cease IO and save any
-device state you need to restore.
+A driver or user space is triggering a reset on the device which
+contains the interface passed as an argument. Cease IO, wait for all
+outstanding URBs to complete, and save any device state you need to
+restore.  No more URBs may be submitted until the post_reset method
+is called.
 
 If you need to allocate memory here, use GFP_NOIO or GFP_ATOMIC, if you
 are in atomic context.
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 65f78ca5d88e..73c7df489607 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -806,8 +806,10 @@ struct usbdrv_wrap {
  * @resume: Called when the device is being resumed by the system.
  * @reset_resume: Called when the suspended device has been reset instead
  *	of being resumed.
- * @pre_reset: Called by usb_reset_device() when the device
- *	is about to be reset.
+ * @pre_reset: Called by usb_reset_device() when the device is about to be
+ *	reset.  This routine must not return until the driver has no active
+ *	URBs for the device, and no more URBs may be submitted until the
+ *	post_reset method is called.
  * @post_reset: Called by usb_reset_device() after the device
  *	has been reset
  * @id_table: USB drivers use ID table to support hotplugging.</pre><hr><pre>commit 99083f16f04e050eab0059167b4980cd67e7aa5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:35:53 2011 -0400

    USB: UHCI: don't try to revive a dead controller
    
    This patch (as1457) abandons the curious strategy of declaring a
    controller dead following hibernation merely in order to reset and
    then revive it.  The core no longer allow dead controllers to spring
    back to life when the system resumes, so there's no reason to declare
    a working controller temporarily dead.  Instead we do an explicit
    reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 73db5569f57b..83344d688ff0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -140,8 +140,6 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
-
-	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
 }
 
 /*
@@ -837,16 +835,17 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* Make sure resume from hibernation re-enumerates everything */
-	if (hibernated)
-		uhci_hc_died(uhci);
+	if (hibernated) {
+		uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr);
+		finish_reset(uhci);
+	}
 
-	/* The firmware or a boot kernel may have changed the controller
-	 * settings during a system wakeup.  Check it and reconfigure
-	 * to avoid problems.
+	/* The firmware may have changed the controller settings during
+	 * a system wakeup.  Check it and reconfigure to avoid problems.
 	 */
-	check_and_reset_hc(uhci);
-
-	/* If the controller was dead before, it's back alive now */
+	else {
+		check_and_reset_hc(uhci);
+	}
 	configure_hc(uhci);
 
 	/* Tell the core if the controller had to be reset */</pre><hr><pre>commit 7d670a2ed770a3405a7edb1159e3fa9b3f43fe46
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:36:04 2011 -0400

    USB: UHCI: remove uses of hcd-&gt;state
    
    This patch (as1456) removes all uses of hcd-&gt;state from the uhci-hcd
    driver, as part of the overall strategy to eliminate hcd-&gt;state
    completely.  Now when a controller dies we call usb_hc_died()
    directly, instead of relying on the core interrupt handler to see that
    hcd-&gt;state has changed to HC_STATE_HALT and make the call for us.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 4f65b14e5e08..73db5569f57b 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -139,7 +139,6 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;port_c_suspend = uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 	clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 
 	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
@@ -188,10 +187,6 @@ static void configure_hc(struct uhci_hcd *uhci)
 	outw(uhci-&gt;frame_number &amp; UHCI_MAX_SOF_NUMBER,
 			uhci-&gt;io_addr + USBFRNUM);
 
-	/* Mark controller as not halted before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
-	mb();
-
 	/* Enable PIRQ */
 	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
 
@@ -360,7 +355,6 @@ __acquires(uhci-&gt;lock)
 
 static void start_rh(struct uhci_hcd *uhci)
 {
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 	uhci-&gt;is_stopped = 0;
 
 	/* Mark it configured and running with a 64-byte max packet.
@@ -449,6 +443,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 					lprintk(errbuf);
 				}
 				uhci_hc_died(uhci);
+				usb_hc_died(hcd);
 
 				/* Force a callback in case there are
 				 * pending unlinks */</pre><hr><pre>commit ee81b3e086c907a3347b15ef219a24fc8bf900f6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 25 11:46:27 2011 -0400

    USB: g_file_storage: don't send padding when stall=n
    
    This patch (as1455) removes the extra padding sent by g_file_storage
    and g_mass_storage when the gadget wants to send less data than
    requested by the host and isn't allowed to halt the bulk-IN endpoint.
    
    Although the Bulk-Only Transport specification requires the padding to
    be present, it isn't truly needed since the transfer will be terminated
    by a short packet anyway.  Furthermore, many existing devices don't
    bother to send any padding.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-By: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    CC: Roger Quadros &lt;roger.quadros@nokia.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 125587ac5d0b..98d6b39061d2 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -1569,37 +1569,6 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 	return rc;
 }
 
-static int pad_with_zeros(struct fsg_dev *fsg)
-{
-	struct fsg_buffhd	*bh = fsg-&gt;common-&gt;next_buffhd_to_fill;
-	u32			nkeep = bh-&gt;inreq-&gt;length;
-	u32			nsend;
-	int			rc;
-
-	bh-&gt;state = BUF_STATE_EMPTY;		/* For the first iteration */
-	fsg-&gt;common-&gt;usb_amount_left = nkeep + fsg-&gt;common-&gt;residue;
-	while (fsg-&gt;common-&gt;usb_amount_left &gt; 0) {
-
-		/* Wait for the next buffer to be free */
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(fsg-&gt;common);
-			if (rc)
-				return rc;
-		}
-
-		nsend = min(fsg-&gt;common-&gt;usb_amount_left, FSG_BUFLEN);
-		memset(bh-&gt;buf + nkeep, 0, nsend - nkeep);
-		bh-&gt;inreq-&gt;length = nsend;
-		bh-&gt;inreq-&gt;zero = 0;
-		start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-			       &amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-		bh = fsg-&gt;common-&gt;next_buffhd_to_fill = bh-&gt;next;
-		fsg-&gt;common-&gt;usb_amount_left -= nsend;
-		nkeep = 0;
-	}
-	return 0;
-}
-
 static int throw_away_data(struct fsg_common *common)
 {
 	struct fsg_buffhd	*bh;
@@ -1686,6 +1655,10 @@ static int finish_reply(struct fsg_common *common)
 		if (common-&gt;data_size == 0) {
 			/* Nothing to send */
 
+		/* Don't know what to do if common-&gt;fsg is NULL */
+		} else if (!fsg_is_set(common)) {
+			rc = -EIO;
+
 		/* If there's no residue, simply send the last buffer */
 		} else if (common-&gt;residue == 0) {
 			bh-&gt;inreq-&gt;zero = 0;
@@ -1694,24 +1667,19 @@ static int finish_reply(struct fsg_common *common)
 			common-&gt;next_buffhd_to_fill = bh-&gt;next;
 
 		/*
-		 * For Bulk-only, if we're allowed to stall then send the
-		 * short packet and halt the bulk-in endpoint.  If we can't
-		 * stall, pad out the remaining data with 0's.
+		 * For Bulk-only, mark the end of the data with a short
+		 * packet.  If we are allowed to stall, halt the bulk-in
+		 * endpoint.  (Note: This violates the Bulk-Only Transport
+		 * specification, which requires us to pad the data if we
+		 * don't halt the endpoint.  Presumably nobody will mind.)
 		 */
-		} else if (common-&gt;can_stall) {
+		} else {
 			bh-&gt;inreq-&gt;zero = 1;
 			if (!start_in_transfer(common, bh))
-				/* Don't know what to do if
-				 * common-&gt;fsg is NULL */
 				rc = -EIO;
 			common-&gt;next_buffhd_to_fill = bh-&gt;next;
-			if (common-&gt;fsg)
+			if (common-&gt;can_stall)
 				rc = halt_bulk_in_endpoint(common-&gt;fsg);
-		} else if (fsg_is_set(common)) {
-			rc = pad_with_zeros(common-&gt;fsg);
-		} else {
-			/* Don't know what to do if common-&gt;fsg is NULL */
-			rc = -EIO;
 		}
 		break;
 
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index d04e0e6b019d..aebfb81f3ba4 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1932,37 +1932,6 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 	return rc;
 }
 
-static int pad_with_zeros(struct fsg_dev *fsg)
-{
-	struct fsg_buffhd	*bh = fsg-&gt;next_buffhd_to_fill;
-	u32			nkeep = bh-&gt;inreq-&gt;length;
-	u32			nsend;
-	int			rc;
-
-	bh-&gt;state = BUF_STATE_EMPTY;		// For the first iteration
-	fsg-&gt;usb_amount_left = nkeep + fsg-&gt;residue;
-	while (fsg-&gt;usb_amount_left &gt; 0) {
-
-		/* Wait for the next buffer to be free */
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(fsg);
-			if (rc)
-				return rc;
-		}
-
-		nsend = min(fsg-&gt;usb_amount_left, (u32) mod_data.buflen);
-		memset(bh-&gt;buf + nkeep, 0, nsend - nkeep);
-		bh-&gt;inreq-&gt;length = nsend;
-		bh-&gt;inreq-&gt;zero = 0;
-		start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-				&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-		bh = fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
-		fsg-&gt;usb_amount_left -= nsend;
-		nkeep = 0;
-	}
-	return 0;
-}
-
 static int throw_away_data(struct fsg_dev *fsg)
 {
 	struct fsg_buffhd	*bh;
@@ -2066,18 +2035,20 @@ static int finish_reply(struct fsg_dev *fsg)
 			}
 		}
 
-		/* For Bulk-only, if we're allowed to stall then send the
-		 * short packet and halt the bulk-in endpoint.  If we can't
-		 * stall, pad out the remaining data with 0's. */
+		/*
+		 * For Bulk-only, mark the end of the data with a short
+		 * packet.  If we are allowed to stall, halt the bulk-in
+		 * endpoint.  (Note: This violates the Bulk-Only Transport
+		 * specification, which requires us to pad the data if we
+		 * don't halt the endpoint.  Presumably nobody will mind.)
+		 */
 		else {
-			if (mod_data.can_stall) {
-				bh-&gt;inreq-&gt;zero = 1;
-				start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-						&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-				fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
+			bh-&gt;inreq-&gt;zero = 1;
+			start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
+					&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
+			fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
+			if (mod_data.can_stall)
 				rc = halt_bulk_in_endpoint(fsg);
-			} else
-				rc = pad_with_zeros(fsg);
 		}
 		break;
 </pre><hr><pre>commit 94ae4976e253757e9b03a44d27d41b20f1829d80
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:36:15 2011 -0400

    USB: EHCI: unlink unused QHs when the controller is stopped
    
    This patch (as1458) fixes a problem affecting ultra-reliable systems:
    When hardware failover of an EHCI controller occurs, the data
    structures do not get released correctly.  This is because the routine
    responsible for removing unused QHs from the async schedule assumes
    the controller is running properly (the frame counter is used in
    determining how long the QH has been idle) -- but when a failover
    causes the controller to be electronically disconnected from the PCI
    bus, obviously it stops running.
    
    The solution is simple: Allow scan_async() to remove a QH from the
    async schedule if it has been idle for long enough _or_ if the
    controller is stopped.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-Tested-by: Dan Duval &lt;dan.duval@stratus.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 98ded66e8d3f..42abd0f603bf 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1247,24 +1247,27 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void scan_async (struct ehci_hcd *ehci)
 {
+	bool			stopped;
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
 	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
+	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
 	qh = ehci-&gt;async-&gt;qh_next.qh;
 	if (likely (qh != NULL)) {
 		do {
 			/* clean any finished work for this qh */
-			if (!list_empty (&amp;qh-&gt;qtd_list)
-					&amp;&amp; qh-&gt;stamp != ehci-&gt;stamp) {
+			if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; (stopped ||
+					qh-&gt;stamp != ehci-&gt;stamp)) {
 				int temp;
 
 				/* unlinks could happen here; completion
 				 * reporting drops the lock.  rescan using
 				 * the latest schedule, but don't rescan
-				 * qhs we already finished (no looping).
+				 * qhs we already finished (no looping)
+				 * unless the controller is stopped.
 				 */
 				qh = qh_get (qh);
 				qh-&gt;stamp = ehci-&gt;stamp;
@@ -1285,9 +1288,9 @@ static void scan_async (struct ehci_hcd *ehci)
 			 */
 			if (list_empty(&amp;qh-&gt;qtd_list)
 					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-				if (!ehci-&gt;reclaim
-					&amp;&amp; ((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
-						&gt;= (EHCI_SHRINK_FRAMES * 8))
+				if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
+					((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
+						&gt;= EHCI_SHRINK_FRAMES * 8))
 					start_unlink_async(ehci, qh);
 				else
 					action = TIMER_ASYNC_SHRINK;</pre><hr><pre>commit b5a3b3d985493c173925907adfebf3edab236fe7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 16 10:57:15 2011 -0400

    ehci-hcd: Bug fix: don't set a QH's Halt bit
    
    This patch (as1453) fixes a long-standing bug in the ehci-hcd driver.
    
    There is no need to set the Halt bit in the overlay region for an
    unlinked or blocked QH.  Contrary to what the comment says, setting
    the Halt bit does not cause the QH to be patched later; that decision
    (made in qh_refresh()) depends only on whether the QH is currently
    pointing to a valid qTD.  Likewise, setting the Halt bit does not
    prevent completions from activating the QH while it is "stopped"; they
    are prevented by the fact that qh_completions() temporarily changes
    qh-&gt;qh_state to QH_STATE_COMPLETING.
    
    On the other hand, there are circumstances in which the QH will be
    reactivated _without_ being patched; this happens after an URB beyond
    the head of the queue is unlinked.  Setting the Halt bit will then
    cause the hardware to see the QH with both the Active and Halt bits
    set, an invalid combination that will prevent the queue from
    advancing and may even crash some controllers.
    
    Apparently the only reason this hasn't been reported before is that
    unlinking URBs from the middle of a running queue is quite uncommon.
    However Test 17, recently added to the usbtest driver, does exactly
    this, and it confirms the presence of the bug.
    
    In short, there is no reason to set the Halt bit for an unlinked or
    blocked QH, and there is a very good reason not to set it.  Therefore
    the code that sets it is removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andiry Xu &lt;andiry.xu@amd.com&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index fe99895fb098..98ded66e8d3f 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -315,7 +315,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	int			stopped;
 	unsigned		count = 0;
 	u8			state;
-	const __le32		halt = HALT_BIT(ehci);
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
@@ -422,7 +421,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					&amp;&amp; !(qtd-&gt;hw_alt_next
 						&amp; EHCI_LIST_END(ehci))) {
 				stopped = 1;
-				goto halt;
 			}
 
 		/* stop scanning when we reach qtds the hc is using */
@@ -456,16 +454,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 				 */
 				ehci_clear_tt_buffer(ehci, qh, urb, token);
 			}
-
-			/* force halt for unlinked or blocked qh, so we'll
-			 * patch the qh later and so that completions can't
-			 * activate it while we "know" it's stopped.
-			 */
-			if ((halt &amp; hw-&gt;hw_token) == 0) {
-halt:
-				hw-&gt;hw_token |= halt;
-				wmb ();
-			}
 		}
 
 		/* unless we already know the urb's status, collect qtd status</pre>
    <div class="pagination">
        <a href='2_57.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><span>[58]</span><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_59.html'>Next&gt;&gt;</a>
    <div>
</body>
