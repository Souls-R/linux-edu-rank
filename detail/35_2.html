<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Rochester Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Rochester Institute of Technology</h1>
    <div class="pagination">
        <a href='35.html'>&lt;&lt;Prev</a><a href='35.html'>1</a><span>[2]</span>
    </div>
    <hr>
    <pre>commit 52618df95d0820be7add339068d3c42799393c09
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Dec 2 09:19:43 2015 -0500

    nfs: fix missing assignment in nfs4_sequence_done tracepoint
    
    status_flags not set
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;

diff --git a/fs/nfs/nfs4trace.h b/fs/nfs/nfs4trace.h
index 671cf68fe56b..4c1015462a81 100644
--- a/fs/nfs/nfs4trace.h
+++ b/fs/nfs/nfs4trace.h
@@ -321,6 +321,7 @@ TRACE_EVENT(nfs4_sequence_done,
 			__entry-&gt;highest_slotid = res-&gt;sr_highest_slotid;
 			__entry-&gt;target_highest_slotid =
 					res-&gt;sr_target_highest_slotid;
+			__entry-&gt;status_flags = res-&gt;sr_status_flags;
 			__entry-&gt;error = res-&gt;sr_status;
 		),
 		TP_printk(</pre><hr><pre>commit 7fc0564e3a8d16df096f48c9c6425ba84d945c6e
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Thu Nov 5 20:42:43 2015 -0500

    nfsd: fix race with open / open upgrade stateids
    
    We observed multiple open stateids on the server for files that
    seemingly should have been closed.
    
    nfsd4_process_open2() tests for the existence of a preexisting
    stateid. If one is not found, the locks are dropped and a new
    one is created. The problem is that init_open_stateid(), which
    is also responsible for hashing the newly initialized stateid,
    doesn't check to see if another open has raced in and created
    a matching stateid. This fix is to enable init_open_stateid() to
    return the matching stateid and have nfsd4_process_open2()
    swap to that stateid and switch to the open upgrade path.
    In testing this patch, coverage to the newly created
    path indicates that the race was indeed happening.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@poochiereds.net&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 6411c3421870..6b800b5b8fed 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3392,6 +3392,27 @@ static const struct nfs4_stateowner_operations openowner_ops = {
 	.so_free =	nfs4_free_openowner,
 };
 
+static struct nfs4_ol_stateid *
+nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)
+{
+	struct nfs4_ol_stateid *local, *ret = NULL;
+	struct nfs4_openowner *oo = open-&gt;op_openowner;
+
+	lockdep_assert_held(&amp;fp-&gt;fi_lock);
+
+	list_for_each_entry(local, &amp;fp-&gt;fi_stateids, st_perfile) {
+		/* ignore lock owners */
+		if (local-&gt;st_stateowner-&gt;so_is_open_owner == 0)
+			continue;
+		if (local-&gt;st_stateowner == &amp;oo-&gt;oo_owner) {
+			ret = local;
+			atomic_inc(&amp;ret-&gt;st_stid.sc_count);
+			break;
+		}
+	}
+	return ret;
+}
+
 static struct nfs4_openowner *
 alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,
 			   struct nfsd4_compound_state *cstate)
@@ -3423,9 +3444,20 @@ alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,
 	return ret;
 }
 
-static void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *open) {
+static struct nfs4_ol_stateid *
+init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp,
+		struct nfsd4_open *open)
+{
+
 	struct nfs4_openowner *oo = open-&gt;op_openowner;
+	struct nfs4_ol_stateid *retstp = NULL;
 
+	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
+	spin_lock(&amp;fp-&gt;fi_lock);
+
+	retstp = nfsd4_find_existing_open(fp, open);
+	if (retstp)
+		goto out_unlock;
 	atomic_inc(&amp;stp-&gt;st_stid.sc_count);
 	stp-&gt;st_stid.sc_type = NFS4_OPEN_STID;
 	INIT_LIST_HEAD(&amp;stp-&gt;st_locks);
@@ -3436,12 +3468,13 @@ static void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp,
 	stp-&gt;st_deny_bmap = 0;
 	stp-&gt;st_openstp = NULL;
 	init_rwsem(&amp;stp-&gt;st_rwsem);
-	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	list_add(&amp;stp-&gt;st_perstateowner, &amp;oo-&gt;oo_owner.so_stateids);
-	spin_lock(&amp;fp-&gt;fi_lock);
 	list_add(&amp;stp-&gt;st_perfile, &amp;fp-&gt;fi_stateids);
+
+out_unlock:
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
+	return retstp;
 }
 
 /*
@@ -3852,27 +3885,6 @@ nfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,
 	return nfs_ok;
 }
 
-static struct nfs4_ol_stateid *
-nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)
-{
-	struct nfs4_ol_stateid *local, *ret = NULL;
-	struct nfs4_openowner *oo = open-&gt;op_openowner;
-
-	spin_lock(&amp;fp-&gt;fi_lock);
-	list_for_each_entry(local, &amp;fp-&gt;fi_stateids, st_perfile) {
-		/* ignore lock owners */
-		if (local-&gt;st_stateowner-&gt;so_is_open_owner == 0)
-			continue;
-		if (local-&gt;st_stateowner == &amp;oo-&gt;oo_owner) {
-			ret = local;
-			atomic_inc(&amp;ret-&gt;st_stid.sc_count);
-			break;
-		}
-	}
-	spin_unlock(&amp;fp-&gt;fi_lock);
-	return ret;
-}
-
 static inline int nfs4_access_to_access(u32 nfs4_access)
 {
 	int flags = 0;
@@ -4258,6 +4270,7 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	struct nfs4_client *cl = open-&gt;op_openowner-&gt;oo_owner.so_client;
 	struct nfs4_file *fp = NULL;
 	struct nfs4_ol_stateid *stp = NULL;
+	struct nfs4_ol_stateid *swapstp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
 
@@ -4271,7 +4284,9 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 		status = nfs4_check_deleg(cl, open, &amp;dp);
 		if (status)
 			goto out;
+		spin_lock(&amp;fp-&gt;fi_lock);
 		stp = nfsd4_find_existing_open(fp, open);
+		spin_unlock(&amp;fp-&gt;fi_lock);
 	} else {
 		open-&gt;op_file = NULL;
 		status = nfserr_bad_stateid;
@@ -4294,7 +4309,19 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	} else {
 		stp = open-&gt;op_stp;
 		open-&gt;op_stp = NULL;
-		init_open_stateid(stp, fp, open);
+		swapstp = init_open_stateid(stp, fp, open);
+		if (swapstp) {
+			nfs4_put_stid(&amp;stp-&gt;st_stid);
+			stp = swapstp;
+			down_read(&amp;stp-&gt;st_rwsem);
+			status = nfs4_upgrade_open(rqstp, fp, current_fh,
+						stp, open);
+			if (status) {
+				up_read(&amp;stp-&gt;st_rwsem);
+				goto out;
+			}
+			goto upgrade_out;
+		}
 		down_read(&amp;stp-&gt;st_rwsem);
 		status = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);
 		if (status) {
@@ -4308,6 +4335,7 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 		if (stp-&gt;st_clnt_odstate == open-&gt;op_odstate)
 			open-&gt;op_odstate = NULL;
 	}
+upgrade_out:
 	nfs4_inc_and_copy_stateid(&amp;open-&gt;op_stateid, &amp;stp-&gt;st_stid);
 	up_read(&amp;stp-&gt;st_rwsem);
 </pre><hr><pre>commit 34ed9872e745fa56f10e9bef2cf3d2336c6c8816
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Thu Oct 15 12:07:28 2015 -0400

    nfsd: eliminate sending duplicate and repeated delegations
    
    We've observed the nfsd server in a state where there are
    multiple delegations on the same nfs4_file for the same client.
    The nfs client does attempt to DELEGRETURN these when they are presented to
    it - but apparently under some (unknown) circumstances the client does not
    manage to return all of them. This leads to the eventual
    attempt to CB_RECALL more than one delegation with the same nfs
    filehandle to the same client. The first recall will succeed, but the
    next recall will fail with NFS4ERR_BADHANDLE. This leads to the server
    having delegations on cl_revoked that the client has no way to FREE
    or DELEGRETURN, with resulting inability to recover. The state manager
    on the server will continually assert SEQ4_STATUS_RECALLABLE_STATE_REVOKED,
    and the state manager on the client will be looping unable to satisfy
    the server.
    
    List discussion also reports a race between OPEN and DELEGRETURN that
    will be avoided by only sending the delegation once to the
    client. This is also logically in accordance with RFC5561 9.1.1 and 10.2.
    
    So, let's:
    
    1.) Not hand out duplicate delegations.
    2.) Only send them to the client once.
    
    RFC 5561:
    
    9.1.1:
    "Delegations and layouts, on the other hand, are not associated with a
    specific owner but are associated with the client as a whole
    (identified by a client ID)."
    
    10.2:
    "...the stateid for a delegation is associated with a client ID and may be
    used on behalf of all the open-owners for the given client.  A
    delegation is made to the client as a whole and not to any specific
    process or thread of control within it."
    
    Reported-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Cc: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;
    Cc: Olga Kornievskaia &lt;aglo@umich.edu&gt;
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 0a697158a4ca..6411c3421870 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -778,16 +778,68 @@ void nfs4_unhash_stid(struct nfs4_stid *s)
 	s-&gt;sc_type = 0;
 }
 
-static void
+/**
+ * nfs4_get_existing_delegation - Discover if this delegation already exists
+ * @clp:     a pointer to the nfs4_client we're granting a delegation to
+ * @fp:      a pointer to the nfs4_file we're granting a delegation on
+ *
+ * Return:
+ *      On success: NULL if an existing delegation was not found.
+ *
+ *      On error: -EAGAIN if one was previously granted to this nfs4_client
+ *                 for this nfs4_file.
+ *
+ */
+
+static int
+nfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)
+{
+	struct nfs4_delegation *searchdp = NULL;
+	struct nfs4_client *searchclp = NULL;
+
+	lockdep_assert_held(&amp;state_lock);
+	lockdep_assert_held(&amp;fp-&gt;fi_lock);
+
+	list_for_each_entry(searchdp, &amp;fp-&gt;fi_delegations, dl_perfile) {
+		searchclp = searchdp-&gt;dl_stid.sc_client;
+		if (clp == searchclp) {
+			return -EAGAIN;
+		}
+	}
+	return 0;
+}
+
+/**
+ * hash_delegation_locked - Add a delegation to the appropriate lists
+ * @dp:     a pointer to the nfs4_delegation we are adding.
+ * @fp:     a pointer to the nfs4_file we're granting a delegation on
+ *
+ * Return:
+ *      On success: NULL if the delegation was successfully hashed.
+ *
+ *      On error: -EAGAIN if one was previously granted to this
+ *                 nfs4_client for this nfs4_file. Delegation is not hashed.
+ *
+ */
+
+static int
 hash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)
 {
+	int status;
+	struct nfs4_client *clp = dp-&gt;dl_stid.sc_client;
+
 	lockdep_assert_held(&amp;state_lock);
 	lockdep_assert_held(&amp;fp-&gt;fi_lock);
 
+	status = nfs4_get_existing_delegation(clp, fp);
+	if (status)
+		return status;
+	++fp-&gt;fi_delegees;
 	atomic_inc(&amp;dp-&gt;dl_stid.sc_count);
 	dp-&gt;dl_stid.sc_type = NFS4_DELEG_STID;
 	list_add(&amp;dp-&gt;dl_perfile, &amp;fp-&gt;fi_delegations);
-	list_add(&amp;dp-&gt;dl_perclnt, &amp;dp-&gt;dl_stid.sc_client-&gt;cl_delegations);
+	list_add(&amp;dp-&gt;dl_perclnt, &amp;clp-&gt;cl_delegations);
+	return 0;
 }
 
 static bool
@@ -3969,6 +4021,18 @@ static struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)
 	return fl;
 }
 
+/**
+ * nfs4_setlease - Obtain a delegation by requesting lease from vfs layer
+ * @dp:   a pointer to the nfs4_delegation we're adding.
+ *
+ * Return:
+ *      On success: Return code will be 0 on success.
+ *
+ *      On error: -EAGAIN if there was an existing delegation.
+ *                 nonzero if there is an error in other cases.
+ *
+ */
+
 static int nfs4_setlease(struct nfs4_delegation *dp)
 {
 	struct nfs4_file *fp = dp-&gt;dl_stid.sc_file;
@@ -4000,16 +4064,19 @@ static int nfs4_setlease(struct nfs4_delegation *dp)
 		goto out_unlock;
 	/* Race breaker */
 	if (fp-&gt;fi_deleg_file) {
-		status = 0;
-		++fp-&gt;fi_delegees;
-		hash_delegation_locked(dp, fp);
+		status = hash_delegation_locked(dp, fp);
 		goto out_unlock;
 	}
 	fp-&gt;fi_deleg_file = filp;
-	fp-&gt;fi_delegees = 1;
-	hash_delegation_locked(dp, fp);
+	fp-&gt;fi_delegees = 0;
+	status = hash_delegation_locked(dp, fp);
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;state_lock);
+	if (status) {
+		/* Should never happen, this is a new fi_deleg_file  */
+		WARN_ON_ONCE(1);
+		goto out_fput;
+	}
 	return 0;
 out_unlock:
 	spin_unlock(&amp;fp-&gt;fi_lock);
@@ -4029,6 +4096,15 @@ nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,
 	if (fp-&gt;fi_had_conflict)
 		return ERR_PTR(-EAGAIN);
 
+	spin_lock(&amp;state_lock);
+	spin_lock(&amp;fp-&gt;fi_lock);
+	status = nfs4_get_existing_delegation(clp, fp);
+	spin_unlock(&amp;fp-&gt;fi_lock);
+	spin_unlock(&amp;state_lock);
+
+	if (status)
+		return ERR_PTR(status);
+
 	dp = alloc_init_deleg(clp, fh, odstate);
 	if (!dp)
 		return ERR_PTR(-ENOMEM);
@@ -4047,9 +4123,7 @@ nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,
 		status = -EAGAIN;
 		goto out_unlock;
 	}
-	++fp-&gt;fi_delegees;
-	hash_delegation_locked(dp, fp);
-	status = 0;
+	status = hash_delegation_locked(dp, fp);
 out_unlock:
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;state_lock);</pre><hr><pre>commit a457974f1b9524a6e7d0a0be10df760e7802d32f
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Mon Aug 31 12:06:41 2015 -0400

    nfsd: deal with DELEGRETURN racing with CB_RECALL
    
    We have observed the server sending recalls for delegation stateids
    that have already been successfully returned. Change
    nfsd4_cb_recall_done() to return success if the client has returned
    the delegation. While this does not completely eliminate the sending
    of recalls for delegations that have already been returned, this
    does prevent unnecessarily declaring the callback path to be down.
    
    Reported-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Acked-by: Jeff Layton &lt;jlayton@poochiereds.net&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 08746ec1d44a..0f1d5691b795 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3510,6 +3510,9 @@ static int nfsd4_cb_recall_done(struct nfsd4_callback *cb,
 {
 	struct nfs4_delegation *dp = cb_to_delegation(cb);
 
+	if (dp-&gt;dl_stid.sc_type == NFS4_CLOSED_DELEG_STID)
+	        return 1;
+
 	switch (task-&gt;tk_status) {
 	case 0:
 		return 1;</pre><hr><pre>commit c1b8940b42bb6487b10f2267a96b486276ce9ff7
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Mon Feb 23 08:51:24 2015 -0500

    NFS: fix BUG() crash in notify_change() with patch to chown_common()
    
    We have observed a BUG() crash in fs/attr.c:notify_change(). The crash
    occurs during an rsync into a filesystem that is exported via NFS.
    
    1.) fs/attr.c:notify_change() modifies the caller's version of attr.
    2.) 6de0ec00ba8d ("VFS: make notify_change pass ATTR_KILL_S*ID to
        setattr operations") introduced a BUG() restriction such that "no
        function will ever call notify_change() with both ATTR_MODE and
        ATTR_KILL_S*ID set". Under some circumstances though, it will have
        assisted in setting the caller's version of attr to this very
        combination.
    3.) 27ac0ffeac80 ("locks: break delegations on any attribute
        modification") introduced code to handle breaking
        delegations. This can result in notify_change() being re-called. attr
        _must_ be explicitly reset to avoid triggering the BUG() established
        in #2.
    4.) The path that that triggers this is via fs/open.c:chmod_common().
        The combination of attr flags set here and in the first call to
        notify_change() along with a later failed break_deleg_wait()
        results in notify_change() being called again via retry_deleg
        without resetting attr.
    
    Solution is to move retry_deleg in chmod_common() a bit further up to
    ensure attr is completely reset.
    
    There are other places where this seemingly could occur, such as
    fs/utimes.c:utimes_common(), but the attr flags are not initially
    set in such a way to trigger this.
    
    Fixes: 27ac0ffeac80 ("locks: break delegations on any attribute modification")
    Reported-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Tested-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;

diff --git a/fs/open.c b/fs/open.c
index ebcc7df0c9b6..6a83c47d5904 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -570,6 +570,7 @@ static int chown_common(struct path *path, uid_t user, gid_t group)
 	uid = make_kuid(current_user_ns(), user);
 	gid = make_kgid(current_user_ns(), group);
 
+retry_deleg:
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		if (!uid_valid(uid))
@@ -586,7 +587,6 @@ static int chown_common(struct path *path, uid_t user, gid_t group)
 	if (!S_ISDIR(inode-&gt;i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
-retry_deleg:
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	error = security_path_chown(path, uid, gid);
 	if (!error)</pre><hr><pre>commit c876486be17aeefe0da569f3d111cbd8de6f675d
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Feb 25 17:46:27 2015 -0500

    nfsd: fix clp-&gt;cl_revoked list deletion causing softlock in nfsd
    
    commit 2d4a532d385f ("nfsd: ensure that clp-&gt;cl_revoked list is
    protected by clp-&gt;cl_lock") removed the use of the reaplist to
    clean out clp-&gt;cl_revoked. It failed to change list_entry() to
    walk clp-&gt;cl_revoked.next instead of reaplist.next
    
    Fixes: 2d4a532d385f ("nfsd: ensure that clp-&gt;cl_revoked list is protected by clp-&gt;cl_lock")
    Cc: stable@vger.kernel.org
    Reported-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Tested-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jeff.layton@primarydata.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index f6b2a09f793f..d2f2c37dc2db 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1638,7 +1638,7 @@ __destroy_client(struct nfs4_client *clp)
 		nfs4_put_stid(&amp;dp-&gt;dl_stid);
 	}
 	while (!list_empty(&amp;clp-&gt;cl_revoked)) {
-		dp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);
+		dp = list_entry(clp-&gt;cl_revoked.next, struct nfs4_delegation, dl_recall_lru);
 		list_del_init(&amp;dp-&gt;dl_recall_lru);
 		nfs4_put_stid(&amp;dp-&gt;dl_stid);
 	}</pre><hr><pre>commit 278702074ff77b1a3fa2061267997095959f5e2c
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Mon Feb 9 12:53:04 2015 -0500

    GFS2: Fix crash during ACL deletion in acl max entry check in gfs2_set_acl()
    
    Fixes: e01580bf9e ("gfs2: use generic posix ACL infrastructure")
    Reported-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Tested-by: Eric Meddaugh &lt;etmsys@rit.edu&gt;
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: Steven Whitehouse &lt;swhiteho@redhat.com&gt;

diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c
index 3088e2a38e30..7b3143064af1 100644
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@ -73,7 +73,7 @@ int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 
 	BUG_ON(name == NULL);
 
-	if (acl-&gt;a_count &gt; GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
+	if (acl &amp;&amp; acl-&gt;a_count &gt; GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
 		return -E2BIG;
 
 	if (type == ACL_TYPE_ACCESS) {</pre>
    <div class="pagination">
        <a href='35.html'>&lt;&lt;Prev</a><a href='35.html'>1</a><span>[2]</span>
    <div>
</body>
