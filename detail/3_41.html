<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_40.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><span>[41]</span><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_42.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6b8f1ca5581bf9783069cd6bde65ba7a3a470aab
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Aug 13 09:59:31 2010 -0400

    USB: ssu100: set tty_flags in ssu100_process_packet
    
    flag was never set in ssu100_process_packet.  Add logic to set it
    before calling tty_insert_flip_*
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 55e9672d286a..660c31f14999 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -602,7 +602,8 @@ static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
 	}
 }
 
-static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
+static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
+			      char *tty_flag)
 {
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -611,16 +612,32 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
 	priv-&gt;shadowLSR = lsr;
 	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
 
+	*tty_flag = TTY_NORMAL;
 	if (lsr &amp; UART_LSR_BRK_ERROR_BITS) {
-		if (lsr &amp; UART_LSR_BI)
+		/* we always want to update icount, but we only want to
+		 * update tty_flag for one case */
+		if (lsr &amp; UART_LSR_BI) {
 			priv-&gt;icount.brk++;
-		if (lsr &amp; UART_LSR_FE)
-			priv-&gt;icount.frame++;
-		if (lsr &amp; UART_LSR_PE)
+			*tty_flag = TTY_BREAK;
+			usb_serial_handle_break(port);
+		}
+		if (lsr &amp; UART_LSR_PE) {
 			priv-&gt;icount.parity++;
-		if (lsr &amp; UART_LSR_OE)
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_PARITY;
+		}
+		if (lsr &amp; UART_LSR_FE) {
+			priv-&gt;icount.frame++;
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_FRAME;
+		}
+		if (lsr &amp; UART_LSR_OE){
 			priv-&gt;icount.overrun++;
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_OVERRUN;
+		}
 	}
+
 }
 
 static int ssu100_process_packet(struct tty_struct *tty,
@@ -629,7 +646,7 @@ static int ssu100_process_packet(struct tty_struct *tty,
 				 char *packet, int len)
 {
 	int i;
-	char flag;
+	char flag = TTY_NORMAL;
 	char *ch;
 
 	dbg("%s - port %d", __func__, port-&gt;number);
@@ -637,8 +654,11 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	if ((len &gt;= 4) &amp;&amp;
 	    (packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
-		if (packet[2] == 0x00)
-			ssu100_update_lsr(port, packet[3]);
+		if (packet[2] == 0x00) {
+			ssu100_update_lsr(port, packet[3], &amp;flag);
+			if (flag == TTY_OVERRUN)
+				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
 		if (packet[2] == 0x01)
 			ssu100_update_msr(port, packet[3]);
 </pre><hr><pre>commit 85dee135b84f1c7cad252fa4a619ea692077a7fc
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:11 2010 -0400

    USB: ssu100: add disconnect function for ssu100
    
    Add a disconnect function to the functions of this device.  The
    disconnect is a call to usb_serial_generic_disconnect() so it requires
    that symbol to be exported from generic.c.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index e244491b1a0d..55e9672d286a 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -687,7 +687,6 @@ static void ssu100_process_read_urb(struct urb *urb)
 	tty_kref_put(tty);
 }
 
-
 static struct usb_serial_driver ssu100_device = {
 	.driver = {
 		.owner = THIS_MODULE,
@@ -709,6 +708,7 @@ static struct usb_serial_driver ssu100_device = {
 	.tiocmset            = ssu100_tiocmset,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,
+	.disconnect          = usb_serial_generic_disconnect,
 };
 
 static int __init ssu100_init(void)</pre><hr><pre>commit 5c7efeb76e7dc5145b467657fa049f3c1bd9cf58
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:10 2010 -0400

    USB: serial: export symbol usb_serial_generic_disconnect
    
    This is needed by the ssu100 driver to use this function.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index ca92f67747cc..0b1a13384c6d 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -518,6 +518,7 @@ void usb_serial_generic_disconnect(struct usb_serial *serial)
 	for (i = 0; i &lt; serial-&gt;num_ports; ++i)
 		generic_cleanup(serial-&gt;port[i]);
 }
+EXPORT_SYMBOL_GPL(usb_serial_generic_disconnect);
 
 void usb_serial_generic_release(struct usb_serial *serial)
 {</pre><hr><pre>commit f81c83db563334d8377b26ad45585261f604605a
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:09 2010 -0400

    USB: ssu100: rework logic for TIOCMIWAIT
    
    Rework the logic for TIOCMIWAIT to use wait_event_interruptible.
    
    This also adds support for TIOCGICOUNT.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index ad5f9ae40687..e244491b1a0d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -80,6 +80,7 @@ struct ssu100_port_private {
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
 	unsigned short max_packet_size;
+	struct async_icount icount;
 };
 
 static void ssu100_release(struct usb_serial *serial)
@@ -330,11 +331,8 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	}
 
 	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
-	priv-&gt;shadowLSR = data[0]  &amp; (UART_LSR_OE | UART_LSR_PE |
-				      UART_LSR_FE | UART_LSR_BI);
-
-	priv-&gt;shadowMSR = data[1]  &amp; (UART_MSR_CTS | UART_MSR_DSR |
-				      UART_MSR_RI | UART_MSR_DCD);
+	priv-&gt;shadowLSR = data[0];
+	priv-&gt;shadowMSR = data[1];
 	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
 
 	kfree(data);
@@ -379,11 +377,51 @@ static int get_serial_info(struct usb_serial_port *port,
 	return 0;
 }
 
+static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	struct async_icount prev, cur;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
+	prev = priv-&gt;icount;
+	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
+
+	while (1) {
+		wait_event_interruptible(priv-&gt;delta_msr_wait,
+					 ((priv-&gt;icount.rng != prev.rng) ||
+					  (priv-&gt;icount.dsr != prev.dsr) ||
+					  (priv-&gt;icount.dcd != prev.dcd) ||
+					  (priv-&gt;icount.cts != prev.cts)));
+
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
+		cur = priv-&gt;icount;
+		spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
+
+		if ((prev.rng == cur.rng) &amp;&amp;
+		    (prev.dsr == cur.dsr) &amp;&amp;
+		    (prev.dcd == cur.dcd) &amp;&amp;
+		    (prev.cts == cur.cts))
+			return -EIO;
+
+		if ((arg &amp; TIOCM_RNG &amp;&amp; (prev.rng != cur.rng)) ||
+		    (arg &amp; TIOCM_DSR &amp;&amp; (prev.dsr != cur.dsr)) ||
+		    (arg &amp; TIOCM_CD  &amp;&amp; (prev.dcd != cur.dcd)) ||
+		    (arg &amp; TIOCM_CTS &amp;&amp; (prev.cts != cur.cts)))
+			return 0;
+	}
+	return 0;
+}
+
 static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 		    unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	void __user *user_arg = (void __user *)arg;
 
 	dbg("%s cmd 0x%04x", __func__, cmd);
 
@@ -393,28 +431,28 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 				       (struct serial_struct __user *) arg);
 
 	case TIOCMIWAIT:
-		while (priv != NULL) {
-			u8 prevMSR = priv-&gt;shadowMSR &amp; SERIAL_MSR_MASK;
-			interruptible_sleep_on(&amp;priv-&gt;delta_msr_wait);
-			/* see if a signal did it */
-			if (signal_pending(current))
-				return -ERESTARTSYS;
-			else {
-				u8 diff = (priv-&gt;shadowMSR &amp; SERIAL_MSR_MASK) ^ prevMSR;
-				if (!diff)
-					return -EIO; /* no change =&gt; error */
-
-				/* Return 0 if caller wanted to know about
-				   these bits */
-
-				if (((arg &amp; TIOCM_RNG) &amp;&amp; (diff &amp; UART_MSR_RI)) ||
-				    ((arg &amp; TIOCM_DSR) &amp;&amp; (diff &amp; UART_MSR_DSR)) ||
-				    ((arg &amp; TIOCM_CD) &amp;&amp; (diff &amp; UART_MSR_DCD)) ||
-				    ((arg &amp; TIOCM_CTS) &amp;&amp; (diff &amp; UART_MSR_CTS)))
-					return 0;
-			}
-		}
+		return wait_modem_info(port, arg);
+
+	case TIOCGICOUNT:
+	{
+		struct serial_icounter_struct icount;
+		struct async_icount cnow = priv-&gt;icount;
+		memset(&amp;icount, 0, sizeof(icount));
+		icount.cts = cnow.cts;
+		icount.dsr = cnow.dsr;
+		icount.rng = cnow.rng;
+		icount.dcd = cnow.dcd;
+		icount.rx = cnow.rx;
+		icount.tx = cnow.tx;
+		icount.frame = cnow.frame;
+		icount.overrun = cnow.overrun;
+		icount.parity = cnow.parity;
+		icount.brk = cnow.brk;
+		icount.buf_overrun = cnow.buf_overrun;
+		if (copy_to_user(user_arg, &amp;icount, sizeof(icount)))
+			return -EFAULT;
 		return 0;
+	}
 
 	default:
 		break;
@@ -541,6 +579,50 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 	mutex_unlock(&amp;port-&gt;serial-&gt;disc_mutex);
 }
 
+static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
+	priv-&gt;shadowMSR = msr;
+	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
+
+	if (msr &amp; UART_MSR_ANY_DELTA) {
+		/* update input line counters */
+		if (msr &amp; UART_MSR_DCTS)
+			priv-&gt;icount.cts++;
+		if (msr &amp; UART_MSR_DDSR)
+			priv-&gt;icount.dsr++;
+		if (msr &amp; UART_MSR_DDCD)
+			priv-&gt;icount.dcd++;
+		if (msr &amp; UART_MSR_TERI)
+			priv-&gt;icount.rng++;
+		wake_up_interruptible(&amp;priv-&gt;delta_msr_wait);
+	}
+}
+
+static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
+	priv-&gt;shadowLSR = lsr;
+	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
+
+	if (lsr &amp; UART_LSR_BRK_ERROR_BITS) {
+		if (lsr &amp; UART_LSR_BI)
+			priv-&gt;icount.brk++;
+		if (lsr &amp; UART_LSR_FE)
+			priv-&gt;icount.frame++;
+		if (lsr &amp; UART_LSR_PE)
+			priv-&gt;icount.parity++;
+		if (lsr &amp; UART_LSR_OE)
+			priv-&gt;icount.overrun++;
+	}
+}
+
 static int ssu100_process_packet(struct tty_struct *tty,
 				 struct usb_serial_port *port,
 				 struct ssu100_port_private *priv,
@@ -556,15 +638,9 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	    (packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
-			priv-&gt;shadowLSR = packet[3] &amp; (UART_LSR_OE |
-						       UART_LSR_PE |
-						       UART_LSR_FE |
-						       UART_LSR_BI);
-
-		if (packet[2] == 0x01) {
-			priv-&gt;shadowMSR = packet[3];
-			wake_up_interruptible(&amp;priv-&gt;delta_msr_wait);
-		}
+			ssu100_update_lsr(port, packet[3]);
+		if (packet[2] == 0x01)
+			ssu100_update_msr(port, packet[3]);
 
 		len -= 4;
 		ch = packet + 4;</pre><hr><pre>commit 556f1a0e9c178193e584209b47cf1cb9f669bd51
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:08 2010 -0400

    USB: ssu100: add register parameter to ssu100_setregister
    
    The function ssu100_setregister was hard coded to only set the MCR
    register.  Add a register parameter so that other registers can be
    set.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 3c586b5790e1..ad5f9ae40687 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -127,9 +127,10 @@ static inline int ssu100_getregister(struct usb_device *dev,
 
 static inline int ssu100_setregister(struct usb_device *dev,
 				     unsigned short uart,
+				     unsigned short reg,
 				     u16 data)
 {
-	u16 value = (data &lt;&lt; 8) | UART_MCR;
+	u16 value = (data &lt;&lt; 8) | reg;
 
 	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			       QT_SET_GET_REGISTER, 0x40, value, uart,
@@ -159,7 +160,7 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 	if (set &amp; TIOCM_RTS)
 		urb_value |= UART_MCR_RTS;
 
-	result = ssu100_setregister(dev, 0, urb_value);
+	result = ssu100_setregister(dev, 0, UART_MCR, urb_value);
 	if (result &lt; 0)
 		dbg("%s Error from MODEM_CTRL urb", __func__);
 
@@ -529,7 +530,7 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 	if (!port-&gt;serial-&gt;disconnected) {
 		/* Disable flow control */
 		if (!on &amp;&amp;
-		    ssu100_setregister(dev, 0, 0) &lt; 0)
+		    ssu100_setregister(dev, 0, UART_MCR, 0) &lt; 0)
 			dev_err(&amp;port-&gt;dev, "error from flowcontrol urb\n");
 		/* drop RTS and DTR */
 		if (on)</pre><hr><pre>commit 79f203a26a07a9d5701c404925e85eb161b72cde
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:07 2010 -0400

    USB: ssu100: remove duplicate #defines in ssu100
    
    The ssu100 uses a TI16C550C UART so the SERIAL_ defines in this code
    are duplicates of those found in serial_reg.h.  Remove the defines in
    ssu100.c and use the ones in the header file.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index c7193880a2b6..3c586b5790e1 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -15,6 +15,7 @@
 #include &lt;linux/serial.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/serial.h&gt;
+#include &lt;linux/serial_reg.h&gt;
 #include &lt;linux/uaccess.h&gt;
 
 #define QT_OPEN_CLOSE_CHANNEL       0xca
@@ -27,36 +28,11 @@
 #define QT_HW_FLOW_CONTROL_MASK     0xc5
 #define QT_SW_FLOW_CONTROL_MASK     0xc6
 
-#define MODEM_CTL_REGISTER         0x04
-#define MODEM_STATUS_REGISTER      0x06
-
-
-#define SERIAL_LSR_OE       0x02
-#define SERIAL_LSR_PE       0x04
-#define SERIAL_LSR_FE       0x08
-#define SERIAL_LSR_BI       0x10
-
-#define SERIAL_LSR_TEMT     0x40
-
-#define  SERIAL_MCR_DTR             0x01
-#define  SERIAL_MCR_RTS             0x02
-#define  SERIAL_MCR_LOOP            0x10
-
-#define  SERIAL_MSR_CTS             0x10
-#define  SERIAL_MSR_CD              0x80
-#define  SERIAL_MSR_RI              0x40
-#define  SERIAL_MSR_DSR             0x20
 #define  SERIAL_MSR_MASK            0xf0
 
-#define  SERIAL_CRTSCTS ((SERIAL_MCR_RTS &lt;&lt; 8) | SERIAL_MSR_CTS)
-
-#define  SERIAL_8_DATA              0x03
-#define  SERIAL_7_DATA              0x02
-#define  SERIAL_6_DATA              0x01
-#define  SERIAL_5_DATA              0x00
+#define  SERIAL_CRTSCTS ((UART_MCR_RTS &lt;&lt; 8) | UART_MSR_CTS)
 
-#define  SERIAL_ODD_PARITY          0X08
-#define  SERIAL_EVEN_PARITY         0X18
+#define  SERIAL_EVEN_PARITY         (UART_LCR_PARITY | UART_LCR_EPAR)
 
 #define  MAX_BAUD_RATE              460800
 
@@ -153,7 +129,7 @@ static inline int ssu100_setregister(struct usb_device *dev,
 				     unsigned short uart,
 				     u16 data)
 {
-	u16 value = (data &lt;&lt; 8) | MODEM_CTL_REGISTER;
+	u16 value = (data &lt;&lt; 8) | UART_MCR;
 
 	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			       QT_SET_GET_REGISTER, 0x40, value, uart,
@@ -179,9 +155,9 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 	clear &amp;= ~set;	/* 'set' takes precedence over 'clear' */
 	urb_value = 0;
 	if (set &amp; TIOCM_DTR)
-		urb_value |= SERIAL_MCR_DTR;
+		urb_value |= UART_MCR_DTR;
 	if (set &amp; TIOCM_RTS)
-		urb_value |= SERIAL_MCR_RTS;
+		urb_value |= UART_MCR_RTS;
 
 	result = ssu100_setregister(dev, 0, urb_value);
 	if (result &lt; 0)
@@ -265,24 +241,24 @@ static void ssu100_set_termios(struct tty_struct *tty,
 
 	if (cflag &amp; PARENB) {
 		if (cflag &amp; PARODD)
-			urb_value |= SERIAL_ODD_PARITY;
+			urb_value |= UART_LCR_PARITY;
 		else
 			urb_value |= SERIAL_EVEN_PARITY;
 	}
 
 	switch (cflag &amp; CSIZE) {
 	case CS5:
-		urb_value |= SERIAL_5_DATA;
+		urb_value |= UART_LCR_WLEN5;
 		break;
 	case CS6:
-		urb_value |= SERIAL_6_DATA;
+		urb_value |= UART_LCR_WLEN6;
 		break;
 	case CS7:
-		urb_value |= SERIAL_7_DATA;
+		urb_value |= UART_LCR_WLEN7;
 		break;
 	default:
 	case CS8:
-		urb_value |= SERIAL_8_DATA;
+		urb_value |= UART_LCR_WLEN8;
 		break;
 	}
 
@@ -353,11 +329,11 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	}
 
 	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
-	priv-&gt;shadowLSR = data[0]  &amp; (SERIAL_LSR_OE | SERIAL_LSR_PE |
-				      SERIAL_LSR_FE | SERIAL_LSR_BI);
+	priv-&gt;shadowLSR = data[0]  &amp; (UART_LSR_OE | UART_LSR_PE |
+				      UART_LSR_FE | UART_LSR_BI);
 
-	priv-&gt;shadowMSR = data[1]  &amp; (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
-				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+	priv-&gt;shadowMSR = data[1]  &amp; (UART_MSR_CTS | UART_MSR_DSR |
+				      UART_MSR_RI | UART_MSR_DCD);
 	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
 
 	kfree(data);
@@ -430,10 +406,10 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 				/* Return 0 if caller wanted to know about
 				   these bits */
 
-				if (((arg &amp; TIOCM_RNG) &amp;&amp; (diff &amp; SERIAL_MSR_RI)) ||
-				    ((arg &amp; TIOCM_DSR) &amp;&amp; (diff &amp; SERIAL_MSR_DSR)) ||
-				    ((arg &amp; TIOCM_CD) &amp;&amp; (diff &amp; SERIAL_MSR_CD)) ||
-				    ((arg &amp; TIOCM_CTS) &amp;&amp; (diff &amp; SERIAL_MSR_CTS)))
+				if (((arg &amp; TIOCM_RNG) &amp;&amp; (diff &amp; UART_MSR_RI)) ||
+				    ((arg &amp; TIOCM_DSR) &amp;&amp; (diff &amp; UART_MSR_DSR)) ||
+				    ((arg &amp; TIOCM_CD) &amp;&amp; (diff &amp; UART_MSR_DCD)) ||
+				    ((arg &amp; TIOCM_CTS) &amp;&amp; (diff &amp; UART_MSR_CTS)))
 					return 0;
 			}
 		}
@@ -513,20 +489,20 @@ static int ssu100_tiocmget(struct tty_struct *tty, struct file *file)
 	if (!d)
 		return -ENOMEM;
 
-	r = ssu100_getregister(dev, 0, MODEM_CTL_REGISTER, d);
+	r = ssu100_getregister(dev, 0, UART_MCR, d);
 	if (r &lt; 0)
 		goto mget_out;
 
-	r = ssu100_getregister(dev, 0, MODEM_STATUS_REGISTER, d+1);
+	r = ssu100_getregister(dev, 0, UART_MSR, d+1);
 	if (r &lt; 0)
 		goto mget_out;
 
-	r = (d[0] &amp; SERIAL_MCR_DTR ? TIOCM_DTR : 0) |
-		(d[0] &amp; SERIAL_MCR_RTS ? TIOCM_RTS : 0) |
-		(d[1] &amp; SERIAL_MSR_CTS ? TIOCM_CTS : 0) |
-		(d[1] &amp; SERIAL_MSR_CD ? TIOCM_CAR : 0) |
-		(d[1] &amp; SERIAL_MSR_RI ? TIOCM_RI : 0) |
-		(d[1] &amp; SERIAL_MSR_DSR ? TIOCM_DSR : 0);
+	r = (d[0] &amp; UART_MCR_DTR ? TIOCM_DTR : 0) |
+		(d[0] &amp; UART_MCR_RTS ? TIOCM_RTS : 0) |
+		(d[1] &amp; UART_MSR_CTS ? TIOCM_CTS : 0) |
+		(d[1] &amp; UART_MSR_DCD ? TIOCM_CAR : 0) |
+		(d[1] &amp; UART_MSR_RI ? TIOCM_RI : 0) |
+		(d[1] &amp; UART_MSR_DSR ? TIOCM_DSR : 0);
 
 mget_out:
 	kfree(d);
@@ -579,10 +555,10 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	    (packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
-			priv-&gt;shadowLSR = packet[3] &amp; (SERIAL_LSR_OE |
-						       SERIAL_LSR_PE |
-						       SERIAL_LSR_FE |
-						       SERIAL_LSR_BI);
+			priv-&gt;shadowLSR = packet[3] &amp; (UART_LSR_OE |
+						       UART_LSR_PE |
+						       UART_LSR_FE |
+						       UART_LSR_BI);
 
 		if (packet[2] == 0x01) {
 			priv-&gt;shadowMSR = packet[3];</pre><hr><pre>commit 9b2cef31f2823558eb92a35624d37439599f3f9f
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:06 2010 -0400

    USB: ssu100: refine process_packet in ssu100
    
    The status information does not appear at the start of each incoming
    packet so the check for len &lt; 4 at the start of ssu100_process_packet
    is wrong.  Remove it.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 2826f013752d..c7193880a2b6 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -575,12 +575,8 @@ static int ssu100_process_packet(struct tty_struct *tty,
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
-	if (len &lt; 4) {
-		dbg("%s - malformed packet", __func__);
-		return 0;
-	}
-
-	if ((packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
+	if ((len &gt;= 4) &amp;&amp;
+	    (packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
 			priv-&gt;shadowLSR = packet[3] &amp; (SERIAL_LSR_OE |</pre><hr><pre>commit 175230587bcca6dee0a1d6832a8a2138e32ab6ab
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 5 17:01:05 2010 -0400

    USB: ssu100: add locking for port private data in ssu100
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 6e82d4f54bc8..2826f013752d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -99,6 +99,7 @@ static struct usb_driver ssu100_driver = {
 };
 
 struct ssu100_port_private {
+	spinlock_t status_lock;
 	u8 shadowLSR;
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
@@ -333,6 +334,7 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
 	u8 *data;
 	int result;
+	unsigned long flags;
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
@@ -350,11 +352,13 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 		return result;
 	}
 
+	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
 	priv-&gt;shadowLSR = data[0]  &amp; (SERIAL_LSR_OE | SERIAL_LSR_PE |
 				      SERIAL_LSR_FE | SERIAL_LSR_BI);
 
 	priv-&gt;shadowMSR = data[1]  &amp; (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
 				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
 
 	kfree(data);
 
@@ -455,6 +459,7 @@ static void ssu100_set_max_packet_size(struct usb_serial_port *port)
 
 	unsigned num_endpoints;
 	int i;
+	unsigned long flags;
 
 	num_endpoints = interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints;
 	dev_info(&amp;udev-&gt;dev, "Number of endpoints %d\n", num_endpoints);
@@ -466,7 +471,9 @@ static void ssu100_set_max_packet_size(struct usb_serial_port *port)
 	}
 
 	/* set max packet size based on descriptor */
+	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
 	priv-&gt;max_packet_size = ep_desc-&gt;wMaxPacketSize;
+	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
 
 	dev_info(&amp;udev-&gt;dev, "Setting MaxPacketSize %d\n", priv-&gt;max_packet_size);
 }
@@ -485,9 +492,9 @@ static int ssu100_attach(struct usb_serial *serial)
 		return -ENOMEM;
 	}
 
+	spin_lock_init(&amp;priv-&gt;status_lock);
 	init_waitqueue_head(&amp;priv-&gt;delta_msr_wait);
 	usb_set_serial_port_data(port, priv);
-
 	ssu100_set_max_packet_size(port);
 
 	return ssu100_initdevice(serial-&gt;dev);</pre><hr><pre>commit 52af954599396e5945a895035525c703f2761b20
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Jul 29 11:05:41 2010 -0400

    USB: add USB serial ssu100 driver
    
    Add support for the Quatech SSU-100 single port usb to serial device.
    This driver is based on the ftdi_sio.c driver and the original
    serqt_usb driver from Quatech.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index bd8aab0ef1cf..916b2b6d765f 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -642,6 +642,15 @@ config USB_SERIAL_ZIO
 	  To compile this driver as a module, choose M here: the
 	  module will be called zio.
 
+config USB_SERIAL_SSU100
+	tristate "USB Quatech SSU-100 Single Port Serial Driver"
+	help
+	  Say Y here if you want to use the Quatech SSU-100 single
+	  port usb to serial adapter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ssu100.
+
 config USB_SERIAL_DEBUG
 	tristate "USB Debugging Device"
 	help
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index e54c728c016e..40ebe17b6ea8 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_USB_SERIAL_SAFE)			+= safe_serial.o
 obj-$(CONFIG_USB_SERIAL_SIEMENS_MPI)		+= siemens_mpi.o
 obj-$(CONFIG_USB_SERIAL_SIERRAWIRELESS)		+= sierra.o
 obj-$(CONFIG_USB_SERIAL_SPCP8X5)		+= spcp8x5.o
+obj-$(CONFIG_USB_SERIAL_SSU100)			+= ssu100.o
 obj-$(CONFIG_USB_SERIAL_SYMBOL)			+= symbolserial.o
 obj-$(CONFIG_USB_SERIAL_WWAN)			+= usb_wwan.o
 obj-$(CONFIG_USB_SERIAL_TI)			+= ti_usb_3410_5052.o
diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
new file mode 100644
index 000000000000..6e82d4f54bc8
--- /dev/null
+++ b/drivers/usb/serial/ssu100.c
@@ -0,0 +1,698 @@
+/*
+ * usb-serial driver for Quatech SSU-100
+ *
+ * based on ftdi_sio.c and the original serqt_usb.c from Quatech
+ *
+ */
+
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/tty.h&gt;
+#include &lt;linux/tty_driver.h&gt;
+#include &lt;linux/tty_flip.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/serial.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/serial.h&gt;
+#include &lt;linux/uaccess.h&gt;
+
+#define QT_OPEN_CLOSE_CHANNEL       0xca
+#define QT_SET_GET_DEVICE           0xc2
+#define QT_SET_GET_REGISTER         0xc0
+#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc
+#define QT_SET_ATF                  0xcd
+#define QT_GET_SET_UART             0xc1
+#define QT_TRANSFER_IN              0xc0
+#define QT_HW_FLOW_CONTROL_MASK     0xc5
+#define QT_SW_FLOW_CONTROL_MASK     0xc6
+
+#define MODEM_CTL_REGISTER         0x04
+#define MODEM_STATUS_REGISTER      0x06
+
+
+#define SERIAL_LSR_OE       0x02
+#define SERIAL_LSR_PE       0x04
+#define SERIAL_LSR_FE       0x08
+#define SERIAL_LSR_BI       0x10
+
+#define SERIAL_LSR_TEMT     0x40
+
+#define  SERIAL_MCR_DTR             0x01
+#define  SERIAL_MCR_RTS             0x02
+#define  SERIAL_MCR_LOOP            0x10
+
+#define  SERIAL_MSR_CTS             0x10
+#define  SERIAL_MSR_CD              0x80
+#define  SERIAL_MSR_RI              0x40
+#define  SERIAL_MSR_DSR             0x20
+#define  SERIAL_MSR_MASK            0xf0
+
+#define  SERIAL_CRTSCTS ((SERIAL_MCR_RTS &lt;&lt; 8) | SERIAL_MSR_CTS)
+
+#define  SERIAL_8_DATA              0x03
+#define  SERIAL_7_DATA              0x02
+#define  SERIAL_6_DATA              0x01
+#define  SERIAL_5_DATA              0x00
+
+#define  SERIAL_ODD_PARITY          0X08
+#define  SERIAL_EVEN_PARITY         0X18
+
+#define  MAX_BAUD_RATE              460800
+
+#define ATC_DISABLED                0x00
+#define DUPMODE_BITS        0xc0
+#define RR_BITS             0x03
+#define LOOPMODE_BITS       0x41
+#define RS232_MODE          0x00
+#define RTSCTS_TO_CONNECTOR 0x40
+#define CLKS_X4             0x02
+#define FULLPWRBIT          0x00000080
+#define NEXT_BOARD_POWER_BIT        0x00000004
+
+static int debug = 1;
+
+/* Version Information */
+#define DRIVER_VERSION "v0.1"
+#define DRIVER_DESC "Quatech SSU-100 USB to Serial Driver"
+
+#define	USB_VENDOR_ID_QUATECH	0x061d	/* Quatech VID */
+#define QUATECH_SSU100	0xC020	/* SSU100 */
+
+static const struct usb_device_id id_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, id_table);
+
+
+static struct usb_driver ssu100_driver = {
+	.name			       = "ssu100",
+	.probe			       = usb_serial_probe,
+	.disconnect		       = usb_serial_disconnect,
+	.id_table		       = id_table,
+	.suspend		       = usb_serial_suspend,
+	.resume			       = usb_serial_resume,
+	.no_dynamic_id		       = 1,
+	.supports_autosuspend	       = 1,
+};
+
+struct ssu100_port_private {
+	u8 shadowLSR;
+	u8 shadowMSR;
+	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
+	unsigned short max_packet_size;
+};
+
+static void ssu100_release(struct usb_serial *serial)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(*serial-&gt;port);
+
+	dbg("%s", __func__);
+	kfree(priv);
+}
+
+static inline int ssu100_control_msg(struct usb_device *dev,
+				     u8 request, u16 data, u16 index)
+{
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       request, 0x40, data, index,
+			       NULL, 0, 300);
+}
+
+static inline int ssu100_setdevice(struct usb_device *dev, u8 *data)
+{
+	u16 x = ((u16)(data[1] &lt;&lt; 8) | (u16)(data[0]));
+
+	return ssu100_control_msg(dev, QT_SET_GET_DEVICE, x, 0);
+}
+
+
+static inline int ssu100_getdevice(struct usb_device *dev, u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_DEVICE, 0xc0, 0, 0,
+			       data, 3, 300);
+}
+
+static inline int ssu100_getregister(struct usb_device *dev,
+				     unsigned short uart,
+				     unsigned short reg,
+				     u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0xc0, reg,
+			       uart, data, sizeof(*data), 300);
+
+}
+
+
+static inline int ssu100_setregister(struct usb_device *dev,
+				     unsigned short uart,
+				     u16 data)
+{
+	u16 value = (data &lt;&lt; 8) | MODEM_CTL_REGISTER;
+
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0x40, value, uart,
+			       NULL, 0, 300);
+
+}
+
+#define set_mctrl(dev, set)		update_mctrl((dev), (set), 0)
+#define clear_mctrl(dev, clear)	update_mctrl((dev), 0, (clear))
+
+/* these do not deal with device that have more than 1 port */
+static inline int update_mctrl(struct usb_device *dev, unsigned int set,
+			       unsigned int clear)
+{
+	unsigned urb_value;
+	int result;
+
+	if (((set | clear) &amp; (TIOCM_DTR | TIOCM_RTS)) == 0) {
+		dbg("%s - DTR|RTS not being set|cleared", __func__);
+		return 0;	/* no change */
+	}
+
+	clear &amp;= ~set;	/* 'set' takes precedence over 'clear' */
+	urb_value = 0;
+	if (set &amp; TIOCM_DTR)
+		urb_value |= SERIAL_MCR_DTR;
+	if (set &amp; TIOCM_RTS)
+		urb_value |= SERIAL_MCR_RTS;
+
+	result = ssu100_setregister(dev, 0, urb_value);
+	if (result &lt; 0)
+		dbg("%s Error from MODEM_CTRL urb", __func__);
+
+	return result;
+}
+
+static int ssu100_initdevice(struct usb_device *dev)
+{
+	u8 *data;
+	int result = 0;
+
+	dbg("%s", __func__);
+
+	data = kzalloc(3, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	result = ssu100_getdevice(dev, data);
+	if (result &lt; 0) {
+		dbg("%s - get_device failed %i", __func__, result);
+		goto out;
+	}
+
+	data[1] &amp;= ~FULLPWRBIT;
+
+	result = ssu100_setdevice(dev, data);
+	if (result &lt; 0) {
+		dbg("%s - setdevice failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);
+	if (result &lt; 0) {
+		dbg("%s - set prebuffer level failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);
+	if (result &lt; 0) {
+		dbg("%s - set ATFprebuffer level failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_getdevice(dev, data);
+	if (result &lt; 0) {
+		dbg("%s - get_device failed %i", __func__, result);
+		goto out;
+	}
+
+	data[0] &amp;= ~(RR_BITS | DUPMODE_BITS);
+	data[0] |= CLKS_X4;
+	data[1] &amp;= ~(LOOPMODE_BITS);
+	data[1] |= RS232_MODE;
+
+	result = ssu100_setdevice(dev, data);
+	if (result &lt; 0) {
+		dbg("%s - setdevice failed %i", __func__, result);
+		goto out;
+	}
+
+out:	kfree(data);
+	return result;
+
+}
+
+
+static void ssu100_set_termios(struct tty_struct *tty,
+			       struct usb_serial_port *port,
+			       struct ktermios *old_termios)
+{
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	struct ktermios *termios = tty-&gt;termios;
+	u16 baud, divisor, remainder;
+	unsigned int cflag = termios-&gt;c_cflag;
+	u16 urb_value = 0; /* will hold the new flags */
+	int result;
+
+	dbg("%s", __func__);
+
+	if (cflag &amp; PARENB) {
+		if (cflag &amp; PARODD)
+			urb_value |= SERIAL_ODD_PARITY;
+		else
+			urb_value |= SERIAL_EVEN_PARITY;
+	}
+
+	switch (cflag &amp; CSIZE) {
+	case CS5:
+		urb_value |= SERIAL_5_DATA;
+		break;
+	case CS6:
+		urb_value |= SERIAL_6_DATA;
+		break;
+	case CS7:
+		urb_value |= SERIAL_7_DATA;
+		break;
+	default:
+	case CS8:
+		urb_value |= SERIAL_8_DATA;
+		break;
+	}
+
+	baud = tty_get_baud_rate(tty);
+	if (!baud)
+		baud = 9600;
+
+	dbg("%s - got baud = %d\n", __func__, baud);
+
+
+	divisor = MAX_BAUD_RATE / baud;
+	remainder = MAX_BAUD_RATE % baud;
+	if (((remainder * 2) &gt;= baud) &amp;&amp; (baud != 110))
+		divisor++;
+
+	urb_value = urb_value &lt;&lt; 8;
+
+	result = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);
+	if (result &lt; 0)
+		dbg("%s - set uart failed", __func__);
+
+	if (cflag &amp; CRTSCTS)
+		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					    SERIAL_CRTSCTS, 0);
+	else
+		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					    0, 0);
+	if (result &lt; 0)
+		dbg("%s - set HW flow control failed", __func__);
+
+	if (I_IXOFF(tty) || I_IXON(tty)) {
+		u16 x = ((u16)(START_CHAR(tty) &lt;&lt; 8) | (u16)(STOP_CHAR(tty)));
+
+		result = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					    x, 0);
+	} else
+		result = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					    0, 0);
+
+	if (result &lt; 0)
+		dbg("%s - set SW flow control failed", __func__);
+
+}
+
+
+static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
+{
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	u8 *data;
+	int result;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
+	data = kzalloc(2, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+				 QT_OPEN_CLOSE_CHANNEL,
+				 QT_TRANSFER_IN, 0x01,
+				 0, data, 2, 300);
+	if (result &lt; 0) {
+		dbg("%s - open failed %i", __func__, result);
+		kfree(data);
+		return result;
+	}
+
+	priv-&gt;shadowLSR = data[0]  &amp; (SERIAL_LSR_OE | SERIAL_LSR_PE |
+				      SERIAL_LSR_FE | SERIAL_LSR_BI);
+
+	priv-&gt;shadowMSR = data[1]  &amp; (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
+				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+
+	kfree(data);
+
+/* set to 9600 */
+	result = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);
+	if (result &lt; 0)
+		dbg("%s - set uart failed", __func__);
+
+	if (tty)
+		ssu100_set_termios(tty, port, tty-&gt;termios);
+
+	return usb_serial_generic_open(tty, port);
+}
+
+static void ssu100_close(struct usb_serial_port *port)
+{
+	dbg("%s", __func__);
+	usb_serial_generic_close(port);
+}
+
+static int get_serial_info(struct usb_serial_port *port,
+			   struct serial_struct __user *retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+
+	memset(&amp;tmp, 0, sizeof(tmp));
+	tmp.line		= port-&gt;serial-&gt;minor;
+	tmp.port		= 0;
+	tmp.irq			= 0;
+	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
+	tmp.xmit_fifo_size	= port-&gt;bulk_out_size;
+	tmp.baud_base		= 9600;
+	tmp.close_delay		= 5*HZ;
+	tmp.closing_wait	= 30*HZ;
+
+	if (copy_to_user(retinfo, &amp;tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+
+	dbg("%s cmd 0x%04x", __func__, cmd);
+
+	switch (cmd) {
+	case TIOCGSERIAL:
+		return get_serial_info(port,
+				       (struct serial_struct __user *) arg);
+
+	case TIOCMIWAIT:
+		while (priv != NULL) {
+			u8 prevMSR = priv-&gt;shadowMSR &amp; SERIAL_MSR_MASK;
+			interruptible_sleep_on(&amp;priv-&gt;delta_msr_wait);
+			/* see if a signal did it */
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+			else {
+				u8 diff = (priv-&gt;shadowMSR &amp; SERIAL_MSR_MASK) ^ prevMSR;
+				if (!diff)
+					return -EIO; /* no change =&gt; error */
+
+				/* Return 0 if caller wanted to know about
+				   these bits */
+
+				if (((arg &amp; TIOCM_RNG) &amp;&amp; (diff &amp; SERIAL_MSR_RI)) ||
+				    ((arg &amp; TIOCM_DSR) &amp;&amp; (diff &amp; SERIAL_MSR_DSR)) ||
+				    ((arg &amp; TIOCM_CD) &amp;&amp; (diff &amp; SERIAL_MSR_CD)) ||
+				    ((arg &amp; TIOCM_CTS) &amp;&amp; (diff &amp; SERIAL_MSR_CTS)))
+					return 0;
+			}
+		}
+		return 0;
+
+	default:
+		break;
+	}
+
+	dbg("%s arg not supported", __func__);
+
+	return -ENOIOCTLCMD;
+}
+
+static void ssu100_set_max_packet_size(struct usb_serial_port *port)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	struct usb_serial *serial = port-&gt;serial;
+	struct usb_device *udev = serial-&gt;dev;
+
+	struct usb_interface *interface = serial-&gt;interface;
+	struct usb_endpoint_descriptor *ep_desc = &amp;interface-&gt;cur_altsetting-&gt;endpoint[1].desc;
+
+	unsigned num_endpoints;
+	int i;
+
+	num_endpoints = interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints;
+	dev_info(&amp;udev-&gt;dev, "Number of endpoints %d\n", num_endpoints);
+
+	for (i = 0; i &lt; num_endpoints; i++) {
+		dev_info(&amp;udev-&gt;dev, "Endpoint %d MaxPacketSize %d\n", i+1,
+			interface-&gt;cur_altsetting-&gt;endpoint[i].desc.wMaxPacketSize);
+		ep_desc = &amp;interface-&gt;cur_altsetting-&gt;endpoint[i].desc;
+	}
+
+	/* set max packet size based on descriptor */
+	priv-&gt;max_packet_size = ep_desc-&gt;wMaxPacketSize;
+
+	dev_info(&amp;udev-&gt;dev, "Setting MaxPacketSize %d\n", priv-&gt;max_packet_size);
+}
+
+static int ssu100_attach(struct usb_serial *serial)
+{
+	struct ssu100_port_private *priv;
+	struct usb_serial_port *port = *serial-&gt;port;
+
+	dbg("%s", __func__);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&amp;port-&gt;dev, "%s- kmalloc(%Zd) failed.\n", __func__,
+			sizeof(*priv));
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&amp;priv-&gt;delta_msr_wait);
+	usb_set_serial_port_data(port, priv);
+
+	ssu100_set_max_packet_size(port);
+
+	return ssu100_initdevice(serial-&gt;dev);
+}
+
+static int ssu100_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	u8 *d;
+	int r;
+
+	dbg("%s\n", __func__);
+
+	d = kzalloc(2, GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	r = ssu100_getregister(dev, 0, MODEM_CTL_REGISTER, d);
+	if (r &lt; 0)
+		goto mget_out;
+
+	r = ssu100_getregister(dev, 0, MODEM_STATUS_REGISTER, d+1);
+	if (r &lt; 0)
+		goto mget_out;
+
+	r = (d[0] &amp; SERIAL_MCR_DTR ? TIOCM_DTR : 0) |
+		(d[0] &amp; SERIAL_MCR_RTS ? TIOCM_RTS : 0) |
+		(d[1] &amp; SERIAL_MSR_CTS ? TIOCM_CTS : 0) |
+		(d[1] &amp; SERIAL_MSR_CD ? TIOCM_CAR : 0) |
+		(d[1] &amp; SERIAL_MSR_RI ? TIOCM_RI : 0) |
+		(d[1] &amp; SERIAL_MSR_DSR ? TIOCM_DSR : 0);
+
+mget_out:
+	kfree(d);
+	return r;
+}
+
+static int ssu100_tiocmset(struct tty_struct *tty, struct file *file,
+			   unsigned int set, unsigned int clear)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+
+	dbg("%s\n", __func__);
+	return update_mctrl(dev, set, clear);
+}
+
+static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
+{
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+
+	dbg("%s\n", __func__);
+
+	mutex_lock(&amp;port-&gt;serial-&gt;disc_mutex);
+	if (!port-&gt;serial-&gt;disconnected) {
+		/* Disable flow control */
+		if (!on &amp;&amp;
+		    ssu100_setregister(dev, 0, 0) &lt; 0)
+			dev_err(&amp;port-&gt;dev, "error from flowcontrol urb\n");
+		/* drop RTS and DTR */
+		if (on)
+			set_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
+		else
+			clear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
+	}
+	mutex_unlock(&amp;port-&gt;serial-&gt;disc_mutex);
+}
+
+static int ssu100_process_packet(struct tty_struct *tty,
+				 struct usb_serial_port *port,
+				 struct ssu100_port_private *priv,
+				 char *packet, int len)
+{
+	int i;
+	char flag;
+	char *ch;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
+	if (len &lt; 4) {
+		dbg("%s - malformed packet", __func__);
+		return 0;
+	}
+
+	if ((packet[0] == 0x1b) &amp;&amp; (packet[1] == 0x1b) &amp;&amp;
+	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
+		if (packet[2] == 0x00)
+			priv-&gt;shadowLSR = packet[3] &amp; (SERIAL_LSR_OE |
+						       SERIAL_LSR_PE |
+						       SERIAL_LSR_FE |
+						       SERIAL_LSR_BI);
+
+		if (packet[2] == 0x01) {
+			priv-&gt;shadowMSR = packet[3];
+			wake_up_interruptible(&amp;priv-&gt;delta_msr_wait);
+		}
+
+		len -= 4;
+		ch = packet + 4;
+	} else
+		ch = packet;
+
+	if (!len)
+		return 0;	/* status only */
+
+	if (port-&gt;port.console &amp;&amp; port-&gt;sysrq) {
+		for (i = 0; i &lt; len; i++, ch++) {
+			if (!usb_serial_handle_sysrq_char(tty, port, *ch))
+				tty_insert_flip_char(tty, *ch, flag);
+		}
+	} else
+		tty_insert_flip_string_fixed_flag(tty, ch, flag, len);
+
+	return len;
+}
+
+static void ssu100_process_read_urb(struct urb *urb)
+{
+	struct usb_serial_port *port = urb-&gt;context;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	char *data = (char *)urb-&gt;transfer_buffer;
+	struct tty_struct *tty;
+	int count = 0;
+	int i;
+	int len;
+
+	dbg("%s", __func__);
+
+	tty = tty_port_tty_get(&amp;port-&gt;port);
+	if (!tty)
+		return;
+
+	for (i = 0; i &lt; urb-&gt;actual_length; i += priv-&gt;max_packet_size) {
+		len = min_t(int, urb-&gt;actual_length - i, priv-&gt;max_packet_size);
+		count += ssu100_process_packet(tty, port, priv, &amp;data[i], len);
+	}
+
+	if (count)
+		tty_flip_buffer_push(tty);
+	tty_kref_put(tty);
+}
+
+
+static struct usb_serial_driver ssu100_device = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "ssu100",
+	},
+	.description	     = DRIVER_DESC,
+	.id_table	     = id_table,
+	.usb_driver	     = &amp;ssu100_driver,
+	.num_ports	     = 1,
+	.bulk_in_size        = 256,
+	.bulk_out_size       = 256,
+	.open		     = ssu100_open,
+	.close		     = ssu100_close,
+	.attach              = ssu100_attach,
+	.release             = ssu100_release,
+	.dtr_rts             = ssu100_dtr_rts,
+	.process_read_urb    = ssu100_process_read_urb,
+	.tiocmget            = ssu100_tiocmget,
+	.tiocmset            = ssu100_tiocmset,
+	.ioctl               = ssu100_ioctl,
+	.set_termios         = ssu100_set_termios,
+};
+
+static int __init ssu100_init(void)
+{
+	int retval;
+
+	dbg("%s", __func__);
+
+	/* register with usb-serial */
+	retval = usb_serial_register(&amp;ssu100_device);
+
+	if (retval)
+		goto failed_usb_sio_register;
+
+	retval = usb_register(&amp;ssu100_driver);
+	if (retval)
+		goto failed_usb_register;
+
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
+
+	return 0;
+
+failed_usb_register:
+	usb_serial_deregister(&amp;ssu100_device);
+failed_usb_sio_register:
+	return retval;
+}
+
+static void __exit ssu100_exit(void)
+{
+	usb_deregister(&amp;ssu100_driver);
+	usb_serial_deregister(&amp;ssu100_device);
+}
+
+module_init(ssu100_init);
+module_exit(ssu100_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");</pre><hr><pre>commit ffc18879903e55487bc5ac3c774b99a07de06029
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Aug 3 15:19:30 2010 -0400

    omfs: fix uninitialized variable warning
    
    quiet the warning:
    fs/omfs/file.c: In function 'omfs_get_block':
    fs/omfs/file.c:225: warning: 'new_block' may be used uninitialized in
    this function
    
    new_block is used properly by the call to omfs_grow_extent()
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Bob Copeland &lt;me@bobcopeland.com&gt;

diff --git a/fs/omfs/file.c b/fs/omfs/file.c
index 76bc21b91a8a..d821d468e5a2 100644
--- a/fs/omfs/file.c
+++ b/fs/omfs/file.c
@@ -222,7 +222,7 @@ static int omfs_get_block(struct inode *inode, sector_t block,
 	struct buffer_head *bh;
 	sector_t next, offset;
 	int ret;
-	u64 new_block;
+	u64 uninitialized_var(new_block);
 	u32 max_extents;
 	int extent_count;
 	struct omfs_extent *oe;</pre>
    <div class="pagination">
        <a href='3_40.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><span>[41]</span><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_42.html'>Next&gt;&gt;</a>
    <div>
</body>
