<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_37.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><span>[38]</span><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_39.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7bc782d73c7db042ecc965866b8c1c2b7d6e93d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:31:11 2013 -0400

    USB: EHCI: split needs_rescan into two flags
    
    This patch (as1662) does some more QH-related cleanup in ehci-hcd.
    The qh-&gt;needs_rescan flag is currently used for two different
    purposes; the patch replaces it with two separate flags for greater
    clarity: qh-&gt;dequeue_during_giveback indicates that a completion
    handler dequeued an URB (implying that a rescan is needed), and
    qh-&gt;exception indicates that the QH is in an exceptional state
    requiring an unlink (either it encountered an I/O error or an unlink
    was requested).
    
    The new flags get set where the dequeue, exception, or unlink request
    occurred, rather than where the unlink is started.  This is so that in
    the future, if we need to, we will be able to tell apart unlinks that
    truly were required from those that were carried out merely because
    the QH wasn't being used.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 0c3314c41363..93f4cd75845e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,11 +903,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
 		if (!qh)
 			break;
+		qh-&gt;exception = 1;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_async(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh-&gt;dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
 			/* already started */
@@ -923,11 +926,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
 		if (!qh)
 			break;
+		qh-&gt;exception = 1;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_intr(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh-&gt;dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -984,6 +990,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto done;
 	}
 
+	qh-&gt;exception = 1;
 	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
@@ -1052,13 +1059,12 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh-&gt;qh_state == QH_STATE_LINKED ||
-				qh-&gt;qh_state == QH_STATE_COMPLETING) {
-
+		} else {
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
 			else
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index c95f60d43b1a..fca741dbf9df 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -322,7 +322,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
  rescan:
 	last = NULL;
 	last_status = -EINPROGRESS;
-	qh-&gt;needs_rescan = 0;
+	qh-&gt;dequeue_during_giveback = 0;
 
 	/* remove de-activated QTDs from front of queue.
 	 * after faults (including short reads), cleanup this urb
@@ -518,18 +518,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* Do we need to rescan for URBs dequeued during a giveback? */
-	if (unlikely(qh-&gt;needs_rescan)) {
+	if (unlikely(qh-&gt;dequeue_during_giveback)) {
 		/* If the QH is already unlinked, do the rescan now. */
 		if (state == QH_STATE_IDLE)
 			goto rescan;
 
-		/* Otherwise we have to wait until the QH is fully unlinked.
-		 * Our caller will start an unlink if qh-&gt;needs_rescan is
-		 * set.  But if an unlink has already started, nothing needs
-		 * to be done.
-		 */
-		if (state != QH_STATE_LINKED)
-			qh-&gt;needs_rescan = 0;
+		/* Otherwise the caller must unlink the QH. */
 	}
 
 	/* restore original state; caller must unlink or relink */
@@ -538,29 +532,23 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* be sure the hardware's done with the qh before refreshing
 	 * it after fault cleanup, or recovering from silicon wrongly
 	 * overlaying the dummy qtd (which reduces DMA chatter).
+	 *
+	 * We won't refresh a QH that's linked (after the HC
+	 * stopped the queue).  That avoids a race:
+	 *  - HC reads first part of QH;
+	 *  - CPU updates that first part and the token;
+	 *  - HC reads rest of that QH, including token
+	 * Result:  HC gets an inconsistent image, and then
+	 * DMAs to/from the wrong memory (corrupting it).
+	 *
+	 * That should be rare for interrupt transfers,
+	 * except maybe high bandwidth ...
 	 */
-	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci)) {
-		if (state == QH_STATE_LINKED) {
-			/*
-			 * We won't refresh a QH that's linked (after the HC
-			 * stopped the queue).  That avoids a race:
-			 *  - HC reads first part of QH;
-			 *  - CPU updates that first part and the token;
-			 *  - HC reads rest of that QH, including token
-			 * Result:  HC gets an inconsistent image, and then
-			 * DMAs to/from the wrong memory (corrupting it).
-			 *
-			 * That should be rare for interrupt transfers,
-			 * except maybe high bandwidth ...
-			 *
-			 * Therefore tell the caller to start an unlink.
-			 */
-			qh-&gt;needs_rescan = 1;
-		}
-		/* otherwise, unlink already started */
-	}
+	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci))
+		qh-&gt;exception = 1;
 
-	return qh-&gt;needs_rescan;
+	/* Let the caller know if the QH needs to be unlinked. */
+	return qh-&gt;exception;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1002,8 +990,9 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw-&gt;hw_next = dma;
 
-	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
+	qh-&gt;xacterrs = 0;
+	qh-&gt;exception = 0;
 	/* qtd completions reported later by interrupt */
 
 	enable_async(ehci);
@@ -1317,16 +1306,9 @@ static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
 
 static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/*
-	 * If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
+	/* If the QH isn't linked then there's nothing we can do. */
+	if (qh-&gt;qh_state != QH_STATE_LINKED)
 		return;
-	}
 
 	single_unlink_async(ehci, qh);
 	start_iaa_cycle(ehci, false);
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 5c82bbab9a48..e7a2dbd27b1e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -539,6 +539,7 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	qh-&gt;xacterrs = 0;
+	qh-&gt;exception = 0;
 
 	/* update per-qh bandwidth for usbfs */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;period
@@ -602,15 +603,9 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
+	/* If the QH isn't linked then there's nothing we can do. */
+	if (qh-&gt;qh_state != QH_STATE_LINKED)
 		return;
-	}
 
 	qh_unlink_periodic (ehci, qh);
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 36c3a8210595..6815209511aa 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -384,7 +384,6 @@ struct ehci_qh {
 
 	unsigned		unlink_cycle;
 
-	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;
 #define	QH_STATE_LINKED		1		/* HC sees this */
 #define	QH_STATE_UNLINK		2		/* HC may still see this */
@@ -407,6 +406,9 @@ struct ehci_qh {
 	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
+	unsigned		dequeue_during_giveback:1;
+	unsigned		exception:1;	/* got a fault, or an unlink
+						   was requested */
 };
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit 79bcf7b02ba3d45bafe81a2753cedb8ef49548e3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:30:56 2013 -0400

    USB: EHCI: change return value of qh_completions()
    
    This patch (as1658) cleans up the usage of qh_completions() in
    ehci-hcd.  Currently the function's return value indicates whether any
    URBs were given back; the idea was that the caller can scan the QH
    over again to handle any URBs that were dequeued by a completion
    handler.  This is not necessary; when qh_completions() is ready to
    give back dequeued URBs, it does its own rescanning.
    
    Therefore the new return value will be a flag indicating whether the
    caller needs to unlink the QH.  This is more convenient than forcing
    the caller to check qh-&gt;needs_rescan, and it makes a lot more sense --
    why should "needs_rescan" imply that an unlink is needed?  The callers
    are also changed to remove the unneeded rescans.
    
    Lastly, the check for whether qh-&gt;qtd_list is non-empty is removed
    from the start of qh_completions().  Two of the callers have to make
    this test anyway, so the same test can simply be added to the other
    two callers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b824cb674898..c95f60d43b1a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -292,8 +292,8 @@ static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
  * Process and free completed qtds for a qh, returning URBs to drivers.
- * Chases up to qh-&gt;hw_current.  Returns number of completions called,
- * indicating how much "real" work we did.
+ * Chases up to qh-&gt;hw_current.  Returns nonzero if the caller should
+ * unlink qh.
  */
 static unsigned
 qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -302,13 +302,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct list_head	*entry, *tmp;
 	int			last_status;
 	int			stopped;
-	unsigned		count = 0;
 	u8			state;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
-	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
-		return count;
-
 	/* completions (or tasks on other cpus) must never clobber HALT
 	 * till we've gone through and cleaned everything up, even when
 	 * they add urbs to this qh's queue or mark them for unlinking.
@@ -345,7 +341,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		if (last) {
 			if (likely (last-&gt;urb != urb)) {
 				ehci_urb_done(ehci, last-&gt;urb, last_status);
-				count++;
 				last_status = -EINPROGRESS;
 			}
 			ehci_qtd_free (ehci, last);
@@ -519,7 +514,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* last urb's completion might still need calling */
 	if (likely (last != NULL)) {
 		ehci_urb_done(ehci, last-&gt;urb, last_status);
-		count++;
 		ehci_qtd_free (ehci, last);
 	}
 
@@ -566,7 +560,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* otherwise, unlink already started */
 	}
 
-	return count;
+	return qh-&gt;needs_rescan;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1254,7 +1248,8 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 		qh-&gt;qh_next.qh = NULL;
 
-		qh_completions(ehci, qh);
+		if (!list_empty(&amp;qh-&gt;qtd_list))
+			qh_completions(ehci, qh);
 		if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
 				ehci-&gt;rh_state == EHCI_RH_RUNNING)
 			qh_link_async(ehci, qh);
@@ -1348,7 +1343,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	while (ehci-&gt;qh_scan_next) {
 		qh = ehci-&gt;qh_scan_next;
 		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
- rescan:
+
 		/* clean any finished work for this qh */
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			int temp;
@@ -1361,14 +1356,13 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (qh-&gt;needs_rescan) {
+			if (unlikely(temp)) {
 				start_unlink_async(ehci, qh);
 			} else if (list_empty(&amp;qh-&gt;qtd_list)
 					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
 				qh-&gt;unlink_cycle = ehci-&gt;async_unlink_cycle;
 				check_unlinks_later = true;
-			} else if (temp != 0)
-				goto rescan;
+			}
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 66259dc7822e..5c82bbab9a48 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -649,7 +649,8 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 
-	qh_completions(ehci, qh);
+	if (!list_empty(&amp;qh-&gt;qtd_list))
+		qh_completions(ehci, qh);
 
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
@@ -914,7 +915,7 @@ static void scan_intr(struct ehci_hcd *ehci)
 
 	list_for_each_entry_safe(qh, ehci-&gt;qh_scan_next, &amp;ehci-&gt;intr_qh_list,
 			intr_node) {
- rescan:
+
 		/* clean any finished work for this qh */
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			int temp;
@@ -927,12 +928,9 @@ static void scan_intr(struct ehci_hcd *ehci)
 			 * in qh_unlink_periodic().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (unlikely(qh-&gt;needs_rescan ||
-					(list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-						qh-&gt;qh_state == QH_STATE_LINKED)))
+			if (unlikely(temp || (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+					qh-&gt;qh_state == QH_STATE_LINKED)))
 				start_unlink_intr(ehci, qh);
-			else if (temp != 0)
-				goto rescan;
 		}
 	}
 }</pre><hr><pre>commit c1fdb68e3d73741630ca16695cf9176c233be7ed
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:30:43 2013 -0400

    USB: EHCI: changes related to qh_refresh()
    
    This patch (as1638) makes several changes to the ehci-hcd driver, all
    related to the qh_refresh() function.  This function must be called
    whenever an idle QH gets linked back into either the async or the
    periodic schedule.
    
            Change a BUG_ON() in the qh_update routine to a WARN_ON().
            Since this code runs in atomic context, a BUG_ON() would
            immediately freeze the whole system.
    
            Remove two unneeded calls to qh_refresh(), one when a QH is
            initialized and one when a QH becomes idle.  Adjust the
            adjacent comments accordingly.
    
            Move the qh_refresh() and qh_link_periodic() calls for new
            interrupt URBs to after the new TDs have been added.
    
            As a result of the previous two changes, qh_refresh() is never
            called when the qtd_list is empty.  The corresponding check in
            qh_refresh() can be removed, along with an indentation level.
    
    These changes should not cause any alteration of behavior.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 23d136904285..b824cb674898 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -90,7 +90,7 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 	struct ehci_qh_hw *hw = qh-&gt;hw;
 
 	/* writes to an active overlay are unsafe */
-	BUG_ON(qh-&gt;qh_state != QH_STATE_IDLE);
+	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
 
 	hw-&gt;hw_qtd_next = QTD_NEXT(ehci, qtd-&gt;qtd_dma);
 	hw-&gt;hw_alt_next = EHCI_LIST_END(ehci);
@@ -123,26 +123,19 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	struct ehci_qtd *qtd;
 
-	if (list_empty (&amp;qh-&gt;qtd_list))
-		qtd = qh-&gt;dummy;
-	else {
-		qtd = list_entry (qh-&gt;qtd_list.next,
-				struct ehci_qtd, qtd_list);
-		/*
-		 * first qtd may already be partially processed.
-		 * If we come here during unlink, the QH overlay region
-		 * might have reference to the just unlinked qtd. The
-		 * qtd is updated in qh_completions(). Update the QH
-		 * overlay here.
-		 */
-		if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci)) {
-			qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
-			qtd = NULL;
-		}
-	}
+	qtd = list_entry(qh-&gt;qtd_list.next, struct ehci_qtd, qtd_list);
 
-	if (qtd)
-		qh_update (ehci, qh, qtd);
+	/*
+	 * first qtd may already be partially processed.
+	 * If we come here during unlink, the QH overlay region
+	 * might have reference to the just unlinked qtd. The
+	 * qtd is updated in qh_completions(). Update the QH
+	 * overlay here.
+	 */
+	if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))
+		qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
+	else
+		qh_update(ehci, qh, qtd);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -553,12 +546,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 * overlaying the dummy qtd (which reduces DMA chatter).
 	 */
 	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci)) {
-		switch (state) {
-		case QH_STATE_IDLE:
-			qh_refresh(ehci, qh);
-			break;
-		case QH_STATE_LINKED:
-			/* We won't refresh a QH that's linked (after the HC
+		if (state == QH_STATE_LINKED) {
+			/*
+			 * We won't refresh a QH that's linked (after the HC
 			 * stopped the queue).  That avoids a race:
 			 *  - HC reads first part of QH;
 			 *  - CPU updates that first part and the token;
@@ -568,13 +558,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 *
 			 * That should be rare for interrupt transfers,
 			 * except maybe high bandwidth ...
+			 *
+			 * Therefore tell the caller to start an unlink.
 			 */
-
-			/* Tell the caller to start an unlink */
 			qh-&gt;needs_rescan = 1;
-			break;
-		/* otherwise, unlink already started */
 		}
+		/* otherwise, unlink already started */
 	}
 
 	return count;
@@ -957,14 +946,13 @@ qh_make (
 
 	/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
 
-	/* init as live, toggle clear, advance to dummy */
+	/* init as live, toggle clear */
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw = qh-&gt;hw;
 	hw-&gt;hw_info1 = cpu_to_hc32(ehci, info1);
 	hw-&gt;hw_info2 = cpu_to_hc32(ehci, info2);
 	qh-&gt;is_out = !is_input;
 	usb_settoggle (urb-&gt;dev, usb_pipeendpoint (urb-&gt;pipe), !is_input, 1);
-	qh_refresh (ehci, qh);
 	return qh;
 }
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b476daf49f6f..66259dc7822e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -792,7 +792,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	unsigned	frame;		/* 0..(qh-&gt;period - 1), or NO_FRAME */
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
-	qh_refresh(ehci, qh);
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 	frame = qh-&gt;start;
 
@@ -844,8 +843,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	} else
 		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
 
-	/* stuff into the periodic schedule */
-	qh_link_periodic(ehci, qh);
 done:
 	return status;
 }
@@ -891,6 +888,12 @@ static int intr_submit (
 	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	BUG_ON (qh == NULL);
 
+	/* stuff into the periodic schedule */
+	if (qh-&gt;qh_state == QH_STATE_IDLE) {
+		qh_refresh(ehci, qh);
+		qh_link_periodic(ehci, qh);
+	}
+
 	/* ... update usbfs periodic stats */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_int_reqs++;
 </pre><hr><pre>commit 417c765af914106f5e76c4e0181dd555fe6a89a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 21 12:48:42 2013 -0400

    USB: EHCI: fix up incorrect merge resolution
    
    This patch (as1671) fixes up an incorrect resolution of a merge
    conflict between Greg KH's usb-linus branch and his usb-next branch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index dca8fc42b8d7..e7363332887e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -297,6 +297,15 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
 	u32 cmd, status;
 
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
 	/* If we get here, IAA is *REALLY* late.  It's barely
 	 * conceivable that the system is so busy that CMD_IAAD
 	 * is still legitimately set, so let's be sure it's</pre><hr><pre>commit d714aaf649460cbfd5e82e75520baa856b4fa0a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 20 15:07:26 2013 -0400

    USB: EHCI: fix regression in QH unlinking
    
    This patch (as1670) fixes a regression caused by commit
    6402c796d3b4205d3d7296157956c5100a05d7d6 (USB: EHCI: work around
    silicon bug in Intel's EHCI controllers).  The workaround goes through
    two IAA cycles for each QH being unlinked.  During the first cycle,
    the QH is not added to the async_iaa list (because it isn't fully gone
    from the hardware yet), which means that list will be empty.
    
    Unfortunately, I forgot to update the IAA watchdog timer routine.  It
    thinks that an empty async_iaa list means the timer expiration was an
    error, which isn't true any more.  This problem didn't show up during
    initial testing because the controllers being tested all had working
    IAA interrupts.  But not all controllers do, and when the watchdog
    timer expires, the empty-list check prevents the second IAA cycle from
    starting.  As a result, URB unlinks never complete.  The check needs
    to be removed.
    
    Among the symptoms of the regression are processes stuck in D wait
    states and hangs during system shutdown.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Reported-and-tested-by: Sven Joachim &lt;svenjoac@gmx.de&gt;
    Reported-by: Andreas Bombe &lt;aeb@debian.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..c3fa1305f830 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -304,7 +304,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_iaa) {
+	if (1) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely</pre><hr><pre>commit 8119b55aed818e590c26cb97706c914e3d660fd8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:03:17 2013 -0400

    USB: gadget: net2280: remove leftover driver-&gt;unbind call in error pathway
    
    This patch (as1667) removes an incorrect driver-&gt;unbind() call from
    the net2280 driver.  If startup fails, the UDC core takes care of
    unbinding the gadget driver automatically; the controller driver
    shouldn't do it too.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 3105a4d601c8..3bd0f992fb49 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -1924,7 +1924,6 @@ static int net2280_start(struct usb_gadget *_gadget,
 err_func:
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_function);
 err_unbind:
-	driver-&gt;unbind (&amp;dev-&gt;gadget);
 	dev-&gt;gadget.dev.driver = NULL;
 	dev-&gt;driver = NULL;
 	return retval;</pre><hr><pre>commit 511f3c5326eabe1ece35202a404c24c0aeacc246
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:02:14 2013 -0400

    usb: gadget: udc-core: fix a regression during gadget driver unbinding
    
    This patch (as1666) fixes a regression in the UDC core.  The core
    takes care of unbinding gadget drivers, and it does the unbinding
    before telling the UDC driver to turn off the controller hardware.
    When the call to the udc_stop callback is made, the gadget no longer
    has a driver.  The callback routine should not be invoked with a
    pointer to the old driver; doing so can cause problems (such as
    use-after-free accesses in net2280).
    
    This patch should be applied, with appropriate context changes, to all
    the stable kernels going back to 3.1.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index 2a9cd369f71c..f8f62c3ed65e 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -216,7 +216,7 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	usb_gadget_disconnect(udc-&gt;gadget);
 	udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
 	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
-	usb_gadget_udc_stop(udc-&gt;gadget, udc-&gt;driver);
+	usb_gadget_udc_stop(udc-&gt;gadget, NULL);
 
 	udc-&gt;driver = NULL;
 	udc-&gt;dev.driver = NULL;</pre><hr><pre>commit 24b90814fb133bb7971aef8ea5e642d9f9bc4b0b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:42 2013 -0400

    USB: EHCI: don't turn on PORT_SUSPEND during port resume
    
    This patch (as1637) cleans up the way ehci-hcd handles end-of-resume
    port signalling.  When the PORT_RESUME bit in the port's status and
    control register is cleared, we shouldn't be setting the PORT_SUSPEND
    bit at the same time.  Not doing this doesn't seem to have hurt so
    far, but we might as well do the right thing.
    
    Also, the patch replaces an estimated value for what the port status
    should be following a resume with the actual register value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 576b735f49b6..0df45d933a10 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -464,7 +464,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	while (i--) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
 		if (test_bit(i, &amp;resume_needed)) {
-			temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
+			temp &amp;= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);
 			ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
 		}
@@ -871,10 +871,9 @@ static int ehci_hub_control (
 				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 
 				/* stop resume signaling */
-				temp = ehci_readl(ehci, status_reg);
-				ehci_writel(ehci,
-					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
-					status_reg);
+				temp &amp;= ~(PORT_RWC_BITS |
+						PORT_SUSPEND | PORT_RESUME);
+				ehci_writel(ehci, temp, status_reg);
 				clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
@@ -884,7 +883,7 @@ static int ehci_hub_control (
 						wIndex + 1, retval);
 					goto error;
 				}
-				temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
+				temp = ehci_readl(ehci, status_reg);
 			}
 		}
 </pre><hr><pre>commit 60fd4aa742a0c4f01dafeb0d125fed54e91e3657
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:19 2013 -0400

    USB: EHCI: reorganize ehci_iaa_watchdog()
    
    This patch (as1635) rearranges the control-flow logic in
    ehci_iaa_watchdog() slightly to agree better with the comments.  It
    also changes a verbose-debug message to a regular debug message.
    Expiration of the IAA watchdog is an unusual event and can lead to
    problems; we need to know about it if it happens during debugging.  It
    should not be necessary to set a "verbose" compilation option.
    
    No behavioral changes other than the debug message.  Lots of apparent
    changes to the source text, though, because the indentation level was
    decreased.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index cc9ad5892d19..97815d0fc97c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -295,8 +295,7 @@ static void end_free_itds(struct ehci_hcd *ehci)
 /* Handle lost (or very late) IAA interrupts */
 static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
-		return;
+	u32 cmd, status;
 
 	/*
 	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
@@ -304,34 +303,32 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_iaa) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		/*
-		 * If IAA is set here it either legitimately triggered
-		 * after the watchdog timer expired (_way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
-		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
-			COUNT(ehci-&gt;stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
-		}
+	if (!ehci-&gt;async_iaa || ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/* If we get here, IAA is *REALLY* late.  It's barely
+	 * conceivable that the system is so busy that CMD_IAAD
+	 * is still legitimately set, so let's be sure it's
+	 * clear before we read STS_IAA.  (The HC should clear
+	 * CMD_IAAD when it sets STS_IAA.)
+	 */
+	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
+	/*
+	 * If IAA is set here it either legitimately triggered
+	 * after the watchdog timer expired (_way_ late, so we'll
+	 * still count it as lost) ... or a silicon erratum:
+	 * - VIA seems to set IAA without triggering the IRQ;
+	 * - IAAD potentially cleared without setting IAA.
+	 */
+	status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+	if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
+		COUNT(ehci-&gt;stats.lost_iaa);
+		ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
 	}
+
+	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
+	end_unlink_async(ehci);
 }
 
 </pre><hr><pre>commit 4dd405a4b0969bfec4dc9959050b46d818b6549b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:08 2013 -0400

    USB: EHCI: improve use of per-port status-change bits
    
    This patch (as1634) simplifies some of the code associated with the
    per-port change bits added in EHCI-1.1, and in particular it fixes a
    bug in the logic of ehci_hub_status_data().  Even if the change bit
    doesn't indicate anything happened on a particular port, we still have
    to notify the core about changes to the suspend or reset status.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 303b0222cd6d..fcf8b940e867 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -758,7 +758,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status &amp; STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci-&gt;hcs_params);
-		u32		ppcd = 0;
+		u32		ppcd = ~0;
 
 		/* kick root hub later */
 		pcd_status = status;
@@ -775,7 +775,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			int pstatus;
 
 			/* leverage per-port change bits feature */
-			if (ehci-&gt;has_ppcd &amp;&amp; !(ppcd &amp; (1 &lt;&lt; i)))
+			if (!(ppcd &amp; (1 &lt;&lt; i)))
 				continue;
 			pstatus = ehci_readl(ehci,
 					 &amp;ehci-&gt;regs-&gt;port_status[i]);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4d3b294f203e..576b735f49b6 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -590,7 +590,7 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	u32		mask;
 	int		ports, i, retval = 1;
 	unsigned long	flags;
-	u32		ppcd = 0;
+	u32		ppcd = ~0;
 
 	/* init status to no-changes */
 	buf [0] = 0;
@@ -628,9 +628,10 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 
 	for (i = 0; i &lt; ports; i++) {
 		/* leverage per-port change bits feature */
-		if (ehci-&gt;has_ppcd &amp;&amp; !(ppcd &amp; (1 &lt;&lt; i)))
-			continue;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
+		if (ppcd &amp; (1 &lt;&lt; i))
+			temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status[i]);
+		else
+			temp = 0;
 
 		/*
 		 * Return status information even for ports with OWNER set.</pre>
    <div class="pagination">
        <a href='2_37.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><span>[38]</span><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_39.html'>Next&gt;&gt;</a>
    <div>
</body>
