<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_42.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><span>[43]</span><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_44.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit acc08503406f97ce6582c92fd8c8139f1e871a96
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 10 15:07:39 2012 -0400

    USB: EHCI: make ehci_read_frame_index platform independent
    
    In preparation for splitting the ehci-hcd driver into a core library
    and separate platform-specific driver modules, this patch (as1617)
    changes the way ehci_read_frame_index() is handled.
    
    Since the same core library will have to work with both PCI and
    non-PCI platforms, the quirk handler routine will be compiled
    unconditionally.  The decision about whether to call it or simply to
    read the frame index register is made at run time, based on whether
    the frame_index_bug quirk flag is set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Felipe Balbi &lt;balbi@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 28fb5ddaf786..9c2afb516fe5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -118,9 +118,34 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 /*-------------------------------------------------------------------------*/
 
 #include "ehci.h"
-#include "ehci-dbg.c"
 #include "pci-quirks.h"
 
+/*
+ * The MosChip MCS9990 controller updates its microframe counter
+ * a little before the frame counter, and occasionally we will read
+ * the invalid intermediate value.  Avoid problems by checking the
+ * microframe number (the low-order 3 bits); if they are 0 then
+ * re-read the register to get the correct value.
+ */
+static unsigned ehci_moschip_read_frame_index(struct ehci_hcd *ehci)
+{
+	unsigned uf;
+
+	uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+	if (unlikely((uf &amp; 7) == 0))
+		uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+	return uf;
+}
+
+static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
+{
+	if (ehci-&gt;frame_index_bug)
+		return ehci_moschip_read_frame_index(ehci);
+	return ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+}
+
+#include "ehci-dbg.c"
+
 /*-------------------------------------------------------------------------*/
 
 /*
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b538a4d62d5e..2e14714b359f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -36,29 +36,6 @@
 
 static int ehci_get_frame (struct usb_hcd *hcd);
 
-#ifdef CONFIG_PCI
-
-static unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
-{
-	unsigned uf;
-
-	/*
-	 * The MosChip MCS9990 controller updates its microframe counter
-	 * a little before the frame counter, and occasionally we will read
-	 * the invalid intermediate value.  Avoid problems by checking the
-	 * microframe number (the low-order 3 bits); if they are 0 then
-	 * re-read the register to get the correct value.
-	 */
-	uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
-	if (unlikely(ehci-&gt;frame_index_bug &amp;&amp; ((uf &amp; 7) == 0)))
-		uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
-	return uf;
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 /*
  * periodic_next_shadow - return "next" pointer on shadow list
  * @periodic: host pointer to qh/itd/sitd
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 9b8cbb4b3e2c..ec948c3b1cea 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -776,22 +776,6 @@ static inline u32 hc32_to_cpup (const struct ehci_hcd *ehci, const __hc32 *x)
 	static inline void ehci_vdbg(struct ehci_hcd *ehci, ...) {}
 #endif
 
-#ifdef CONFIG_PCI
-
-/* For working around the MosChip frame-index-register bug */
-static unsigned ehci_read_frame_index(struct ehci_hcd *ehci);
-
-#else
-
-static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
-{
-	return ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 #ifndef DEBUG
 #define STUB_DEBUG_FILES
 #endif	/* DEBUG */</pre><hr><pre>commit d6064aca824b81fbb788fd230c88976d84b651b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 10 15:07:30 2012 -0400

    USB: EHCI: move logging macros to ehci.h
    
    In preparation for splitting the ehci-hcd driver into a core library
    and separate platform-specific driver modules, this patch (as1616)
    moves the console logging macros from ehci-dbg.c to ehci.h, where they
    will be available to the platform drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Felipe Balbi &lt;balbi@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 1599806e3d47..dfd3bf3aa4de 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -18,21 +18,6 @@
 
 /* this file is part of ehci-hcd.c */
 
-#define ehci_dbg(ehci, fmt, args...) \
-	dev_dbg (ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args )
-#define ehci_err(ehci, fmt, args...) \
-	dev_err (ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args )
-#define ehci_info(ehci, fmt, args...) \
-	dev_info (ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args )
-#define ehci_warn(ehci, fmt, args...) \
-	dev_warn (ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args )
-
-#ifdef VERBOSE_DEBUG
-#	define ehci_vdbg ehci_dbg
-#else
-	static inline void ehci_vdbg(struct ehci_hcd *ehci, ...) {}
-#endif
-
 #ifdef	DEBUG
 
 /* check the values in the HCSPARAMS register
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 4ddf7c51616b..9b8cbb4b3e2c 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -761,6 +761,21 @@ static inline u32 hc32_to_cpup (const struct ehci_hcd *ehci, const __hc32 *x)
 
 /*-------------------------------------------------------------------------*/
 
+#define ehci_dbg(ehci, fmt, args...) \
+	dev_dbg(ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args)
+#define ehci_err(ehci, fmt, args...) \
+	dev_err(ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args)
+#define ehci_info(ehci, fmt, args...) \
+	dev_info(ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args)
+#define ehci_warn(ehci, fmt, args...) \
+	dev_warn(ehci_to_hcd(ehci)-&gt;self.controller , fmt , ## args)
+
+#ifdef VERBOSE_DEBUG
+#	define ehci_vdbg ehci_dbg
+#else
+	static inline void ehci_vdbg(struct ehci_hcd *ehci, ...) {}
+#endif
+
 #ifdef CONFIG_PCI
 
 /* For working around the MosChip frame-index-register bug */</pre><hr><pre>commit 6a41b4d3fe8cd4cc95181516fc6fba7b1747a27c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:32:15 2012 -0400

    OHCI: implement new semantics for URB_ISO_ASAP
    
    This patch (as1614) updates the isochronous scheduling in ohci-hcd to
    match the new semantics for URB_ISO_ASAP.  Testing revealed a hardware
    bug in the way my OHCI controller handles expired isochronous TDs;
    consequently the patch tries hard to avoid creating them (unlike the
    ehci-hcd and uhci-hcd drivers).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 4a1d64d92338..cfc1da30667c 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -231,13 +231,41 @@ static int ohci_urb_enqueue (
 			frame &amp;= ~(ed-&gt;interval - 1);
 			frame |= ed-&gt;branch;
 			urb-&gt;start_frame = frame;
+		}
+	} else if (ed-&gt;type == PIPE_ISOCHRONOUS) {
+		u16	next = ohci_frame_no(ohci) + 2;
+		u16	frame = ed-&gt;last_iso + ed-&gt;interval;
+
+		/* Behind the scheduling threshold? */
+		if (unlikely(tick_before(frame, next))) {
 
-			/* yes, only URB_ISO_ASAP is supported, and
-			 * urb-&gt;start_frame is never used as input.
+			/* USB_ISO_ASAP: Round up to the first available slot */
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+				frame += (next - frame + ed-&gt;interval - 1) &amp;
+						-ed-&gt;interval;
+
+			/*
+			 * Not ASAP: Use the next slot in the stream.  If
+			 * the entire URB falls before the threshold, fail.
 			 */
+			else if (tick_before(frame + ed-&gt;interval *
+					(urb-&gt;number_of_packets - 1), next)) {
+				retval = -EXDEV;
+				usb_hcd_unlink_urb_from_ep(hcd, urb);
+				goto fail;
+			}
+
+			/*
+			 * Some OHCI hardware doesn't handle late TDs
+			 * correctly.  After retiring them it proceeds to
+			 * the next ED instead of the next TD.  Therefore
+			 * we have to omit the late TDs entirely.
+			 */
+			urb_priv-&gt;td_cnt = DIV_ROUND_UP(next - frame,
+					ed-&gt;interval);
 		}
-	} else if (ed-&gt;type == PIPE_ISOCHRONOUS)
-		urb-&gt;start_frame = ed-&gt;last_iso + ed-&gt;interval;
+		urb-&gt;start_frame = frame;
+	}
 
 	/* fill the TDs and link them to the ed; and
 	 * enable that part of the schedule, if needed
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index c5a1ea9145fa..177a213790d4 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -596,7 +596,6 @@ static void td_submit_urb (
 		urb_priv-&gt;ed-&gt;hwHeadP &amp;= ~cpu_to_hc32 (ohci, ED_C);
 	}
 
-	urb_priv-&gt;td_cnt = 0;
 	list_add (&amp;urb_priv-&gt;pending, &amp;ohci-&gt;pending);
 
 	if (data_len)
@@ -672,7 +671,8 @@ static void td_submit_urb (
 	 * we could often reduce the number of TDs here.
 	 */
 	case PIPE_ISOCHRONOUS:
-		for (cnt = 0; cnt &lt; urb-&gt;number_of_packets; cnt++) {
+		for (cnt = urb_priv-&gt;td_cnt; cnt &lt; urb-&gt;number_of_packets;
+				cnt++) {
 			int	frame = urb-&gt;start_frame;
 
 			// FIXME scheduling should handle frame counter</pre><hr><pre>commit c44b225077bb1fb25ed5cd5c4f226897b91bedd4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:32:09 2012 -0400

    UHCI: implement new semantics for URB_ISO_ASAP
    
    This patch (as1613) updates the isochronous scheduling in uhci-hcd to
    match the new semantics for URB_ISO_ASAP.  The amount of code
    alteration is smaller than it looks because of a change in the
    indentation level.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index d2c6f5ac4626..15921fd55048 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1256,7 +1256,8 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
 	struct uhci_td *td = NULL;	/* Since urb-&gt;number_of_packets &gt; 0 */
-	int i, frame;
+	int i;
+	unsigned frame, next;
 	unsigned long destination, status;
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
@@ -1265,37 +1266,29 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 			urb-&gt;number_of_packets &gt;= UHCI_NUMFRAMES)
 		return -EFBIG;
 
+	uhci_get_current_frame_number(uhci);
+
 	/* Check the period and figure out the starting frame number */
 	if (!qh-&gt;bandwidth_reserved) {
 		qh-&gt;period = urb-&gt;interval;
-		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
-			qh-&gt;phase = -1;		/* Find the best phase */
-			i = uhci_check_bandwidth(uhci, qh);
-			if (i)
-				return i;
-
-			/* Allow a little time to allocate the TDs */
-			uhci_get_current_frame_number(uhci);
-			frame = uhci-&gt;frame_number + 10;
-
-			/* Move forward to the first frame having the
-			 * correct phase */
-			urb-&gt;start_frame = frame + ((qh-&gt;phase - frame) &amp;
-					(qh-&gt;period - 1));
-		} else {
-			i = urb-&gt;start_frame - uhci-&gt;last_iso_frame;
-			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
-				return -EINVAL;
-			qh-&gt;phase = urb-&gt;start_frame &amp; (qh-&gt;period - 1);
-			i = uhci_check_bandwidth(uhci, qh);
-			if (i)
-				return i;
-		}
+		qh-&gt;phase = -1;		/* Find the best phase */
+		i = uhci_check_bandwidth(uhci, qh);
+		if (i)
+			return i;
+
+		/* Allow a little time to allocate the TDs */
+		next = uhci-&gt;frame_number + 10;
+		frame = qh-&gt;phase;
+
+		/* Round up to the first available slot */
+		frame += (next - frame + qh-&gt;period - 1) &amp; -qh-&gt;period;
 
 	} else if (qh-&gt;period != urb-&gt;interval) {
 		return -EINVAL;		/* Can't change the period */
 
 	} else {
+		next = uhci-&gt;frame_number + 2;
+
 		/* Find the next unused frame */
 		if (list_empty(&amp;qh-&gt;queue)) {
 			frame = qh-&gt;iso_frame;
@@ -1308,25 +1301,31 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 					lurb-&gt;number_of_packets *
 					lurb-&gt;interval;
 		}
-		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
-			/* Skip some frames if necessary to insure
-			 * the start frame is in the future.
+
+		/* Fell behind? */
+		if (uhci_frame_before_eq(frame, next)) {
+
+			/* USB_ISO_ASAP: Round up to the first available slot */
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+				frame += (next - frame + qh-&gt;period - 1) &amp;
+						-qh-&gt;period;
+
+			/*
+			 * Not ASAP: Use the next slot in the stream.  If
+			 * the entire URB falls before the threshold, fail.
 			 */
-			uhci_get_current_frame_number(uhci);
-			if (uhci_frame_before_eq(frame, uhci-&gt;frame_number)) {
-				frame = uhci-&gt;frame_number + 1;
-				frame += ((qh-&gt;phase - frame) &amp;
-					(qh-&gt;period - 1));
-			}
-		}	/* Otherwise pick up where the last URB leaves off */
-		urb-&gt;start_frame = frame;
+			else if (!uhci_frame_before_eq(next,
+					frame + (urb-&gt;number_of_packets - 1) *
+						qh-&gt;period))
+				return -EXDEV;
+		}
 	}
 
 	/* Make sure we won't have to go too far into the future */
 	if (uhci_frame_before_eq(uhci-&gt;last_iso_frame + UHCI_NUMFRAMES,
-			urb-&gt;start_frame + urb-&gt;number_of_packets *
-				urb-&gt;interval))
+			frame + urb-&gt;number_of_packets * urb-&gt;interval))
 		return -EFBIG;
+	urb-&gt;start_frame = frame;
 
 	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);</pre><hr><pre>commit 4005ad4390bf698e3bdae9567e79242ec0584097
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:32:01 2012 -0400

    EHCI: implement new semantics for URB_ISO_ASAP
    
    This patch (as1612) updates the isochronous scheduling and processing
    in ehci-hcd to match the new semantics for URB_ISO_ASAP.  It also adds
    a missing "unlikely" in sitd_complete() to match the corresponding
    statement in itd_complete(), and it increments urb-&gt;error_count in a
    couple of places that had been overlooked.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index e08e65d8e004..b538a4d62d5e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1386,8 +1386,8 @@ iso_stream_schedule (
 
 	/* Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
-	 * (irq delays etc), but if there are we'll take the next
-	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
+	 * (irq delays etc).  If there are, the behavior depends on
+	 * whether URB_ISO_ASAP is set.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 
@@ -1414,9 +1414,25 @@ iso_stream_schedule (
 			goto fail;
 		}
 
-		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
-		if (unlikely(start &lt; next))
-			start += (next - start + period - 1) &amp; (- period);
+		/* Behind the scheduling threshold? */
+		if (unlikely(start &lt; next)) {
+
+			/* USB_ISO_ASAP: Round up to the first available slot */
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+				start += (next - start + period - 1) &amp; -period;
+
+			/*
+			 * Not ASAP: Use the next slot in the stream.  If
+			 * the entire URB falls before the threshold, fail.
+			 */
+			else if (start + span - period &lt; next) {
+				ehci_dbg(ehci, "iso urb late %p (%u+%u &lt; %u)\n",
+						urb, start + base,
+						span - period, next + base);
+				status = -EXDEV;
+				goto fail;
+			}
+		}
 
 		start += base;
 	}
@@ -1699,7 +1715,7 @@ static bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)
 			urb-&gt;actual_length += desc-&gt;actual_length;
 		} else {
 			/* URB was too late */
-			desc-&gt;status = -EXDEV;
+			urb-&gt;error_count++;
 		}
 	}
 
@@ -2072,7 +2088,7 @@ static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
 	t = hc32_to_cpup(ehci, &amp;sitd-&gt;hw_results);
 
 	/* report transfer status */
-	if (t &amp; SITD_ERRS) {
+	if (unlikely(t &amp; SITD_ERRS)) {
 		urb-&gt;error_count++;
 		if (t &amp; SITD_STS_DBE)
 			desc-&gt;status = usb_pipein (urb-&gt;pipe)
@@ -2082,6 +2098,9 @@ static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
 			desc-&gt;status = -EOVERFLOW;
 		else /* XACT, MMF, etc */
 			desc-&gt;status = -EPROTO;
+	} else if (unlikely(t &amp; SITD_STS_ACTIVE)) {
+		/* URB was too late */
+		urb-&gt;error_count++;
 	} else {
 		desc-&gt;status = 0;
 		desc-&gt;actual_length = desc-&gt;length - SITD_LENGTH(t);</pre><hr><pre>commit a03bede5c73a6876fa891cfe82a65460dc9f4698
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:31:53 2012 -0400

    USB: update documentation for URB_ISO_ASAP
    
    This patch (as1611) updates the USB documentation and kerneldoc to
    give a more precise meaning for the URB_ISO_ASAP flag and to explain
    more of the details of scheduling for isochronous URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/usb/error-codes.txt b/Documentation/usb/error-codes.txt
index b3f606b81a03..8d1e2a9ebbba 100644
--- a/Documentation/usb/error-codes.txt
+++ b/Documentation/usb/error-codes.txt
@@ -35,9 +35,8 @@ USB-specific:
 		d) ISO: number_of_packets is &lt; 0
 		e) various other cases
 
--EAGAIN		a) specified ISO start frame too early
-		b) (using ISO-ASAP) too much scheduled for the future
-		   wait some time and try again.
+-EXDEV		ISO: URB_ISO_ASAP wasn't specified and all the frames
+		the URB would be scheduled in have already expired.
 
 -EFBIG		Host controller driver can't schedule that many ISO frames.
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9d912bfdcffe..3662287e2f4f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -214,9 +214,25 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * urb-&gt;interval is modified to reflect the actual transfer period used
  * (normally some power of two units).  And for isochronous urbs,
  * urb-&gt;start_frame is modified to reflect when the URB's transfers were
- * scheduled to start.  Not all isochronous transfer scheduling policies
- * will work, but most host controller drivers should easily handle ISO
- * queues going from now until 10-200 msec into the future.
+ * scheduled to start.
+ *
+ * Not all isochronous transfer scheduling policies will work, but most
+ * host controller drivers should easily handle ISO queues going from now
+ * until 10-200 msec into the future.  Drivers should try to keep at
+ * least one or two msec of data in the queue; many controllers require
+ * that new transfers start at least 1 msec in the future when they are
+ * added.  If the driver is unable to keep up and the queue empties out,
+ * the behavior for new submissions is governed by the URB_ISO_ASAP flag.
+ * If the flag is set, or if the queue is idle, then the URB is always
+ * assigned to the first available (and not yet expired) slot in the
+ * endpoint's schedule.  If the flag is not set and the queue is active
+ * then the URB is always assigned to the next slot in the schedule
+ * following the end of the endpoint's previous URB, even if that slot is
+ * in the past.  When a packet is assigned in this way to a slot that has
+ * already expired, the packet is not transmitted and the corresponding
+ * usb_iso_packet_descriptor's status field will return -EXDEV.  If this
+ * would happen to all the packets in the URB, submission fails with a
+ * -EXDEV error code.
  *
  * For control endpoints, the synchronous usb_control_msg() call is
  * often used (in non-interrupt context) instead of this call.
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 10278d18709c..f92cdf0c1457 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1129,8 +1129,8 @@ extern int usb_disabled(void);
  * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
-					 * ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only; use the first unexpired
+					 * slot in the schedule */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
@@ -1309,15 +1309,20 @@ typedef void (*usb_complete_t)(struct urb *);
  * the transfer interval in the endpoint descriptor is logarithmic.
  * Device drivers must convert that value to linear units themselves.)
  *
- * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling
- * the host controller to schedule the transfer as soon as bandwidth
- * utilization allows, and then set start_frame to reflect the actual frame
- * selected during submission.  Otherwise drivers must specify the start_frame
- * and handle the case where the transfer can't begin then.  However, drivers
- * won't know how bandwidth is currently allocated, and while they can
- * find the current frame using usb_get_current_frame_number () they can't
- * know the range for that frame number.  (Ranges for frame counter values
- * are HC-specific, and can go from 256 to 65536 frames from "now".)
+ * If an isochronous endpoint queue isn't already running, the host
+ * controller will schedule a new URB to start as soon as bandwidth
+ * utilization allows.  If the queue is running then a new URB will be
+ * scheduled to start in the first transfer slot following the end of the
+ * preceding URB, if that slot has not already expired.  If the slot has
+ * expired (which can happen when IRQ delivery is delayed for a long time),
+ * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
+ * is clear then the URB will be scheduled to start in the expired slot,
+ * implying that some of its packets will not be transferred; if the flag
+ * is set then the URB will be scheduled in the first unexpired slot,
+ * breaking the queue's synchronization.  Upon URB completion, the
+ * start_frame field will be set to the (micro)frame number in which the
+ * transfer was scheduled.  Ranges for frame counter values are HC-specific
+ * and can go from as low as 256 to as high as 65536 frames.
  *
  * Isochronous URBs have a different data transfer model, in part because
  * the quality of service is only "best effort".  Callers provide specially</pre><hr><pre>commit 72675479925f53af051ae8a78bcfafeaa47b3eef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:40 2012 -0400

    EHCI: replace mult/div with bit-mask operation
    
    This patch (as1610) replaces multiplication and divison operations in
    ehci-hcd's isochronous scheduling code with a bit-mask operation,
    taking advantage of the fact that isochronous periods are always
    powers of 2.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b764cab2ab9a..e08e65d8e004 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1416,7 +1416,7 @@ iso_stream_schedule (
 
 		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
 		if (unlikely(start &lt; next))
-			start += period * DIV_ROUND_UP(next - start, period);
+			start += (next - start + period - 1) &amp; (- period);
 
 		start += base;
 	}</pre><hr><pre>commit 98cae42d82fe9c9e2b5dacdf391edaa007e147e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:34 2012 -0400

    EHCI: use the isochronous scheduling threshold
    
    This patch (as1609) changes the way ehci-hcd uses the "Isochronous
    Scheduling Threshold" in its calculations.  Until now the code has
    ignored the threshold except for certain Intel PCI-based controllers.
    This violates the EHCI spec.
    
    The new code takes the threshold into account always, removing the
    need for the fs_i_thresh quirk flag.  In addition it implements the
    "full frame cache" setting more efficiently, moving forward only as
    far as the next frame boundary instead of always moving forward 8
    microframes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6bf6c42481e8..61eac96441de 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -503,7 +503,7 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	/* controllers may cache some of the periodic schedule ... */
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
-		ehci-&gt;i_thresh = 2 + 8;
+		ehci-&gt;i_thresh = 0;
 	else					// N microframes cached
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 2cb7d370c4ef..d1407f8d42b1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -103,7 +103,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_INTEL:
-		ehci-&gt;fs_i_thresh = 1;
 		if (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd-&gt;has_tt = 1;
 		break;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7eb242f27c00..b764cab2ab9a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1391,15 +1391,11 @@ iso_stream_schedule (
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 
-		/* For high speed devices, allow scheduling within the
-		 * isochronous scheduling threshold.  For full speed devices
-		 * and Intel PCI-based controllers, don't (work around for
-		 * Intel ICH9 bug).
-		 */
-		if (!stream-&gt;highspeed &amp;&amp; ehci-&gt;fs_i_thresh)
-			next = now + ehci-&gt;i_thresh;
+		/* Take the isochronous scheduling threshold into account */
+		if (ehci-&gt;i_thresh)
+			next = now + ehci-&gt;i_thresh;	/* uframe cache */
 		else
-			next = now;
+			next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
 
 		/*
 		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 0564a63f5eb3..4ddf7c51616b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -193,7 +193,6 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_amcc_usb23:1;
 	unsigned		need_io_watchdog:1;
 	unsigned		amd_pll_fix:1;
-	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/
 	unsigned		has_synopsys_hc_bug:1; /* Synopsys HC */
 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */</pre><hr><pre>commit c3ee9b76aa93fbf59727e02fac9914c7355108f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:23 2012 -0400

    EHCI: improved logic for isochronous scheduling
    
    This patch (as1608) reworks the logic used by ehci-hcd for scheduling
    isochronous transfers.  Now the modular calculations are all based on
    a window that starts at the last frame scanned for isochronous
    completions.  No transfer descriptors for any earlier frames can
    possibly remain on the schedule, so there can be no confusion from
    schedule wrap-around.  This removes the need for a "slop" region of
    arbitrary size.
    
    There's no need to check for URBs that are longer than the schedule
    length.  With the old code they could throw things off by wrapping
    around and appearing to end in the near future rather than the distant
    future.  Now such confusion isn't possible, and the existing test for
    submissions that extend too far into the future will also catch those
    that exceed the schedule length.  (But there still has to be an
    initial test to handle the case where the schedule already extends as
    far into the future as possible.)
    
    Delays caused by IRQ latency won't confuse the algorithm unless they
    are ridiculously long (over 250 ms); they will merely reduce how far
    into the future new transfers can be scheduled.  A few people have
    reported problems caused by delays of 50 ms or so.  Now instead of
    failing completely, isochronous transfers will experience a brief
    glitch and then continue normally.
    
    (Whether this is truly a good thing is debatable.  A latency as large
    as 50 ms generally indicates a bug is present, and complete failure of
    audio or video transfers draws people's attention pretty vividly.
    Making the transfers more robust also makes it easier for such bugs to
    remain undetected.)
    
    Finally, ehci-&gt;next_frame is renamed to ehci-&gt;last_iso_frame, because
    that better describes what it is: the last frame to have been scanned
    for isochronous completions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7cf3da7babf0..7eb242f27c00 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1361,7 +1361,7 @@ sitd_slot_ok (
  * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!
  */
 
-#define SCHEDULE_SLOP	80	/* microframes */
+#define SCHEDULING_DELAY	40	/* microframes */
 
 static int
 iso_stream_schedule (
@@ -1370,7 +1370,7 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, next, start, period, span;
+	u32			now, base, next, start, period, span;
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
@@ -1382,12 +1382,6 @@ iso_stream_schedule (
 		span &lt;&lt;= 3;
 	}
 
-	if (span &gt; mod - SCHEDULE_SLOP) {
-		ehci_dbg (ehci, "iso request %p too long\n", urb);
-		status = -EFBIG;
-		goto fail;
-	}
-
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1396,7 +1390,6 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		u32	excess;
 
 		/* For high speed devices, allow scheduling within the
 		 * isochronous scheduling threshold.  For full speed devices
@@ -1408,36 +1401,41 @@ iso_stream_schedule (
 		else
 			next = now;
 
-		/* Fell behind (by up to twice the slop amount)?
-		 * We decide based on the time of the last currently-scheduled
-		 * slot, not the time of the next available slot.
+		/*
+		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+		 * TDs scheduled for earlier than that.
 		 */
-		excess = (stream-&gt;next_uframe - period - next) &amp; (mod - 1);
-		if (excess &gt;= mod - 2 * SCHEDULE_SLOP)
-			start = next + excess - mod + period *
-					DIV_ROUND_UP(mod - excess, period);
-		else
-			start = next + excess + period;
-		if (start - now &gt;= mod) {
-			ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
-					urb, start - now - period, period,
-					mod);
-			status = -EFBIG;
+		base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+		next = (next - base) &amp; (mod - 1);
+		start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+
+		/* Is the schedule already full? */
+		if (unlikely(start &lt; period)) {
+			ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
+					urb, stream-&gt;next_uframe, base,
+					period, mod);
+			status = -ENOSPC;
 			goto fail;
 		}
+
+		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
+		if (unlikely(start &lt; next))
+			start += period * DIV_ROUND_UP(next - start, period);
+
+		start += base;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
 	 * this is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the slop should handle reasonably slow cpus.  it
+	 * isn't free, the delay should handle reasonably slow cpus.  it
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
 	else {
 		int done = 0;
-		start = SCHEDULE_SLOP + (now &amp; ~0x07);
 
-		/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
+		base = now &amp; ~0x07;
+		start = base + SCHEDULING_DELAY;
 
 		/* find a uframe slot with enough bandwidth.
 		 * Early uframes are more precious because full-speed
@@ -1464,19 +1462,16 @@ iso_stream_schedule (
 
 		/* no room in the schedule */
 		if (!done) {
-			ehci_dbg(ehci, "iso resched full %p (now %d max %d)\n",
-				urb, now, now + mod);
+			ehci_dbg(ehci, "iso sched full %p", urb);
 			status = -ENOSPC;
 			goto fail;
 		}
 	}
 
 	/* Tried to schedule too far into the future? */
-	if (unlikely(start - now + span - period
-				&gt;= mod - 2 * SCHEDULE_SLOP)) {
-		ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
-				urb, start - now, span - period,
-				mod - 2 * SCHEDULE_SLOP);
+	if (unlikely(start - base + span - period &gt;= mod)) {
+		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",
+				urb, start - base, span - period, mod);
 		status = -EFBIG;
 		goto fail;
 	}
@@ -1490,7 +1485,7 @@ iso_stream_schedule (
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
-		ehci-&gt;next_frame = now &gt;&gt; 3;
+		ehci-&gt;last_iso_frame = now &gt;&gt; 3;
 	return 0;
 
  fail:
@@ -2220,16 +2215,16 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		now_frame = (uf &gt;&gt; 3) &amp; fmask;
 		live = true;
 	} else  {
-		now_frame = (ehci-&gt;next_frame - 1) &amp; fmask;
+		now_frame = (ehci-&gt;last_iso_frame - 1) &amp; fmask;
 		live = false;
 	}
 	ehci-&gt;now_frame = now_frame;
 
-	frame = ehci-&gt;next_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
 
+		frame = ehci-&gt;last_iso_frame;
 restart:
 		/* scan each element in frame's queue for completions */
 		q_p = &amp;ehci-&gt;pshadow [frame];
@@ -2334,7 +2329,6 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		/* Stop when we have reached the current frame */
 		if (frame == now_frame)
 			break;
-		frame = (frame + 1) &amp; fmask;
+		ehci-&gt;last_iso_frame = (frame + 1) &amp; fmask;
 	}
-	ehci-&gt;next_frame = now_frame;
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index da07d98f7d1d..0564a63f5eb3 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -143,7 +143,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
 	unsigned		now_frame;	/* frame from HC hardware */
-	unsigned		next_frame;	/* scan periodic, start here */
+	unsigned		last_iso_frame;	/* last frame scanned for iso */
 	unsigned		intr_count;	/* intr activity count */
 	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */</pre><hr><pre>commit db5c8b524444d4fc6b1f32d368a50a3729e50002
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 10 14:10:21 2012 -0400

    USB: fix port probing and removal in garmin_gps
    
    This patch (as1615) fixes a bug in the Garmin USB serial driver.  It
    uses attach, disconnect, and release routines to carry out actions
    that should be handled by port_probe and port_remove routines, because
    they access port-specific data.
    
    The bug causes an oops when the device in unplugged, because the
    private data for each port structure now gets erased when the port is
    unbound from the driver, resulting in a null-pointer dereference.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported--by: Markus Schauler &lt;mschauler@gmail.com&gt;
    Tested-by: Markus Schauler &lt;mschauler@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c
index 3ee92648c02d..203358d7e7bc 100644
--- a/drivers/usb/serial/garmin_gps.c
+++ b/drivers/usb/serial/garmin_gps.c
@@ -1405,11 +1405,10 @@ static void timeout_handler(unsigned long data)
 
 
 
-static int garmin_attach(struct usb_serial *serial)
+static int garmin_port_probe(struct usb_serial_port *port)
 {
-	int status = 0;
-	struct usb_serial_port *port = serial-&gt;port[0];
-	struct garmin_data *garmin_data_p = NULL;
+	int status;
+	struct garmin_data *garmin_data_p;
 
 	garmin_data_p = kzalloc(sizeof(struct garmin_data), GFP_KERNEL);
 	if (garmin_data_p == NULL) {
@@ -1434,22 +1433,14 @@ static int garmin_attach(struct usb_serial *serial)
 }
 
 
-static void garmin_disconnect(struct usb_serial *serial)
+static int garmin_port_remove(struct usb_serial_port *port)
 {
-	struct usb_serial_port *port = serial-&gt;port[0];
 	struct garmin_data *garmin_data_p = usb_get_serial_port_data(port);
 
 	usb_kill_urb(port-&gt;interrupt_in_urb);
 	del_timer_sync(&amp;garmin_data_p-&gt;timer);
-}
-
-
-static void garmin_release(struct usb_serial *serial)
-{
-	struct usb_serial_port *port = serial-&gt;port[0];
-	struct garmin_data *garmin_data_p = usb_get_serial_port_data(port);
-
 	kfree(garmin_data_p);
+	return 0;
 }
 
 
@@ -1466,9 +1457,8 @@ static struct usb_serial_driver garmin_device = {
 	.close               = garmin_close,
 	.throttle            = garmin_throttle,
 	.unthrottle          = garmin_unthrottle,
-	.attach              = garmin_attach,
-	.disconnect          = garmin_disconnect,
-	.release             = garmin_release,
+	.port_probe		= garmin_port_probe,
+	.port_remove		= garmin_port_remove,
 	.write               = garmin_write,
 	.write_room          = garmin_write_room,
 	.write_bulk_callback = garmin_write_bulk_callback,</pre>
    <div class="pagination">
        <a href='2_42.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><span>[43]</span><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_44.html'>Next&gt;&gt;</a>
    <div>
</body>
