<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_124.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><span>[125]</span><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_126.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6ad07129a8ed2e13dcd7e6313c201c32bcf7cc32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:59:16 2006 -0400

    [PATCH] usbcore: recovery from Set-Configuration failure
    
    This patch (as703) improves the error handling when a Set-Configuration
    request fails.  The old interfaces are all unregistered before the
    request is sent, and if the request fails then we don't know what config
    the device is using.  So it makes no sense to leave actconfig pointing
    to the old configuration with its invalid interfaces.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index b2f608b0538d..8569600f3130 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1411,15 +1411,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 				return ret;
 			}
 		}
-	}
 
-	/* if it's already configured, clear out old state first.
-	 * getting rid of old interfaces means unbinding their drivers.
-	 */
-	if (dev-&gt;state != USB_STATE_ADDRESS)
-		usb_disable_device (dev, 1);	// Skip ep0
-
-	if (cp) {
 		i = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
 		if (i &lt; 0)
 			dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
@@ -1427,84 +1419,91 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					configuration, -i);
 	}
 
+	/* if it's already configured, clear out old state first.
+	 * getting rid of old interfaces means unbinding their drivers.
+	 */
+	if (dev-&gt;state != USB_STATE_ADDRESS)
+		usb_disable_device (dev, 1);	// Skip ep0
+
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
-			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0)
-		goto free_interfaces;
+			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0) {
+
+		/* All the old state is gone, so what else can we do?
+		 * The device is probably useless now anyway.
+		 */
+		cp = NULL;
+	}
 
 	dev-&gt;actconfig = cp;
-	if (!cp)
+	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
-	else {
-		usb_set_device_state(dev, USB_STATE_CONFIGURED);
+		goto free_interfaces;
+	}
+	usb_set_device_state(dev, USB_STATE_CONFIGURED);
 
-		/* Initialize the new interface structures and the
-		 * hc/hcd/usbcore interface/endpoint state.
-		 */
-		for (i = 0; i &lt; nintf; ++i) {
-			struct usb_interface_cache *intfc;
-			struct usb_interface *intf;
-			struct usb_host_interface *alt;
-
-			cp-&gt;interface[i] = intf = new_interfaces[i];
-			intfc = cp-&gt;intf_cache[i];
-			intf-&gt;altsetting = intfc-&gt;altsetting;
-			intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
-			kref_get(&amp;intfc-&gt;ref);
-
-			alt = usb_altnum_to_altsetting(intf, 0);
-
-			/* No altsetting 0?  We'll assume the first altsetting.
-			 * We could use a GetInterface call, but if a device is
-			 * so non-compliant that it doesn't have altsetting 0
-			 * then I wouldn't trust its reply anyway.
-			 */
-			if (!alt)
-				alt = &amp;intf-&gt;altsetting[0];
-
-			intf-&gt;cur_altsetting = alt;
-			usb_enable_interface(dev, intf);
-			intf-&gt;dev.parent = &amp;dev-&gt;dev;
-			intf-&gt;dev.driver = NULL;
-			intf-&gt;dev.bus = &amp;usb_bus_type;
-			intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
-			intf-&gt;dev.release = release_interface;
-			device_initialize (&amp;intf-&gt;dev);
-			mark_quiesced(intf);
-			sprintf (&amp;intf-&gt;dev.bus_id[0], "%d-%s:%d.%d",
-				 dev-&gt;bus-&gt;busnum, dev-&gt;devpath,
-				 configuration,
-				 alt-&gt;desc.bInterfaceNumber);
-		}
-		kfree(new_interfaces);
+	/* Initialize the new interface structures and the
+	 * hc/hcd/usbcore interface/endpoint state.
+	 */
+	for (i = 0; i &lt; nintf; ++i) {
+		struct usb_interface_cache *intfc;
+		struct usb_interface *intf;
+		struct usb_host_interface *alt;
 
-		if (cp-&gt;string == NULL)
-			cp-&gt;string = usb_cache_string(dev,
-					cp-&gt;desc.iConfiguration);
+		cp-&gt;interface[i] = intf = new_interfaces[i];
+		intfc = cp-&gt;intf_cache[i];
+		intf-&gt;altsetting = intfc-&gt;altsetting;
+		intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
+		kref_get(&amp;intfc-&gt;ref);
 
-		/* Now that all the interfaces are set up, register them
-		 * to trigger binding of drivers to interfaces.  probe()
-		 * routines may install different altsettings and may
-		 * claim() any interfaces not yet bound.  Many class drivers
-		 * need that: CDC, audio, video, etc.
+		alt = usb_altnum_to_altsetting(intf, 0);
+
+		/* No altsetting 0?  We'll assume the first altsetting.
+		 * We could use a GetInterface call, but if a device is
+		 * so non-compliant that it doesn't have altsetting 0
+		 * then I wouldn't trust its reply anyway.
 		 */
-		for (i = 0; i &lt; nintf; ++i) {
-			struct usb_interface *intf = cp-&gt;interface[i];
-
-			dev_dbg (&amp;dev-&gt;dev,
-				"adding %s (config #%d, interface %d)\n",
-				intf-&gt;dev.bus_id, configuration,
-				intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
-			ret = device_add (&amp;intf-&gt;dev);
-			if (ret != 0) {
-				dev_err(&amp;dev-&gt;dev,
-					"device_add(%s) --&gt; %d\n",
-					intf-&gt;dev.bus_id,
-					ret);
-				continue;
-			}
-			usb_create_sysfs_intf_files (intf);
+		if (!alt)
+			alt = &amp;intf-&gt;altsetting[0];
+
+		intf-&gt;cur_altsetting = alt;
+		usb_enable_interface(dev, intf);
+		intf-&gt;dev.parent = &amp;dev-&gt;dev;
+		intf-&gt;dev.driver = NULL;
+		intf-&gt;dev.bus = &amp;usb_bus_type;
+		intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
+		intf-&gt;dev.release = release_interface;
+		device_initialize (&amp;intf-&gt;dev);
+		mark_quiesced(intf);
+		sprintf (&amp;intf-&gt;dev.bus_id[0], "%d-%s:%d.%d",
+			 dev-&gt;bus-&gt;busnum, dev-&gt;devpath,
+			 configuration, alt-&gt;desc.bInterfaceNumber);
+	}
+	kfree(new_interfaces);
+
+	if (cp-&gt;string == NULL)
+		cp-&gt;string = usb_cache_string(dev, cp-&gt;desc.iConfiguration);
+
+	/* Now that all the interfaces are set up, register them
+	 * to trigger binding of drivers to interfaces.  probe()
+	 * routines may install different altsettings and may
+	 * claim() any interfaces not yet bound.  Many class drivers
+	 * need that: CDC, audio, video, etc.
+	 */
+	for (i = 0; i &lt; nintf; ++i) {
+		struct usb_interface *intf = cp-&gt;interface[i];
+
+		dev_dbg (&amp;dev-&gt;dev,
+			"adding %s (config #%d, interface %d)\n",
+			intf-&gt;dev.bus_id, configuration,
+			intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
+		ret = device_add (&amp;intf-&gt;dev);
+		if (ret != 0) {
+			dev_err(&amp;dev-&gt;dev, "device_add(%s) --&gt; %d\n",
+				intf-&gt;dev.bus_id, ret);
+			continue;
 		}
+		usb_create_sysfs_intf_files (intf);
 	}
 
 	return 0;</pre><hr><pre>commit df9a1f482d1252045210f50048911e2efba61e62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:55:28 2006 -0400

    [PATCH] usbhid: use usb_reset_composite_device
    
    This patch (as702) makes usbhid use the new usb_reset_composite_device
    API.  Now HID interfaces can coexist with other interfaces on the same
    device, and a reset can safely be requested by any of the drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index c6051beeabdc..17b6e6ab3703 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -944,21 +944,28 @@ static void hid_reset(void *_hid)
 	dev_dbg(&amp;hid-&gt;intf-&gt;dev, "resetting device\n");
 	rc = rc_lock = usb_lock_device_for_reset(hid-&gt;dev, hid-&gt;intf);
 	if (rc_lock &gt;= 0) {
-		rc = usb_reset_device(hid-&gt;dev);
+		rc = usb_reset_composite_device(hid-&gt;dev, hid-&gt;intf);
 		if (rc_lock)
 			usb_unlock_device(hid-&gt;dev);
 	}
 	clear_bit(HID_RESET_PENDING, &amp;hid-&gt;iofl);
 
-	if (rc == 0) {
-		hid-&gt;retry_delay = 0;
-		if (hid_start_in(hid))
+	switch (rc) {
+	case 0:
+		if (!test_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl))
 			hid_io_error(hid);
-	} else if (!(rc == -ENODEV || rc == -EHOSTUNREACH || rc == -EINTR))
+		break;
+	default:
 		err("can't reset device, %s-%s/input%d, status %d",
 				hid-&gt;dev-&gt;bus-&gt;bus_name,
 				hid-&gt;dev-&gt;devpath,
 				hid-&gt;ifnum, rc);
+		/* FALLTHROUGH */
+	case -EHOSTUNREACH:
+	case -ENODEV:
+	case -EINTR:
+		break;
+	}
 }
 
 /* Main I/O error handler */
@@ -2063,11 +2070,29 @@ static int hid_resume(struct usb_interface *intf)
 	int status;
 
 	clear_bit(HID_SUSPENDED, &amp;hid-&gt;iofl);
+	hid-&gt;retry_delay = 0;
 	status = hid_start_in(hid);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return status;
 }
 
+/* Treat USB reset pretty much the same as suspend/resume */
+static void hid_pre_reset(struct usb_interface *intf)
+{
+	/* FIXME: What if the interface is already suspended? */
+	hid_suspend(intf, PMSG_ON);
+}
+
+static void hid_post_reset(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev (intf);
+
+	hid_set_idle(dev, intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 0, 0);
+	/* FIXME: Any more reinitialization needed? */
+
+	hid_resume(intf);
+}
+
 static struct usb_device_id hid_usb_ids [] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,
 		.bInterfaceClass = USB_INTERFACE_CLASS_HID },
@@ -2082,6 +2107,8 @@ static struct usb_driver hid_driver = {
 	.disconnect =	hid_disconnect,
 	.suspend =	hid_suspend,
 	.resume =	hid_resume,
+	.pre_reset =	hid_pre_reset,
+	.post_reset =	hid_post_reset,
 	.id_table =	hid_usb_ids,
 };
 </pre><hr><pre>commit 47104b0dd32cec467574822b0dc3517b3de3f0ad
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:52:56 2006 -0400

    [PATCH] usb-storage: use usb_reset_composite_device
    
    This patch (as701) modifies usb-storage to take advantage of the new
    usb_reset_composite_device() API.  Now we will be able to safely request
    port resets even if other drivers are bound to a mass-storage device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5f11e19eaae3..5715291ba540 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -286,11 +286,7 @@ static int bus_reset(struct scsi_cmnd *srb)
 	int result;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
-
-	mutex_lock(&amp;(us-&gt;dev_mutex));
 	result = usb_stor_port_reset(us);
-	mutex_unlock(&amp;us-&gt;dev_mutex);
-
 	return result &lt; 0 ? FAILED : SUCCESS;
 }
 
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 038f4582ca0b..19b25c5cafd4 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -703,16 +703,19 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	 * device reset. */
   Handle_Errors:
 
-	/* Let the SCSI layer know we are doing a reset, set the
-	 * RESETTING bit, and clear the ABORTING bit so that the reset
-	 * may proceed. */
+	/* Set the RESETTING bit, and clear the ABORTING bit so that
+	 * the reset may proceed. */
 	scsi_lock(us_to_host(us));
-	usb_stor_report_bus_reset(us);
 	set_bit(US_FLIDX_RESETTING, &amp;us-&gt;flags);
 	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
 	scsi_unlock(us_to_host(us));
 
+	/* We must release the device lock because the pre_reset routine
+	 * will want to acquire it. */
+	mutex_unlock(&amp;us-&gt;dev_mutex);
 	result = usb_stor_port_reset(us);
+	mutex_lock(&amp;us-&gt;dev_mutex);
+
 	if (result &lt; 0) {
 		scsi_lock(us_to_host(us));
 		usb_stor_report_device_reset(us);
@@ -1196,31 +1199,30 @@ int usb_stor_Bulk_reset(struct us_data *us)
 				 0, us-&gt;ifnum, NULL, 0);
 }
 
-/* Issue a USB port reset to the device.  But don't do anything if
- * there's more than one interface in the device, so that other users
- * are not affected. */
+/* Issue a USB port reset to the device.  The caller must not hold
+ * us-&gt;dev_mutex.
+ */
 int usb_stor_port_reset(struct us_data *us)
 {
-	int result, rc;
+	int result, rc_lock;
 
-	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
-		result = -EIO;
-		US_DEBUGP("No reset during disconnect\n");
-	} else if (us-&gt;pusb_dev-&gt;actconfig-&gt;desc.bNumInterfaces != 1) {
-		result = -EBUSY;
-		US_DEBUGP("Refusing to reset a multi-interface device\n");
-	} else {
-		result = rc =
-			usb_lock_device_for_reset(us-&gt;pusb_dev, us-&gt;pusb_intf);
-		if (result &lt; 0) {
-			US_DEBUGP("unable to lock device for reset: %d\n",
-					result);
+	result = rc_lock =
+		usb_lock_device_for_reset(us-&gt;pusb_dev, us-&gt;pusb_intf);
+	if (result &lt; 0)
+		US_DEBUGP("unable to lock device for reset: %d\n", result);
+	else {
+		/* Were we disconnected while waiting for the lock? */
+		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+			result = -EIO;
+			US_DEBUGP("No reset during disconnect\n");
 		} else {
-			result = usb_reset_device(us-&gt;pusb_dev);
-			if (rc)
-				usb_unlock_device(us-&gt;pusb_dev);
-			US_DEBUGP("usb_reset_device returns %d\n", result);
+			result = usb_reset_composite_device(
+					us-&gt;pusb_dev, us-&gt;pusb_intf);
+			US_DEBUGP("usb_reset_composite_device returns %d\n",
+					result);
 		}
+		if (rc_lock)
+			usb_unlock_device(us-&gt;pusb_dev);
 	}
 	return result;
 }
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 0142fe82f6b8..e232c7c89909 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -220,6 +220,37 @@ static int storage_resume(struct usb_interface *iface)
 
 #endif /* CONFIG_PM */
 
+/*
+ * The next two routines get called just before and just after
+ * a USB port reset, whether from this driver or a different one.
+ */
+
+static void storage_pre_reset(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Make sure no command runs during the reset */
+	mutex_lock(&amp;us-&gt;dev_mutex);
+}
+
+static void storage_post_reset(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Report the reset to the SCSI core */
+	scsi_lock(us_to_host(us));
+	usb_stor_report_bus_reset(us);
+	scsi_unlock(us_to_host(us));
+
+	/* FIXME: Notify the subdrivers that they need to reinitialize
+	 * the device */
+	mutex_unlock(&amp;us-&gt;dev_mutex);
+}
+
 /*
  * fill_inquiry_response takes an unsigned char array (which must
  * be at least 36 characters) and populates the vendor name,
@@ -1002,6 +1033,8 @@ static struct usb_driver usb_storage_driver = {
 	.suspend =	storage_suspend,
 	.resume =	storage_resume,
 #endif
+	.pre_reset =	storage_pre_reset,
+	.post_reset =	storage_post_reset,
 	.id_table =	storage_usb_ids,
 };
 </pre><hr><pre>commit 7de18d8bf4b470752e799e219b38b6dff4b49993
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:37:24 2006 -0400

    [PATCH] USB hub: use usb_reset_composite_device
    
    This patch (as700) modifies the hub driver to take advantage of the new
    usb_reset_composite_device API.  The existing code had special-case
    calls stuck into usb_reset_device, just before and after the reset.
    With the new version there's no need for special-case stuff; it all
    happens naturally in the form of pre_reset and post_reset notifications.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 37c67d7e8b84..e1731ff8af4d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -525,15 +525,16 @@ static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 
 
 /* caller has locked the hub device */
-static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
+static void hub_pre_reset(struct usb_interface *intf)
 {
+	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
 		if (hdev-&gt;children[port1 - 1]) {
 			usb_disconnect(&amp;hdev-&gt;children[port1 - 1]);
-			if (disable_ports)
+			if (hub-&gt;error == 0)
 				hub_port_disable(hub, port1, 0);
 		}
 	}
@@ -541,8 +542,10 @@ static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
 }
 
 /* caller has locked the hub device */
-static void hub_post_reset(struct usb_hub *hub)
+static void hub_post_reset(struct usb_interface *intf)
 {
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
 	hub_activate(hub);
 	hub_power_on(hub);
 }
@@ -802,15 +805,16 @@ static void hub_disconnect(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
 
+	/* Disconnect all children and quiesce the hub */
+	hub-&gt;error = 0;
+	hub_pre_reset(intf);
+
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	/* Disconnect all children and quiesce the hub */
-	hub_pre_reset(hub, 1);
-
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
 
@@ -2747,7 +2751,8 @@ static void hub_events(void)
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
-			hub_pre_reset(hub, 0);
+			hub-&gt;error = -ENODEV;
+			hub_pre_reset(intf);
 			goto loop;
 		}
 
@@ -2759,7 +2764,7 @@ static void hub_events(void)
 			dev_dbg (hub_dev, "resetting for error %d\n",
 				hub-&gt;error);
 
-			ret = usb_reset_device(hdev);
+			ret = usb_reset_composite_device(hdev, intf);
 			if (ret) {
 				dev_dbg (hub_dev,
 					"error resetting hub: %d\n", ret);
@@ -2928,6 +2933,8 @@ static struct usb_driver hub_driver = {
 	.disconnect =	hub_disconnect,
 	.suspend =	hub_suspend,
 	.resume =	hub_resume,
+	.pre_reset =	hub_pre_reset,
+	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
 	.id_table =	hub_id_table,
 };
@@ -3033,7 +3040,6 @@ int usb_reset_device(struct usb_device *udev)
 	struct usb_device		*parent_hdev = udev-&gt;parent;
 	struct usb_hub			*parent_hub;
 	struct usb_device_descriptor	descriptor = udev-&gt;descriptor;
-	struct usb_hub			*hub = NULL;
 	int 				i, ret = 0;
 	int				port1 = udev-&gt;portnum;
 
@@ -3051,14 +3057,6 @@ int usb_reset_device(struct usb_device *udev)
 	}
 	parent_hub = hdev_to_hub(parent_hdev);
 
-	/* If we're resetting an active hub, take some special actions */
-	if (udev-&gt;actconfig &amp;&amp; udev-&gt;actconfig-&gt;desc.bNumInterfaces &gt; 0 &amp;&amp;
-			udev-&gt;actconfig-&gt;interface[0]-&gt;dev.driver ==
-				&amp;hub_driver.driver &amp;&amp;
-			(hub = hdev_to_hub(udev)) != NULL) {
-		hub_pre_reset(hub, 0);
-	}
-
 	set_bit(port1, parent_hub-&gt;busy_bits);
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
@@ -3117,8 +3115,6 @@ int usb_reset_device(struct usb_device *udev)
 	}
 
 done:
-	if (hub)
-		hub_post_reset(hub);
 	return 0;
  
 re_enumerate:</pre><hr><pre>commit 79efa097e75018a2918155f343f0e08e61ee8a8c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:33:42 2006 -0400

    [PATCH] usbcore: port reset for composite devices
    
    This patch (as699) adds usb_reset_composite_device(), a routine for
    sending a USB port reset to a device with multiple interfaces owned by
    different drivers.  Drivers are notified about impending and completed
    resets through two new methods in the usb_driver structure.
    
    The patch modifieds the usbfs ioctl code to make it use the new routine
    instead of usb_reset_device().  Follow-up patches will modify the hub,
    usb-storage, and usbhid drivers so they can utilize this new API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b04ede772f2c..df3fb57d71e6 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -823,8 +823,7 @@ static int proc_connectinfo(struct dev_state *ps, void __user *arg)
 
 static int proc_resetdevice(struct dev_state *ps)
 {
-	return usb_reset_device(ps-&gt;dev);
-
+	return usb_reset_composite_device(ps-&gt;dev, NULL);
 }
 
 static int proc_setintf(struct dev_state *ps, void __user *arg)
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f41c08946a52..37c67d7e8b84 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3007,9 +3007,9 @@ static int config_descriptors_changed(struct usb_device *udev)
  * usb_reset_device - perform a USB port reset to reinitialize a device
  * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
  *
- * WARNING - don't reset any device unless drivers for all of its
- * interfaces are expecting that reset!  Maybe some driver-&gt;reset()
- * method should eventually help ensure sufficient cooperation.
+ * WARNING - don't use this routine to reset a composite device
+ * (one with multiple interfaces owned by separate drivers)!
+ * Use usb_reset_composite_device() instead.
  *
  * Do a port reset, reassign the device's address, and establish its
  * former operating configuration.  If the reset fails, or the device's
@@ -3125,3 +3125,81 @@ int usb_reset_device(struct usb_device *udev)
 	hub_port_logical_disconnect(parent_hub, port1);
 	return -ENODEV;
 }
+
+/**
+ * usb_reset_composite_device - warn interface drivers and perform a USB port reset
+ * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
+ * @iface: interface bound to the driver making the request (optional)
+ *
+ * Warns all drivers bound to registered interfaces (using their pre_reset
+ * method), performs the port reset, and then lets the drivers know that
+ * the reset is over (using their post_reset method).
+ *
+ * Return value is the same as for usb_reset_device().
+ *
+ * The caller must own the device lock.  For example, it's safe to use
+ * this from a driver probe() routine after downloading new firmware.
+ * For calls that might not occur during probe(), drivers should lock
+ * the device using usb_lock_device_for_reset().
+ *
+ * The interface locks are acquired during the pre_reset stage and released
+ * during the post_reset stage.  However if iface is not NULL and is
+ * currently being probed, we assume that the caller already owns its
+ * lock.
+ */
+int usb_reset_composite_device(struct usb_device *udev,
+		struct usb_interface *iface)
+{
+	int ret;
+	struct usb_host_config *config = udev-&gt;actconfig;
+
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state == USB_STATE_SUSPENDED) {
+		dev_dbg(&amp;udev-&gt;dev, "device reset not allowed in state %d\n",
+				udev-&gt;state);
+		return -EINVAL;
+	}
+
+	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
+		iface = NULL;
+
+	if (config) {
+		int i;
+		struct usb_interface *cintf;
+		struct usb_driver *drv;
+
+		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
+			cintf = config-&gt;interface[i];
+			if (cintf != iface)
+				down(&amp;cintf-&gt;dev.sem);
+			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
+					cintf-&gt;dev.driver) {
+				drv = to_usb_driver(cintf-&gt;dev.driver);
+				if (drv-&gt;pre_reset)
+					(drv-&gt;pre_reset)(cintf);
+			}
+		}
+	}
+
+	ret = usb_reset_device(udev);
+
+	if (config) {
+		int i;
+		struct usb_interface *cintf;
+		struct usb_driver *drv;
+
+		for (i = config-&gt;desc.bNumInterfaces - 1; i &gt;= 0; --i) {
+			cintf = config-&gt;interface[i];
+			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
+					cintf-&gt;dev.driver) {
+				drv = to_usb_driver(cintf-&gt;dev.driver);
+				if (drv-&gt;post_reset)
+					(drv-&gt;post_reset)(cintf);
+			}
+			if (cintf != iface)
+				up(&amp;cintf-&gt;dev.sem);
+		}
+	}
+
+	return ret;
+}
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b7fdc1cd134a..515310751303 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1207,6 +1207,7 @@ EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
 
 EXPORT_SYMBOL(usb_reset_device);
+EXPORT_SYMBOL(usb_reset_composite_device);
 
 EXPORT_SYMBOL(__usb_get_extra_descriptor);
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 317ec9f28bce..5ad30cefe7b2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -386,6 +386,8 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
+extern int usb_reset_composite_device(struct usb_device *dev,
+		struct usb_interface *iface);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
@@ -554,6 +556,10 @@ struct usb_dynids {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @pre_reset: Called by usb_reset_composite_device() when the device
+ *	is about to be reset.
+ * @post_reset: Called by usb_reset_composite_device() after the device
+ *	has been reset.
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
@@ -592,6 +598,9 @@ struct usb_driver {
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
 
+	void (*pre_reset) (struct usb_interface *intf);
+	void (*post_reset) (struct usb_interface *intf);
+
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;</pre><hr><pre>commit 633a7ecf89587879161179ac4f5a03722626866f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 30 10:21:14 2006 -0400

    [PATCH] usbhid: Remove unneeded blacklist entries
    
    Now that usbhid automatically applies HID_QUIRK_NOGET to keyboards and
    mice, we no longer need the blacklist entries that were present for no
    other purpose.  This patch (as698) removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Vojtech Pavlik &lt;vojtech@suse.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index 061002fc66fc..c6051beeabdc 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1374,9 +1374,6 @@ void hid_close(struct hid_device *hid)
 
 #define USB_VENDOR_ID_PANJIT		0x134c
 
-#define USB_VENDOR_ID_SILVERCREST	0x062a
-#define USB_DEVICE_ID_SILVERCREST_KB	0x0201
-
 /*
  * Initialize all reports
  */
@@ -1461,9 +1458,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_VENDOR_ID_ONTRAK		0x0a07
 #define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
 
-#define USB_VENDOR_ID_TANGTOP		0x0d3d
-#define USB_DEVICE_ID_TANGTOP_USBPS2	0x0001
-
 #define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
 #define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
 
@@ -1520,12 +1514,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
 #define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
 
-#define USB_VENDOR_ID_CHICONY		0x04f2
-#define USB_DEVICE_ID_CHICONY_USBHUB_KB	0x0100
-
-#define USB_VENDOR_ID_BTC		0x046e
-#define USB_DEVICE_ID_BTC_KEYBOARD	0x5303
-
 #define USB_VENDOR_ID_VERNIER		0x08f7
 #define USB_DEVICE_ID_VERNIER_LABPRO	0x0001
 #define USB_DEVICE_ID_VERNIER_GOTEMP	0x0002
@@ -1554,15 +1542,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_VENDOR_ID_CHERRY		0x046a
 #define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
 
-#define USB_VENDOR_ID_HP		0x03f0
-#define USB_DEVICE_ID_HP_USBHUB_KB	0x020c
-
-#define USB_VENDOR_ID_IBM		0x04b3
-#define USB_DEVICE_ID_IBM_USBHUB_KB	0x3005
-
-#define USB_VENDOR_ID_CREATIVELABS	0x062a
-#define USB_DEVICE_ID_CREATIVELABS_SILVERCREST	0x0201
-
 #define USB_VENDOR_ID_YEALINK		0x6993
 #define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K	0xb001
 /*
@@ -1683,14 +1662,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVMC, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_KEYBOARD, HID_QUIRK_NOGET},
-	{ USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_USBHUB_KB, HID_QUIRK_NOGET},
-	{ USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_CREATIVELABS_SILVERCREST, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_HP, USB_DEVICE_ID_HP_USBHUB_KB, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_USBHUB_KB, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_TANGTOP, USB_DEVICE_ID_TANGTOP_USBPS2, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD, HID_QUIRK_NOGET | HID_QUIRK_MULTI_INPUT },
-	{ USB_VENDOR_ID_SILVERCREST, USB_DEVICE_ID_SILVERCREST_KB, HID_QUIRK_NOGET },
 
 	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE, HID_QUIRK_MIGHTYMOUSE | HID_QUIRK_INVERT_HWHEEL },
 	{ USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU, HID_QUIRK_2WHEEL_MOUSE_HACK_7 },</pre><hr><pre>commit 9da2150f59e885d88b9eabe0a677f0fa4962f7b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 16:47:13 2006 -0400

    [PATCH] usbtest: report errors in iso tests
    
    This patch (as693b) makes the usbtest driver report errors in the
    isochronous bulk transfer tests instead of always returning 0.  As an
    arbitrary cutoff, an error is returned if more than 10% of the packet
    transfers fail.  It also stops a test immediately upon receiving an URB
    submission error.
    
    For a test harness, it's especially important to report when errors occur!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b42ae6bfb12b..81ba14c73dc7 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1337,7 +1337,9 @@ struct iso_context {
 	unsigned		pending;
 	spinlock_t		lock;
 	struct completion	done;
+	int			submit_error;
 	unsigned long		errors;
+	unsigned long		packet_count;
 	struct usbtest_dev	*dev;
 };
 
@@ -1348,10 +1350,14 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	spin_lock(&amp;ctx-&gt;lock);
 	ctx-&gt;count--;
 
+	ctx-&gt;packet_count += urb-&gt;number_of_packets;
 	if (urb-&gt;error_count &gt; 0)
 		ctx-&gt;errors += urb-&gt;error_count;
+	else if (urb-&gt;status != 0)
+		ctx-&gt;errors += urb-&gt;number_of_packets;
 
-	if (urb-&gt;status == 0 &amp;&amp; ctx-&gt;count &gt; (ctx-&gt;pending - 1)) {
+	if (urb-&gt;status == 0 &amp;&amp; ctx-&gt;count &gt; (ctx-&gt;pending - 1)
+			&amp;&amp; !ctx-&gt;submit_error) {
 		int status = usb_submit_urb (urb, GFP_ATOMIC);
 		switch (status) {
 		case 0:
@@ -1362,6 +1368,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 					status);
 			/* FALLTHROUGH */
 		case -ENODEV:			/* disconnected */
+		case -ESHUTDOWN:		/* endpoint disabled */
+			ctx-&gt;submit_error = 1;
 			break;
 		}
 	}
@@ -1371,8 +1379,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	if (ctx-&gt;pending == 0) {
 		if (ctx-&gt;errors)
 			dev_dbg (&amp;ctx-&gt;dev-&gt;intf-&gt;dev,
-				"iso test, %lu errors\n",
-				ctx-&gt;errors);
+				"iso test, %lu errors out of %lu\n",
+				ctx-&gt;errors, ctx-&gt;packet_count);
 		complete (&amp;ctx-&gt;done);
 	}
 done:
@@ -1433,15 +1441,14 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 	struct usb_device	*udev;
 	unsigned		i;
 	unsigned long		packets = 0;
-	int			status;
+	int			status = 0;
 	struct urb		*urbs[10];	/* FIXME no limit */
 
 	if (param-&gt;sglen &gt; 10)
 		return -EDOM;
 
+	memset(&amp;context, 0, sizeof context);
 	context.count = param-&gt;iterations * param-&gt;sglen;
-	context.pending = param-&gt;sglen;
-	context.errors = 0;
 	context.dev = dev;
 	init_completion (&amp;context.done);
 	spin_lock_init (&amp;context.lock);
@@ -1473,6 +1480,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 	spin_lock_irq (&amp;context.lock);
 	for (i = 0; i &lt; param-&gt;sglen; i++) {
+		++context.pending;
 		status = usb_submit_urb (urbs [i], SLAB_ATOMIC);
 		if (status &lt; 0) {
 			ERROR (dev, "submit iso[%d], error %d\n", i, status);
@@ -1483,12 +1491,26 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 			simple_free_urb (urbs [i]);
 			context.pending--;
+			context.submit_error = 1;
+			break;
 		}
 	}
 	spin_unlock_irq (&amp;context.lock);
 
 	wait_for_completion (&amp;context.done);
-	return 0;
+
+	/*
+	 * Isochronous transfers are expected to fail sometimes.  As an
+	 * arbitrary limit, we will report an error if any submissions
+	 * fail or if the transfer failure rate is &gt; 10%.
+	 */
+	if (status != 0)
+		;
+	else if (context.submit_error)
+		status = -EACCES;
+	else if (context.errors &gt; context.packet_count / 10)
+		status = -EIO;
+	return status;
 
 fail:
 	for (i = 0; i &lt; param-&gt;sglen; i++) {</pre><hr><pre>commit 0ae4ea8092e1277cfca07cade7eaba5f594076c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 12:27:38 2006 -0400

    [PATCH] gadgetfs: fix memory leaks
    
    This patch (as692) fixes a few memory leaks in some unimportant error
    pathways of the gadgetfs driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 57bf24810f9b..aef0722b8f17 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -1038,7 +1038,7 @@ ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
 		/* ep0 can't deliver events when STATE_SETUP */
 		for (i = 0; i &lt; n; i++) {
 			if (dev-&gt;event [i].type == GADGETFS_SETUP) {
-				len = n = i + 1;
+				len = i + 1;
 				len *= sizeof (struct usb_gadgetfs_event);
 				n = 0;
 				break;
@@ -1586,13 +1586,13 @@ gadgetfs_create_file (struct super_block *sb, char const *name,
 static int activate_ep_files (struct dev_data *dev)
 {
 	struct usb_ep	*ep;
+	struct ep_data	*data;
 
 	gadget_for_each_ep (ep, dev-&gt;gadget) {
-		struct ep_data	*data;
 
 		data = kzalloc(sizeof(*data), GFP_KERNEL);
 		if (!data)
-			goto enomem;
+			goto enomem0;
 		data-&gt;state = STATE_EP_DISABLED;
 		init_MUTEX (&amp;data-&gt;lock);
 		init_waitqueue_head (&amp;data-&gt;wait);
@@ -1607,21 +1607,23 @@ static int activate_ep_files (struct dev_data *dev)
 
 		data-&gt;req = usb_ep_alloc_request (ep, GFP_KERNEL);
 		if (!data-&gt;req)
-			goto enomem;
+			goto enomem1;
 
 		data-&gt;inode = gadgetfs_create_file (dev-&gt;sb, data-&gt;name,
 				data, &amp;ep_config_operations,
 				&amp;data-&gt;dentry);
-		if (!data-&gt;inode) {
-			usb_ep_free_request(ep, data-&gt;req);
-			kfree (data);
-			goto enomem;
-		}
+		if (!data-&gt;inode)
+			goto enomem2;
 		list_add_tail (&amp;data-&gt;epfiles, &amp;dev-&gt;epfiles);
 	}
 	return 0;
 
-enomem:
+enomem2:
+	usb_ep_free_request (ep, data-&gt;req);
+enomem1:
+	put_dev (dev);
+	kfree (data);
+enomem0:
 	DBG (dev, "%s enomem\n", __FUNCTION__);
 	destroy_ep_files (dev);
 	return -ENOMEM;
@@ -1792,7 +1794,7 @@ static struct usb_gadget_driver probe_driver = {
  *
  * After initialization, the device stays active for as long as that
  * $CHIP file is open.  Events may then be read from that descriptor,
- * such configuration notifications.  More complex drivers will handle
+ * such as configuration notifications.  More complex drivers will handle
  * some control requests in user space.
  */
 
@@ -2032,12 +2034,10 @@ gadgetfs_fill_super (struct super_block *sb, void *opts, int silent)
 			NULL, &amp;simple_dir_operations,
 			S_IFDIR | S_IRUGO | S_IXUGO);
 	if (!inode)
-		return -ENOMEM;
+		goto enomem0;
 	inode-&gt;i_op = &amp;simple_dir_inode_operations;
-	if (!(d = d_alloc_root (inode))) {
-		iput (inode);
-		return -ENOMEM;
-	}
+	if (!(d = d_alloc_root (inode)))
+		goto enomem1;
 	sb-&gt;s_root = d;
 
 	/* the ep0 file is named after the controller we expect;
@@ -2045,21 +2045,28 @@ gadgetfs_fill_super (struct super_block *sb, void *opts, int silent)
 	 */
 	dev = dev_new ();
 	if (!dev)
-		return -ENOMEM;
+		goto enomem2;
 
 	dev-&gt;sb = sb;
-	if (!(inode = gadgetfs_create_file (sb, CHIP,
+	if (!gadgetfs_create_file (sb, CHIP,
 				dev, &amp;dev_init_operations,
-				&amp;dev-&gt;dentry))) {
-		put_dev(dev);
-		return -ENOMEM;
-	}
+				&amp;dev-&gt;dentry))
+		goto enomem3;
 
 	/* other endpoint files are available after hardware setup,
 	 * from binding to a controller.
 	 */
 	the_device = dev;
 	return 0;
+
+enomem3:
+	put_dev (dev);
+enomem2:
+	dput (d);
+enomem1:
+	iput (inode);
+enomem0:
+	return -ENOMEM;
 }
 
 /* "mount -t gadgetfs path /dev/gadget" ends up here */</pre><hr><pre>commit 83196b52053068f0240371ad2efd9d6ad685bbeb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 12:26:31 2006 -0400

    [PATCH] gadgetfs: fix AIO interface bugs
    
    This patch (as691) fixes a few errors in the AIO interface for the
    gadgetfs driver.  Now requests will complete properly instead of hanging.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 0eb010a3f5bc..57bf24810f9b 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -528,7 +528,7 @@ struct kiocb_priv {
 	struct usb_request	*req;
 	struct ep_data		*epdata;
 	void			*buf;
-	char __user		*ubuf;
+	char __user		*ubuf;		/* NULL for writes */
 	unsigned		actual;
 };
 
@@ -566,7 +566,6 @@ static ssize_t ep_aio_read_retry(struct kiocb *iocb)
 		status = priv-&gt;actual;
 	kfree(priv-&gt;buf);
 	kfree(priv);
-	aio_put_req(iocb);
 	return status;
 }
 
@@ -580,8 +579,8 @@ static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
 	spin_lock(&amp;epdata-&gt;dev-&gt;lock);
 	priv-&gt;req = NULL;
 	priv-&gt;epdata = NULL;
-	if (NULL == iocb-&gt;ki_retry
-			|| unlikely(0 == req-&gt;actual)
+	if (priv-&gt;ubuf == NULL
+			|| unlikely(req-&gt;actual == 0)
 			|| unlikely(kiocbIsCancelled(iocb))) {
 		kfree(req-&gt;buf);
 		kfree(priv);
@@ -618,7 +617,7 @@ ep_aio_rwtail(
 	char __user	*ubuf
 )
 {
-	struct kiocb_priv	*priv = (void *) &amp;iocb-&gt;private;
+	struct kiocb_priv	*priv;
 	struct usb_request	*req;
 	ssize_t			value;
 
@@ -670,7 +669,7 @@ ep_aio_rwtail(
 		kfree(priv);
 		put_ep(epdata);
 	} else
-		value = -EIOCBQUEUED;
+		value = (ubuf ? -EIOCBRETRY : -EIOCBQUEUED);
 	return value;
 }
 </pre><hr><pre>commit c8155cc5d839838f8425dbea568fc537337176a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:52:35 2006 -0400

    [PATCH] UHCI: remove ISO TDs as they are used
    
    This patch (as690) does the same thing for ISO TDs as as680 did for
    non-ISO TDs: free them as they are used rather than all at once when an
    URB is complete.  At the same time it fixes a minor buglet (I'm not
    aware of it ever affecting anyone): An ISO TD should be retired when its
    frame is over, regardless of whether or not the hardware has marked it
    inactive.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index ab8ba8220ad1..6637a0e49978 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -127,7 +127,8 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 
 	i = nactive = ninactive = 0;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		if (++i &lt;= 10 || debug &gt; 2) {
+		if (urbp-&gt;qh-&gt;type != USB_ENDPOINT_XFER_ISOC &amp;&amp;
+				(++i &lt;= 10 || debug &gt; 2)) {
 			out += sprintf(out, "%*s%d: ", space + 2, "", i);
 			out += uhci_show_td(td, out, len - (out - buf), 0);
 		} else {
@@ -168,8 +169,9 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		out += sprintf(out, "%*s    period %d\n",
-				space, "", qh-&gt;period);
+		out += sprintf(out, "%*s    period %d frame %x desc [%p]\n",
+				space, "", qh-&gt;period, qh-&gt;iso_frame,
+				qh-&gt;iso_packet_desc);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
@@ -331,8 +333,10 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "  sof       =       %02x\n", sof);
 	out += uhci_show_sc(1, portsc1, out, len - (out - buf));
 	out += uhci_show_sc(2, portsc2, out, len - (out - buf));
-	out += sprintf(out, "Most recent frame: %x\n",
-			uhci-&gt;frame_number);
+	out += sprintf(out, "Most recent frame: %x (%d)   "
+			"Last ISO frame: %x (%d)\n",
+			uhci-&gt;frame_number, uhci-&gt;frame_number &amp; 1023,
+			uhci-&gt;last_iso_frame, uhci-&gt;last_iso_frame &amp; 1023);
 
 	return out - buf;
 }
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index eaac6ddf03a0..469b4268b850 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -128,8 +128,6 @@ struct uhci_qh {
 	__le32 element;			/* Queue element (TD) pointer */
 
 	/* Software fields */
-	dma_addr_t dma_handle;
-
 	struct list_head node;		/* Node in the list of QHs */
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
@@ -138,13 +136,19 @@ struct uhci_qh {
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
+	struct usb_iso_packet_descriptor *iso_packet_desc;
+					/* Next urb-&gt;iso_frame_desc entry */
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	unsigned int period;		/* For Interrupt and Isochronous QHs */
+	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
+	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
+	dma_addr_t dma_handle;
+
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
@@ -386,6 +390,8 @@ struct uhci_hcd {
 	unsigned int frame_number;		/* As of last check */
 	unsigned int is_stopped;
 #define UHCI_IS_STOPPED		9999		/* Larger than a frame # */
+	unsigned int last_iso_frame;		/* Frame of last scan */
+	unsigned int cur_iso_frame;		/* Frame for current scan */
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 7acc23473c63..cbbaa4c1740f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -184,6 +184,24 @@ static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
 	td-&gt;frame = -1;
 }
 
+static inline void uhci_remove_tds_from_frame(struct uhci_hcd *uhci,
+		unsigned int framenum)
+{
+	struct uhci_td *ftd, *ltd;
+
+	framenum &amp;= (UHCI_NUMFRAMES - 1);
+
+	ftd = uhci-&gt;frame_cpu[framenum];
+	if (ftd) {
+		ltd = list_entry(ftd-&gt;fl_list.prev, struct uhci_td, fl_list);
+		uhci-&gt;frame[framenum] = ltd-&gt;link;
+		uhci-&gt;frame_cpu[framenum] = NULL;
+
+		while (!list_empty(&amp;ftd-&gt;fl_list))
+			list_del_init(ftd-&gt;fl_list.prev);
+	}
+}
+
 /*
  * Remove all the TDs for an Isochronous URB from the frame list
  */
@@ -523,7 +541,6 @@ static int uhci_map_status(int status, int dir_out)
 		return -ENOSR;
 	if (status &amp; TD_CTRL_STALLED)			/* Stalled */
 		return -EPIPE;
-	WARN_ON(status &amp; TD_CTRL_ACTIVE);		/* Active */
 	return 0;
 }
 
@@ -960,12 +977,12 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		return -EFBIG;
 
 	/* Check the period and figure out the starting frame number */
-	uhci_get_current_frame_number(uhci);
 	if (qh-&gt;period == 0) {
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			uhci_get_current_frame_number(uhci);
 			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
 		} else {
-			i = urb-&gt;start_frame - uhci-&gt;frame_number;
+			i = urb-&gt;start_frame - uhci-&gt;last_iso_frame;
 			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
 				return -EINVAL;
 		}
@@ -974,7 +991,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 
 	} else {	/* Pick up where the last URB leaves off */
 		if (list_empty(&amp;qh-&gt;queue)) {
-			frame = uhci-&gt;frame_number + 10;
+			frame = qh-&gt;iso_frame;
 		} else {
 			struct urb *lurb;
 
@@ -986,11 +1003,12 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		}
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
 			urb-&gt;start_frame = frame;
-		/* FIXME: Sanity check */
+		else if (urb-&gt;start_frame != frame)
+			return -EINVAL;
 	}
 
 	/* Make sure we won't have to go too far into the future */
-	if (uhci_frame_before_eq(uhci-&gt;frame_number + UHCI_NUMFRAMES,
+	if (uhci_frame_before_eq(uhci-&gt;last_iso_frame + UHCI_NUMFRAMES,
 			urb-&gt;start_frame + urb-&gt;number_of_packets *
 				urb-&gt;interval))
 		return -EFBIG;
@@ -1020,7 +1038,13 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	frame = urb-&gt;start_frame;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
 		uhci_insert_td_in_frame_list(uhci, td, frame);
-		frame += urb-&gt;interval;
+		frame += qh-&gt;period;
+	}
+
+	if (list_empty(&amp;qh-&gt;queue)) {
+		qh-&gt;iso_packet_desc = &amp;urb-&gt;iso_frame_desc[0];
+		qh-&gt;iso_frame = urb-&gt;start_frame;
+		qh-&gt;iso_status = 0;
 	}
 
 	return 0;
@@ -1028,37 +1052,44 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 
 static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 {
-	struct uhci_td *td;
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	int status;
-	int i, ret = 0;
-
-	urb-&gt;actual_length = urb-&gt;error_count = 0;
+	struct uhci_td *td, *tmp;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+	struct uhci_qh *qh = urbp-&gt;qh;
 
-	i = 0;
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
+	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
+		unsigned int ctrlstat;
+		int status;
 		int actlength;
-		unsigned int ctrlstat = td_status(td);
 
-		if (ctrlstat &amp; TD_CTRL_ACTIVE)
+		if (uhci_frame_before_eq(uhci-&gt;cur_iso_frame, qh-&gt;iso_frame))
 			return -EINPROGRESS;
 
-		actlength = uhci_actual_length(ctrlstat);
-		urb-&gt;iso_frame_desc[i].actual_length = actlength;
-		urb-&gt;actual_length += actlength;
+		uhci_remove_tds_from_frame(uhci, qh-&gt;iso_frame);
+
+		ctrlstat = td_status(td);
+		if (ctrlstat &amp; TD_CTRL_ACTIVE) {
+			status = -EXDEV;	/* TD was added too late? */
+		} else {
+			status = uhci_map_status(uhci_status_bits(ctrlstat),
+					usb_pipeout(urb-&gt;pipe));
+			actlength = uhci_actual_length(ctrlstat);
+
+			urb-&gt;actual_length += actlength;
+			qh-&gt;iso_packet_desc-&gt;actual_length = actlength;
+			qh-&gt;iso_packet_desc-&gt;status = status;
+		}
 
-		status = uhci_map_status(uhci_status_bits(ctrlstat),
-				usb_pipeout(urb-&gt;pipe));
-		urb-&gt;iso_frame_desc[i].status = status;
 		if (status) {
 			urb-&gt;error_count++;
-			ret = status;
+			qh-&gt;iso_status = status;
 		}
 
-		i++;
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
+		qh-&gt;iso_frame += qh-&gt;period;
+		++qh-&gt;iso_packet_desc;
 	}
-
-	return ret;
+	return qh-&gt;iso_status;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
@@ -1119,6 +1150,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 		}
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
+		urb-&gt;error_count = 0;
 		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 		if (bustime &lt; 0) {
 			ret = bustime;
@@ -1200,9 +1232,18 @@ __acquires(uhci-&gt;lock)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	/* Isochronous TDs get unlinked directly from the frame list */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		uhci_unlink_isochronous_tds(uhci, urb);
+	/* When giving back the first URB in an Isochronous queue,
+	 * reinitialize the QH's iso-related members for the next URB. */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+			urbp-&gt;node.prev == &amp;qh-&gt;queue &amp;&amp;
+			urbp-&gt;node.next != &amp;qh-&gt;queue) {
+		struct urb *nurb = list_entry(urbp-&gt;node.next,
+				struct urb_priv, node)-&gt;urb;
+
+		qh-&gt;iso_packet_desc = &amp;nurb-&gt;iso_frame_desc[0];
+		qh-&gt;iso_frame = nurb-&gt;start_frame;
+		qh-&gt;iso_status = 0;
+	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
 	 * this is a perfect time for a toggle fixup. */
@@ -1434,6 +1475,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
+	uhci-&gt;cur_iso_frame = uhci-&gt;frame_number;
 
 	/* Go through all the QH queues and process the URBs in each one */
 	for (i = 0; i &lt; UHCI_NUM_SKELQH - 1; ++i) {
@@ -1451,6 +1493,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		}
 	}
 
+	uhci-&gt;last_iso_frame = uhci-&gt;cur_iso_frame;
 	if (uhci-&gt;need_rescan)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;</pre>
    <div class="pagination">
        <a href='2_124.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><span>[125]</span><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_126.html'>Next&gt;&gt;</a>
    <div>
</body>
